from __future__ import annotations

import typing
from abc import abstractmethod, abstractproperty
from collections.abc import Set
from copy import copy as copy_func
from typing import Iterable, Sized, Protocol, Collection, TypeVar, Literal, Mapping, Self, Any

import pandas as pd

from mdata.core.header import DatapointSpec
from mdata.core.shared_defs import SpecType, SeriesFeatureLabels, ObservationSpecIdentifier
from mdata.core.util import Copyable, SlimMapping, intersection, symmetric_difference

P = typing.ParamSpec('P')

Identifier = TypeVar('Identifier', covariant=True)
BaseSpec = TypeVar('BaseSpec', bound=DatapointSpec, covariant=True)


@typing.runtime_checkable
class SeriesSpecProtocol(Iterable[str], Sized, Copyable, Protocol[Identifier, BaseSpec]):
    """
    Immutable object containing information derived from a datapoint spec.
    Used to store auxiliary structural metadata related to a dataframe.
    """

    @classmethod
    def of(cls, label: SpecType, base_spec: BaseSpec) -> Self:
        """Create a new instance from a label and base `DatapointSpec`."""
        ...

    @property
    @abstractmethod
    def identifier(self) -> Identifier:
        """The identifier of this spec."""
        ...

    @property
    @abstractmethod
    def type_name(self) -> SpecType:
        """The type of this series spec."""
        ...

    @property
    @abstractmethod
    def base(self) -> BaseSpec:
        """The underlying `DatapointSpec` as defined a Machine Data header."""
        ...

    @property
    @abstractmethod
    def features(self) -> SeriesFeatureLabels:
        """The names of the features of this spec."""
        ...

    @property
    @abstractmethod
    def feature_count(self) -> int:
        """The number of features in this spec."""
        ...

    @property
    @abstractmethod
    def long_names(self) -> SeriesFeatureLabels:
        """
        The long names of the features. Intended to be more human-readable.
        Equal to the basic feature names if not explicitly specified in the metadata of a Machine Data header.
        """
        ...

    @abstractmethod
    def feature_intersection(self, other: Self) -> list[str]:
        """Returns the features defined in both `self` and `other`."""
        ...

    @abstractmethod
    def feature_symmetric_difference(self, other: Self) -> tuple[list[str], list[str]]:
        """Returns a tuple of features defined in one but not the other spec."""
        ...

    @abstractmethod
    def project(self, feature_selection: bool | str | Collection[str]) -> Self:
        """
        Project the spec to a subset of its features.

        :param feature_selection: if boolean, the selection is True/False = all/no features, if str, a singular feature
        """
        ...

    @abstractmethod
    def is_mergeable(self, other: Self) -> bool:
        """Decides whether `self` and `other` are mergeable, i.e., whether both spec identifiers are equal."""
        ...

    @abstractmethod
    def merge(self, other: Self) -> Self:
        """
        Merge `self` and `other` by appending the feature definitions of `other` that are not already in `self`.
        A new instance is created.

        :raises: `SeriesSpecMergeException`
        """
        ...


SSpec = TypeVar('SSpec', bound=SeriesSpecProtocol[ObservationSpecIdentifier, DatapointSpec], covariant=True)

class SeriesViewProtocol(Sized, Protocol[SSpec]):
    """
    An immutable representation of a view on a collection of data points through a specific series spec.
    Typically generated by `SeriesContainerProtocol` implementations and not end-users.
    """

    @property
    @abstractmethod
    def series_spec(self) -> SSpec:
        """
        The series spec describing the contained observations' features, i.e., columns in `self.df`.

        :rtype: an implementation of `SeriesSpecProtocol`
        """
        ...

    @property
    @abstractmethod
    def df(self) -> pd.DataFrame:
        """The actual dataframe holding the observation data."""
        ...

    @classmethod
    @abstractmethod
    def of(cls, series_spec: SSpec, df: pd.DataFrame, *args: P.args, **kwargs: P.kwargs) -> Self:
        """Create a new encapsulated view on the given dataframe with the specified spec."""
        ...

    @property
    @abstractmethod
    def objects(self) -> Set[str]:
        """The set of object identifiers occurring in `self.df`."""
        ...

    @abstractmethod
    def feature_column_view(self, *, add_spec_id_prefix: bool = False, use_long_names: bool = False, **kwargs: P.kwargs) -> pd.DataFrame:
        """
        Generate a view on the underlying dataframe.

        :param add_spec_id_prefix: whether to prefix the column names with the spec id (useful for avoiding name collisions when joining dataframes)
        :param use_long_names: whether to rename the columns to use the "long" feature names specified in `self.timeseries_spec`
        """

    def __len__(self) -> int:
        return len(self.df)


SView = TypeVar('SView', bound=SeriesViewProtocol[SeriesSpecProtocol[ObservationSpecIdentifier, DatapointSpec]], covariant=True)
SContainer = TypeVar('SContainer', bound='SeriesContainerProtocol[SeriesSpecProtocol[ObservationSpecIdentifier, DatapointSpec], SeriesViewProtocol[SeriesSpecProtocol[SpecIdentifier, DatapointSpec]]]')


class SeriesContainerProtocol(SeriesViewProtocol[SSpec], SlimMapping[str, SView], Iterable[SView], Sized,
                              Copyable, Protocol[SSpec, SView]):
    """
    The base interface for a container object holding all datapoints of a specific spec.
    Implementations provide generators for filtered views on the datapoints.
    """

    @property
    @abstractmethod
    def series_spec(self) -> SSpec:
        """
        The series spec describing the contained datapoints' features, i.e., columns in `self.df`.

        :rtype: an implementation of `SeriesSpecProtocol`
        """
        ...

    @series_spec.setter
    @abstractmethod
    def series_spec(self, value: SSpec) -> None: ...

    @property
    @abstractmethod
    def df(self) -> pd.DataFrame:
        """
        The actual dataframe holding the data.
        Its index is managed by the holding Machine Data instance, it should not be manually modified in place.
        """
        ...

    @df.setter
    @abstractmethod
    def df(self, value: pd.DataFrame) -> None: ...

    @classmethod
    @abstractmethod
    def of(cls, series_spec: SSpec, df: pd.DataFrame, **kwargs: P.kwargs) -> Self:
        """Create a new instance of the specified spec and observations in the dataframe."""
        ...

    @property
    @abstractmethod
    def series_count(self) -> int:
        """
        The number of individually indexable series that views can be created for.
        By default, that is one per occurring object identifier.
        """
        ...

    @property
    def datapoint_count(self) -> int:
        """
        The number of datapoints in this container, i.e., equivalently the length of `self.df`.
        """
        return len(self.df)

    @abstractmethod
    def view(self, *args: P.args, **kwargs: P.kwargs) -> SView:
        """
        Generate a series view specified by `args` and `kwargs`.
        Concrete implementations can offer different slicing capabilities.

        :rtype: an implementation of `SeriesViewProtocol`
        """
        ...

    @abstractmethod
    def __getitem__(self, item: str) -> SView:
        """Directly access a view on the series indexed by `item`."""
        ...

    @abstractmethod
    def merge(self, other: Self,
              axis: Literal['horizontal', 'vertical'] = 'vertical', copy: bool = True) -> Self:
        """
        Merge the datapoints in `self` and `other`.
        A new independent instance is returned, and the underlying dataframe is copied if `copy=True`.

        - `horizontal` extends the dataframe columns by the additional features defined in `other`.
        - `vertical` appends the datapoints of `other`. The series specs must be equivalent.
        """
        ...

    @classmethod
    def lifted_merge(cls, scs: Mapping[str, SContainer], o_scs: Mapping[str, SContainer],
                     axis: Literal['horizontal', 'vertical'] = 'vertical', copy=True) -> tuple[
        dict[str, SContainer], bool]:
        """
        Apply the specified merge to corresponding series containers in `tscs` and `o_tscs`.
        Containers with keys in the symmetric difference of keys are included in the resulting dict as is.
        The returned boolean indicates whether the index of any the underlying dataframes may have changed.
        If `copy=True`, the underlying containers are copied, otherwise their internal dataframes will be linked.
        """
        assert axis in {'horizontal', 'vertical'}
        ov = intersection(scs.keys(), o_scs.keys())
        s1, s2 = symmetric_difference(scs.keys(), o_scs.keys())

        def maybe_copy(tsc: SContainer) -> SContainer:
            return copy_func(tsc) if copy else tsc

        res = ({e: maybe_copy(scs[e]) for e in s1}
               | {e: scs[e].merge(o_scs[e], axis=axis, copy=copy) for e in ov}
               | {e: maybe_copy(o_scs[e]) for e in s2})
        return res, (axis == 'vertical') | (len(s2) > 0)
