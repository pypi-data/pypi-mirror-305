# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8

import json
import sys
from io import IOBase
from typing import IO, Any, Callable, Dict, List, Optional, TypeVar, Union, overload

from corehttp.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from corehttp.rest import HttpRequest, HttpResponse
from corehttp.runtime.pipeline import PipelineResponse
from corehttp.utils import case_insensitive_dict

from .. import models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import (
        MutableMapping,  # type: ignore  # pylint: disable=ungrouped-imports
    )
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_calendars_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_calendars_resource_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_generate_holidays_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$generate-holidays"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_compute_dates_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$compute-dates"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_generate_date_schedule_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$generate-date-schedule"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendars_resource_count_periods_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/$count-periods"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_read_request(calendar_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_delete_request(calendar_id: str, **kwargs: Any) -> HttpRequest:
    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_calendar_resource_overwrite_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_update_request(calendar_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_generate_holidays_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$generate-holidays"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_compute_dates_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$compute-dates"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_generate_date_schedule_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$generate-date-schedule"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_calendar_resource_count_periods_request(  # pylint: disable=name-too-long
    calendar_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/calendars/v1/{calendarId}/$count-periods"
    path_format_arguments = {
        "calendarId": _SERIALIZER.url("calendar_id", calendar_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_cross_currencies_resource_list_request(  # pylint: disable=name-too-long
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_cross_currencies_resource_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_read_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_delete_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_cross_currency_resource_overwrite_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_cross_currency_resource_update_request(  # pylint: disable=name-too-long
    cross_currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/cross-currencies/v1/{crossCurrencyId}"
    path_format_arguments = {
        "crossCurrencyId": _SERIALIZER.url("cross_currency_id", cross_currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_currencies_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_currencies_resource_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_currency_resource_read_request(currency_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_currency_resource_delete_request(currency_id: str, **kwargs: Any) -> HttpRequest:
    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_currency_resource_overwrite_request(  # pylint: disable=name-too-long
    currency_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_currency_resource_update_request(currency_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/reference-data/currencies/v1/{currencyId}"
    path_format_arguments = {
        "currencyId": _SERIALIZER.url("currency_id", currency_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_list_request(  # pylint: disable=name-too-long
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_create_definition_from_fx_forwards_in_direct_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/$create-definition-from-fx-forwards"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_create_definition_from_deposits_in_direct_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/$create-definition-from-deposits"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curves_resource_calculate_on_the_fly_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/$calculate"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_read_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_delete_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_fx_forward_curve_resource_overwrite_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_update_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_forward_curve_resource_calculate_request(  # pylint: disable=name-too-long
    curve_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/market-data/fx-forward-curves/v1/{curveId}/$calculate"
    path_format_arguments = {
        "curveId": _SERIALIZER.url("curve_id", curve_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forwards_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fx_forwards_resource_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forwards_resource_price_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/$price"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forwards_resource_value_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/$value"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_read_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_delete_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_fx_forward_resource_overwrite_request(  # pylint: disable=name-too-long
    instrument_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_update_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_price_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}/$price"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_forward_resource_value_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-forwards/v1/{instrumentId}/$value"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spots_resource_list_request(
    *,
    item_per_page: Optional[int] = None,
    names: Optional[List[str]] = None,
    spaces: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1"

    # Construct parameters
    if item_per_page is not None:
        _params["itemPerPage"] = _SERIALIZER.query("item_per_page", item_per_page, "int")
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if spaces is not None:
        _params["spaces"] = [_SERIALIZER.query("spaces", q, "str") if q is not None else "" for q in spaces]
    if tags is not None:
        _params["tags"] = [_SERIALIZER.query("tags", q, "str") if q is not None else "" for q in tags]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fx_spots_resource_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spots_resource_price_on_the_fly_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/$price"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spots_resource_value_on_the_fly_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/$value"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_read_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_delete_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_fx_spot_resource_overwrite_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_update_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_price_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}/$price"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_fx_spot_resource_value_request(instrument_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/financials/instruments/fx-spots/v1/{instrumentId}/$value"
    path_format_arguments = {
        "instrumentId": _SERIALIZER.url("instrument_id", instrument_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


class calendarsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`calendars_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.CalendarCollectionResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List resource.

        :keyword item_per_page: Default value is None.
        :paramtype item_per_page: int
        :keyword names: Default value is None.
        :paramtype names: list[str]
        :keyword spaces: Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarCollectionResponse or ServiceErrorResponse. The CalendarCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "description": {
                                "summary": "str",  # Optional. A summary of
                                  information about the resource. Limited to 500 characters.
                                "tags": [
                                    "str"  # Optional. User-defined tags to
                                      identify the resource. Limited to 5 items and 50 characters each.
                                ]
                            },
                            "id": "str",  # Optional. Unique resource ID specified by
                              LSEG.
                            "type": "str"  # Optional. The resource type. Possible values
                              are: Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve,
                              Analytics, Loan, FxSpot, NonDeliverableForward, Deposit,
                              CrossCurrencySwap or Space.
                        }
                    ],
                    "links": {
                        "computeDates": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "generateDateSchedule": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "generateHolidays": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CalendarCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_calendars_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.CalendarResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: ~analyticsapi.models.CalendarResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",  # Optional. The first day of the week set
                          for the calendar. Known values are: "Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday", "Saturday", and "Sunday".
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"  # Days of the week that are set as
                                      rest days. Required.
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create(
        self, body: Union[_models.CalendarResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Is one of the following types: CalendarResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CalendarResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",  # Optional. The first day of the week set
                          for the calendar. Known values are: "Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday", "Saturday", and "Sunday".
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"  # Days of the week that are set as
                                      rest days. Required.
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_holidays(
        self, body: _models.GenerateHolidaysRequestCollection, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param body: Required.
        :type body: ~analyticsapi.models.GenerateHolidaysRequestCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_holidays(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_holidays(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def generate_holidays(
        self, body: Union[_models.GenerateHolidaysRequestCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param body: Is one of the following types: GenerateHolidaysRequestCollection, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.GenerateHolidaysRequestCollection or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_generate_holidays_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateHolidaysResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def compute_dates(
        self, body: _models.ComputeDatesRequestCollection, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute date.

        :param body: Required.
        :type body: ~analyticsapi.models.ComputeDatesRequestCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "tenors": [
                        "str"  # Tenors to be added to startDate to calculate the resulted
                          dates (e.g., 1M, 1Y). Required.
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. Known values are: "ModifiedFollowing", "NextBusinessDay",
                      "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def compute_dates(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute date.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def compute_dates(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute date.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def compute_dates(
        self, body: Union[_models.ComputeDatesRequestCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute date.

        :param body: Is one of the following types: ComputeDatesRequestCollection, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.ComputeDatesRequestCollection or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "tenors": [
                        "str"  # Tenors to be added to startDate to calculate the resulted
                          dates (e.g., 1M, 1Y). Required.
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. Known values are: "ModifiedFollowing", "NextBusinessDay",
                      "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_compute_dates_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ComputeDatesResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_date_schedule(
        self,
        body: _models.GenerateDateScheduleRequestCollection,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Generate date schedule.

        :param body: Required.
        :type body: ~analyticsapi.models.GenerateDateScheduleRequestCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "frequency": "str",  # The frequency of dates in the schedule which should be
                      generated. Required. Known values are: "Daily", "Weekly", "BiWeekly", and
                      "Monthly".
                    "calendarDayOfMonth": 0,  # Optional. The number of the day of the month.
                      Required if frequency is Monthly; do not use otherwise. The minimum value is 1.
                      The maximum value is 31.
                    "count": 0,  # Optional. The number is used to define a list of dates
                      counting from the start date (or today's date if the start day is not set) to the
                      end date.  It should not have a negative value. Required if endDate is not
                      specified. Only one of endDate and count can be set at a time.
                    "dayOfWeek": "str",  # Optional. The day of the week. Required if frequency
                      is Daily; do not use otherwise. Known values are: "Monday", "Tuesday",
                      "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).  If
                      startDate is not specified, endDate is used to define the list of dates from
                      today's date to the end date. The end date must be greater or equal to the start
                      date. Required if count is not specified. Only one of endDate and count can be
                      set at a time.
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).  The start
                      date must be less or equal to the end date. Required if endDate is in the past.
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generate date schedule.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generate date schedule.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def generate_date_schedule(
        self, body: Union[_models.GenerateDateScheduleRequestCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Generate date schedule.

        :param body: Is one of the following types: GenerateDateScheduleRequestCollection, JSON,
         IO[bytes] Required.
        :type body: ~analyticsapi.models.GenerateDateScheduleRequestCollection or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "frequency": "str",  # The frequency of dates in the schedule which should be
                      generated. Required. Known values are: "Daily", "Weekly", "BiWeekly", and
                      "Monthly".
                    "calendarDayOfMonth": 0,  # Optional. The number of the day of the month.
                      Required if frequency is Monthly; do not use otherwise. The minimum value is 1.
                      The maximum value is 31.
                    "count": 0,  # Optional. The number is used to define a list of dates
                      counting from the start date (or today's date if the start day is not set) to the
                      end date.  It should not have a negative value. Required if endDate is not
                      specified. Only one of endDate and count can be set at a time.
                    "dayOfWeek": "str",  # Optional. The day of the week. Required if frequency
                      is Daily; do not use otherwise. Known values are: "Monday", "Tuesday",
                      "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).  If
                      startDate is not specified, endDate is used to define the list of dates from
                      today's date to the end date. The end date must be greater or equal to the start
                      date. Required if count is not specified. Only one of endDate and count can be
                      set at a time.
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).  The start
                      date must be less or equal to the end date. Required if endDate is in the past.
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_generate_date_schedule_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateDateScheduleResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def count_periods(
        self, body: _models.CountPeriodsRequestCollection, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param body: Required.
        :type body: ~analyticsapi.models.CountPeriodsRequestCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",  # end date for counting periods. Required.
                    "startDate": "2020-02-20",  # start date for counting periods. Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dayCountBasis": "str",  # Optional. The day count basis convention used to
                      calculate the period between two dates.  It is used when periodType is set to
                      Year. Each convention defines the number of days between two dates and the year
                      length in days (basis) for the period calculation. Known values are:
                      "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
                      "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
                      "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
                      "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
                      "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
                      "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
                      "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
                      "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
                    "periodType": "str"  # Optional. The method of the period calculation. Known
                      values are: "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and
                      "Year".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def count_periods(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def count_periods(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def count_periods(
        self, body: Union[_models.CountPeriodsRequestCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param body: Is one of the following types: CountPeriodsRequestCollection, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.CountPeriodsRequestCollection or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",  # end date for counting periods. Required.
                    "startDate": "2020-02-20",  # start date for counting periods. Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dayCountBasis": "str",  # Optional. The day count basis convention used to
                      calculate the period between two dates.  It is used when periodType is set to
                      Year. Each convention defines the number of days between two dates and the year
                      length in days (basis) for the period calculation. Known values are:
                      "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
                      "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
                      "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
                      "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
                      "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
                      "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
                      "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
                      "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
                    "periodType": "str"  # Optional. The method of the period calculation. Known
                      values are: "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and
                      "Year".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_count_periods_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CountPeriodsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class calendarResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`calendar_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, calendar_id: str, **kwargs: Any) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Read resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_calendar_resource_read_request(
            calendar_id=calendar_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, calendar_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_calendar_resource_delete_request(
            calendar_id=calendar_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, calendar_id: str, body: _models.CalendarResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CalendarResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",  # Optional. The first day of the week set
                          for the calendar. Known values are: "Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday", "Saturday", and "Sunday".
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"  # Days of the week that are set as
                                      rest days. Required.
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def overwrite(
        self, calendar_id: str, body: Union[_models.CalendarResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is one of the following types: CalendarResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CalendarResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",  # Optional. The first day of the week set
                          for the calendar. Known values are: "Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday", "Saturday", and "Sunday".
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"  # Days of the week that are set as
                                      rest days. Required.
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_overwrite_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, calendar_id: str, body: _models.CalendarResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CalendarResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",  # Optional. The first day of the week set
                          for the calendar. Known values are: "Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday", "Saturday", and "Sunday".
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"  # Days of the week that are set as
                                      rest days. Required.
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def update(
        self, calendar_id: str, body: Union[_models.CalendarResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CalendarResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is one of the following types: CalendarResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CalendarResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CalendarResponse or ServiceErrorResponse. The CalendarResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "firstDayOfWeek": "str",  # Optional. The first day of the week set
                          for the calendar. Known values are: "Monday", "Tuesday", "Wednesday",
                          "Thursday", "Friday", "Saturday", and "Sunday".
                        "holidayExceptionRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "holidayRules": [
                            {
                                "duration": duration,
                                "name": "str",  # The name of the holiday rule.
                                  Required.
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                },
                                "when": when,
                                "description": "str"  # Optional. The description of
                                  the holiday rule.
                            }
                        ],
                        "restDays": [
                            {
                                "restDays": [
                                    "str"  # Days of the week that are set as
                                      rest days. Required.
                                ],
                                "validityPeriod": {
                                    "endDate": "2020-02-20",  # Optional. The end
                                      date of the validity period. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., 2024-01-01).
                                    "startDate": "2020-02-20"  # Optional. The
                                      start date of the validity period. The value is expressed in ISO
                                      8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                }
                            }
                        ]
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "firstDayOfWeek": "str",  # Optional. The first day of the
                              week set for the calendar. Known values are: "Monday", "Tuesday",
                              "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                            "holidayExceptionRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "holidayRules": [
                                {
                                    "duration": duration,
                                    "name": "str",  # The name of the holiday
                                      rule. Required.
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    },
                                    "when": when,
                                    "description": "str"  # Optional. The
                                      description of the holiday rule.
                                }
                            ],
                            "restDays": [
                                {
                                    "restDays": [
                                        "str"  # Days of the week that are
                                          set as rest days. Required.
                                    ],
                                    "validityPeriod": {
                                        "endDate": "2020-02-20",  # Optional.
                                          The end date of the validity period. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                                        "startDate": "2020-02-20"  #
                                          Optional. The start date of the validity period. The value is
                                          expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                                    }
                                }
                            ]
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CalendarResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_update_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CalendarResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_holidays(
        self,
        calendar_id: str,
        body: _models.GenerateHolidaysRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.GenerateHolidaysRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_holidays(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_holidays(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def generate_holidays(
        self, calendar_id: str, body: Union[_models.GenerateHolidaysRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List holidays.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is one of the following types: GenerateHolidaysRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.GenerateHolidaysRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateHolidaysResponse or ServiceErrorResponse. The GenerateHolidaysResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "date": "2020-02-20",  # The date on which the holiday falls.
                              The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).
                              Required.
                            "names": [
                                {
                                    "calendars": [
                                        {
                                            "id": "str",  # Optional. The
                                              unique id of the resource.
                                            "location": {
                                                "name": "str",  # The
                                                  name of the resource. Required.
                                                "space": "str"  #
                                                  Optional. The storage location for the resource.
                                            },
                                            "type": "str"  # Optional.
                                              The type of the resource.
                                        }
                                    ],
                                    "countries": [
                                        "str"  # Optional. An array of
                                          country codes that the holiday belongs to. For example, FRA
                                          for France, UKG for The United Kingdom.
                                    ],
                                    "name": "str"  # Optional. The name of the
                                      holiday.
                                }
                            ],
                            "processingInformation": "str"  # Optional. The error message
                              for the calculation in case of a non-blocking error.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateHolidaysResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_generate_holidays_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateHolidaysResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def compute_dates(
        self,
        calendar_id: str,
        body: _models.ComputeDatesRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute dates.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.ComputeDatesRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tenors": [
                        "str"  # Tenors to be added to startDate to calculate the resulted
                          dates (e.g., 1M, 1Y). Required.
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. Known values are: "ModifiedFollowing", "NextBusinessDay",
                      "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def compute_dates(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute dates.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def compute_dates(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute dates.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def compute_dates(
        self, calendar_id: str, body: Union[_models.ComputeDatesRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Compute dates.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is one of the following types: ComputeDatesRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ComputeDatesRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ComputeDatesResponse or ServiceErrorResponse. The ComputeDatesResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "tenors": [
                        "str"  # Tenors to be added to startDate to calculate the resulted
                          dates (e.g., 1M, 1Y). Required.
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. Known values are: "ModifiedFollowing", "NextBusinessDay",
                      "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "endDate": "2020-02-20",  # Optional. The date produced by
                              the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
                              (e.g., 2024-01-01).
                            "processingInformation": "str",  # Optional. The error
                              message for the calculation in case of a non-blocking error.
                            "tenor": "str"  # Optional. The code indicating the tenor
                              added to startDate to calculate the resulted date (e.g., 1Y).
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.ComputeDatesResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_compute_dates_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ComputeDatesResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def generate_date_schedule(
        self,
        calendar_id: str,
        body: _models.GenerateDateScheduleRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Generate date schedule.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.GenerateDateScheduleRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "frequency": "str",  # The frequency of dates in the schedule which should be
                      generated. Required. Known values are: "Daily", "Weekly", "BiWeekly", and
                      "Monthly".
                    "calendarDayOfMonth": 0,  # Optional. The number of the day of the month.
                      Required if frequency is Monthly; do not use otherwise. The minimum value is 1.
                      The maximum value is 31.
                    "count": 0,  # Optional. The number is used to define a list of dates
                      counting from the start date (or today's date if the start day is not set) to the
                      end date.  It should not have a negative value. Required if endDate is not
                      specified. Only one of endDate and count can be set at a time.
                    "dayOfWeek": "str",  # Optional. The day of the week. Required if frequency
                      is Daily; do not use otherwise. Known values are: "Monday", "Tuesday",
                      "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).  If
                      startDate is not specified, endDate is used to define the list of dates from
                      today's date to the end date. The end date must be greater or equal to the start
                      date. Required if count is not specified. Only one of endDate and count can be
                      set at a time.
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).  The start
                      date must be less or equal to the end date. Required if endDate is in the past.
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generate date schedule.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def generate_date_schedule(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        """Generate date schedule.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def generate_date_schedule(
        self, calendar_id: str, body: Union[_models.GenerateDateScheduleRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Generate date schedule.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is one of the following types: GenerateDateScheduleRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.GenerateDateScheduleRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: GenerateDateScheduleResponse or ServiceErrorResponse. The GenerateDateScheduleResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "frequency": "str",  # The frequency of dates in the schedule which should be
                      generated. Required. Known values are: "Daily", "Weekly", "BiWeekly", and
                      "Monthly".
                    "calendarDayOfMonth": 0,  # Optional. The number of the day of the month.
                      Required if frequency is Monthly; do not use otherwise. The minimum value is 1.
                      The maximum value is 31.
                    "count": 0,  # Optional. The number is used to define a list of dates
                      counting from the start date (or today's date if the start day is not set) to the
                      end date.  It should not have a negative value. Required if endDate is not
                      specified. Only one of endDate and count can be set at a time.
                    "dayOfWeek": "str",  # Optional. The day of the week. Required if frequency
                      is Daily; do not use otherwise. Known values are: "Monday", "Tuesday",
                      "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
                    "endDate": "2020-02-20",  # Optional. The end date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).  If
                      startDate is not specified, endDate is used to define the list of dates from
                      today's date to the end date. The end date must be greater or equal to the start
                      date. Required if count is not specified. Only one of endDate and count can be
                      set at a time.
                    "startDate": "2020-02-20"  # Optional. The start date of the calculation. The
                      value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).  The start
                      date must be less or equal to the end date. Required if endDate is in the past.
                }

                # response body for status code(s): 200
                response == {
                    "data": [
                        "2020-02-20"  # Required.
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.GenerateDateScheduleResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_generate_date_schedule_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.GenerateDateScheduleResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def count_periods(
        self,
        calendar_id: str,
        body: _models.CountPeriodsRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CountPeriodsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",  # end date for counting periods. Required.
                    "startDate": "2020-02-20",  # start date for counting periods. Required.
                    "dayCountBasis": "str",  # Optional. The day count basis convention used to
                      calculate the period between two dates.  It is used when periodType is set to
                      Year. Each convention defines the number of days between two dates and the year
                      length in days (basis) for the period calculation. Known values are:
                      "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
                      "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
                      "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
                      "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
                      "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
                      "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
                      "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
                      "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
                    "periodType": "str"  # Optional. The method of the period calculation. Known
                      values are: "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and
                      "Year".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def count_periods(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def count_periods(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def count_periods(
        self, calendar_id: str, body: Union[_models.CountPeriodsRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Count periods.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is one of the following types: CountPeriodsRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CountPeriodsRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CountPeriodsResponse or ServiceErrorResponse. The CountPeriodsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "endDate": "2020-02-20",  # end date for counting periods. Required.
                    "startDate": "2020-02-20",  # start date for counting periods. Required.
                    "dayCountBasis": "str",  # Optional. The day count basis convention used to
                      calculate the period between two dates.  It is used when periodType is set to
                      Year. Each convention defines the number of days between two dates and the year
                      length in days (basis) for the period calculation. Known values are:
                      "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
                      "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
                      "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
                      "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
                      "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
                      "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
                      "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
                      "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
                    "periodType": "str"  # Optional. The method of the period calculation. Known
                      values are: "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and
                      "Year".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "count": 0,  # The calculated number of dates in the period from
                          startDate to endDate. Required.
                        "periodType": "str",  # The type of the calculated period. Required.
                          Known values are: "Day", "WorkingDay", "Week", "Month", "Quarter", and
                          "Year".
                        "processingInformation": "str"  # Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CountPeriodsResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_count_periods_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CountPeriodsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class crossCurrenciesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`cross_currencies_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyCollectionResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List resource.

        :keyword item_per_page: Default value is None.
        :paramtype item_per_page: int
        :keyword names: Default value is None.
        :paramtype names: list[str]
        :keyword spaces: Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyCollectionResponse or ServiceErrorResponse. The
         CrossCurrencyCollectionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "description": {
                                "summary": "str",  # Optional. A summary of
                                  information about the resource. Limited to 500 characters.
                                "tags": [
                                    "str"  # Optional. User-defined tags to
                                      identify the resource. Limited to 5 items and 50 characters each.
                                ]
                            },
                            "id": "str",  # Optional. Unique resource ID specified by
                              LSEG.
                            "type": "str"  # Optional. The resource type. Possible values
                              are: Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve,
                              Analytics, Loan, FxSpot, NonDeliverableForward, Deposit,
                              CrossCurrencySwap or Space.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CrossCurrencyCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_cross_currencies_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.CrossCurrencyResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: ~analyticsapi.models.CrossCurrencyResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,  # Optional. The number of decimal places
                          used for cross rates.  Minumum is 0, maximum is 9.
                        "crossScalingFactor": 0.0,  # Optional. The factor used for quoting
                          cross currency rates. Minumum is 0.000001, maximum is 1000000, default is 1.
                        "spotLag": 0,  # Optional. The number of business days to settlement.
                          If not provided, a default spot lag for the given code will be used,
                          typically 2 business days.
                        "swapPointPrecision": 0,  # Optional. The number of decimal places
                          used for swap points.  Minumum is 0, maximum is 9.
                        "swapPointScalingFactor": 0.0  # Optional. The factor used when
                          quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100). Minumum is
                          0.000001, maximum is 1000000, default is 10000.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create(
        self, body: Union[_models.CrossCurrencyResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Is one of the following types: CrossCurrencyResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CrossCurrencyResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,  # Optional. The number of decimal places
                          used for cross rates.  Minumum is 0, maximum is 9.
                        "crossScalingFactor": 0.0,  # Optional. The factor used for quoting
                          cross currency rates. Minumum is 0.000001, maximum is 1000000, default is 1.
                        "spotLag": 0,  # Optional. The number of business days to settlement.
                          If not provided, a default spot lag for the given code will be used,
                          typically 2 business days.
                        "swapPointPrecision": 0,  # Optional. The number of decimal places
                          used for swap points.  Minumum is 0, maximum is 9.
                        "swapPointScalingFactor": 0.0  # Optional. The factor used when
                          quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100). Minumum is
                          0.000001, maximum is 1000000, default is 10000.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cross_currencies_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class crossCurrencyResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`cross_currency_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(
        self, cross_currency_id: str, **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Read resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_cross_currency_resource_read_request(
            cross_currency_id=cross_currency_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, cross_currency_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_cross_currency_resource_delete_request(
            cross_currency_id=cross_currency_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self,
        cross_currency_id: str,
        body: _models.CrossCurrencyResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CrossCurrencyResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,  # Optional. The number of decimal places
                          used for cross rates.  Minumum is 0, maximum is 9.
                        "crossScalingFactor": 0.0,  # Optional. The factor used for quoting
                          cross currency rates. Minumum is 0.000001, maximum is 1000000, default is 1.
                        "spotLag": 0,  # Optional. The number of business days to settlement.
                          If not provided, a default spot lag for the given code will be used,
                          typically 2 business days.
                        "swapPointPrecision": 0,  # Optional. The number of decimal places
                          used for swap points.  Minumum is 0, maximum is 9.
                        "swapPointScalingFactor": 0.0  # Optional. The factor used when
                          quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100). Minumum is
                          0.000001, maximum is 1000000, default is 10000.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, cross_currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, cross_currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def overwrite(
        self, cross_currency_id: str, body: Union[_models.CrossCurrencyResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Is one of the following types: CrossCurrencyResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CrossCurrencyResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,  # Optional. The number of decimal places
                          used for cross rates.  Minumum is 0, maximum is 9.
                        "crossScalingFactor": 0.0,  # Optional. The factor used for quoting
                          cross currency rates. Minumum is 0.000001, maximum is 1000000, default is 1.
                        "spotLag": 0,  # Optional. The number of business days to settlement.
                          If not provided, a default spot lag for the given code will be used,
                          typically 2 business days.
                        "swapPointPrecision": 0,  # Optional. The number of decimal places
                          used for swap points.  Minumum is 0, maximum is 9.
                        "swapPointScalingFactor": 0.0  # Optional. The factor used when
                          quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100). Minumum is
                          0.000001, maximum is 1000000, default is 10000.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cross_currency_resource_overwrite_request(
            cross_currency_id=cross_currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        cross_currency_id: str,
        body: _models.CrossCurrencyResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CrossCurrencyResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,  # Optional. The number of decimal places
                          used for cross rates.  Minumum is 0, maximum is 9.
                        "crossScalingFactor": 0.0,  # Optional. The factor used for quoting
                          cross currency rates. Minumum is 0.000001, maximum is 1000000, default is 1.
                        "spotLag": 0,  # Optional. The number of business days to settlement.
                          If not provided, a default spot lag for the given code will be used,
                          typically 2 business days.
                        "swapPointPrecision": 0,  # Optional. The number of decimal places
                          used for swap points.  Minumum is 0, maximum is 9.
                        "swapPointScalingFactor": 0.0  # Optional. The factor used when
                          quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100). Minumum is
                          0.000001, maximum is 1000000, default is 10000.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, cross_currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, cross_currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def update(
        self, cross_currency_id: str, body: Union[_models.CrossCurrencyResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param cross_currency_id: Required.
        :type cross_currency_id: str
        :param body: Is one of the following types: CrossCurrencyResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CrossCurrencyResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CrossCurrencyResponse or ServiceErrorResponse. The CrossCurrencyResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.CrossCurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossRatePrecision": 0,  # Optional. The number of decimal places
                          used for cross rates.  Minumum is 0, maximum is 9.
                        "crossScalingFactor": 0.0,  # Optional. The factor used for quoting
                          cross currency rates. Minumum is 0.000001, maximum is 1000000, default is 1.
                        "spotLag": 0,  # Optional. The number of business days to settlement.
                          If not provided, a default spot lag for the given code will be used,
                          typically 2 business days.
                        "swapPointPrecision": 0,  # Optional. The number of decimal places
                          used for swap points.  Minumum is 0, maximum is 9.
                        "swapPointScalingFactor": 0.0  # Optional. The factor used when
                          quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100). Minumum is
                          0.000001, maximum is 1000000, default is 10000.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossRatePrecision": 0,  # Optional. The number of decimal
                              places used for cross rates.  Minumum is 0, maximum is 9.
                            "crossScalingFactor": 0.0,  # Optional. The factor used for
                              quoting cross currency rates. Minumum is 0.000001, maximum is 1000000,
                              default is 1.
                            "spotLag": 0,  # Optional. The number of business days to
                              settlement. If not provided, a default spot lag for the given code will
                              be used, typically 2 business days.
                            "swapPointPrecision": 0,  # Optional. The number of decimal
                              places used for swap points.  Minumum is 0, maximum is 9.
                            "swapPointScalingFactor": 0.0  # Optional. The factor used
                              when quoting Swap cross currency rates (e.g., for 'JPYUSD' it is 100).
                              Minumum is 0.000001, maximum is 1000000, default is 10000.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CrossCurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cross_currency_resource_update_request(
            cross_currency_id=cross_currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CrossCurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class currenciesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`currencies_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.CurrencyCollectionResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List resource.

        :keyword item_per_page: Default value is None.
        :paramtype item_per_page: int
        :keyword names: Default value is None.
        :paramtype names: list[str]
        :keyword spaces: Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyCollectionResponse or ServiceErrorResponse. The CurrencyCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CurrencyCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "description": {
                                "summary": "str",  # Optional. A summary of
                                  information about the resource. Limited to 500 characters.
                                "tags": [
                                    "str"  # Optional. User-defined tags to
                                      identify the resource. Limited to 5 items and 50 characters each.
                                ]
                            },
                            "id": "str",  # Optional. Unique resource ID specified by
                              LSEG.
                            "type": "str"  # Optional. The resource type. Possible values
                              are: Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve,
                              Analytics, Loan, FxSpot, NonDeliverableForward, Deposit,
                              CrossCurrencySwap or Space.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CurrencyCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_currencies_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.CurrencyResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: ~analyticsapi.models.CurrencyResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        },
                        "spotLag": 0,  # The number of business days to settlement. The
                          minimum is 0. If not provided, a default spot lag for the given code will be
                          used, typically 2 business days. Required.
                        "yearBasis": "str"  # The number of days in a year. Required. Known
                          values are: "360" and "365".
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create(
        self, body: Union[_models.CurrencyResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Is one of the following types: CurrencyResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CurrencyResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        },
                        "spotLag": 0,  # The number of business days to settlement. The
                          minimum is 0. If not provided, a default spot lag for the given code will be
                          used, typically 2 business days. Required.
                        "yearBasis": "str"  # The number of days in a year. Required. Known
                          values are: "360" and "365".
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_currencies_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class currencyResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`currency_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, currency_id: str, **kwargs: Any) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Read resource.

        :param currency_id: Required.
        :type currency_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_currency_resource_read_request(
            currency_id=currency_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, currency_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param currency_id: Required.
        :type currency_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_currency_resource_delete_request(
            currency_id=currency_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, currency_id: str, body: _models.CurrencyResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CurrencyResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        },
                        "spotLag": 0,  # The number of business days to settlement. The
                          minimum is 0. If not provided, a default spot lag for the given code will be
                          used, typically 2 business days. Required.
                        "yearBasis": "str"  # The number of days in a year. Required. Known
                          values are: "360" and "365".
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def overwrite(
        self, currency_id: str, body: Union[_models.CurrencyResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Is one of the following types: CurrencyResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CurrencyResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        },
                        "spotLag": 0,  # The number of business days to settlement. The
                          minimum is 0. If not provided, a default spot lag for the given code will be
                          used, typically 2 business days. Required.
                        "yearBasis": "str"  # The number of days in a year. Required. Known
                          values are: "360" and "365".
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_currency_resource_overwrite_request(
            currency_id=currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, currency_id: str, body: _models.CurrencyResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CurrencyResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        },
                        "spotLag": 0,  # The number of business days to settlement. The
                          minimum is 0. If not provided, a default spot lag for the given code will be
                          used, typically 2 business days. Required.
                        "yearBasis": "str"  # The number of days in a year. Required. Known
                          values are: "360" and "365".
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, currency_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, currency_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def update(
        self, currency_id: str, body: Union[_models.CurrencyResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.CurrencyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param currency_id: Required.
        :type currency_id: str
        :param body: Is one of the following types: CurrencyResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CurrencyResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: CurrencyResponse or ServiceErrorResponse. The CurrencyResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CurrencyResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "calendar": {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        },
                        "spotLag": 0,  # The number of business days to settlement. The
                          minimum is 0. If not provided, a default spot lag for the given code will be
                          used, typically 2 business days. Required.
                        "yearBasis": "str"  # The number of days in a year. Required. Known
                          values are: "360" and "365".
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "calendar": {
                                "id": "str",  # Optional. The unique id of the
                                  resource.
                                "location": {
                                    "name": "str",  # The name of the resource.
                                      Required.
                                    "space": "str"  # Optional. The storage
                                      location for the resource.
                                },
                                "type": "str"  # Optional. The type of the resource.
                            },
                            "spotLag": 0,  # The number of business days to settlement.
                              The minimum is 0. If not provided, a default spot lag for the given code
                              will be used, typically 2 business days. Required.
                            "yearBasis": "str"  # The number of days in a year. Required.
                              Known values are: "360" and "365".
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.CurrencyResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_currency_resource_update_request(
            currency_id=currency_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.CurrencyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class fxForwardCurvesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forward_curves_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCollectionResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List resource.

        :keyword item_per_page: Default value is None.
        :paramtype item_per_page: int
        :keyword names: Default value is None.
        :paramtype names: list[str]
        :keyword spaces: Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCollectionResponse or ServiceErrorResponse. The
         FxForwardCurveCollectionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "description": {
                                "summary": "str",  # Optional. A summary of
                                  information about the resource. Limited to 500 characters.
                                "tags": [
                                    "str"  # Optional. User-defined tags to
                                      identify the resource. Limited to 5 items and 50 characters each.
                                ]
                            },
                            "id": "str",  # Optional. Unique resource ID specified by
                              LSEG.
                            "type": "str"  # Optional. The resource type. Possible values
                              are: Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve,
                              Analytics, Loan, FxSpot, NonDeliverableForward, Deposit,
                              CrossCurrencySwap or Space.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardCurveCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_fx_forward_curves_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.FxForwardCurveResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardCurveResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create(
        self, body: Union[_models.FxForwardCurveResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Is one of the following types: FxForwardCurveResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardCurveResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self, body: _models.BuildInDirectFromFxForwardsRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Required.
        :type body: ~analyticsapi.models.BuildInDirectFromFxForwardsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"  # The currency pair of FX Cross, expressed in ISO 4217
                          alphabetical format (e.g., 'EURCHF'). Required.
                    },
                    "additionalTenorTypes": [
                        "str"  # Optional. An array of tenor types that can be used for
                          instruments in addition to the standard tenor.
                    ],
                    "referenceCurrency": {
                        "code": "str"  # The currency expressed in ISO 4217 alphabetical
                          format (e.g., 'EUR'). Required.
                    },
                    "sources": {
                        "baseFxForwards": "str",  # Optional. The source of FX forwards for
                          the base currency in the cross-currency pair.
                        "baseFxSpot": "str",  # Optional. The source of FX spot for the base
                          currency in the cross-currency pair.
                        "quotedFxForwards": "str",  # Optional. The source of FX forwards for
                          the quoted currency in the cross-currency pair.
                        "quotedFxSpot": "str"  # Optional. The source of FX spot for the
                          quoted currency in the cross-currency pair.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create_definition_from_fx_forwards_in_direct(  # pylint: disable=name-too-long
        self, body: Union[_models.BuildInDirectFromFxForwardsRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Fx Forward constituents - via reference currency.

        :param body: Is one of the following types: BuildInDirectFromFxForwardsRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.BuildInDirectFromFxForwardsRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"  # The currency pair of FX Cross, expressed in ISO 4217
                          alphabetical format (e.g., 'EURCHF'). Required.
                    },
                    "additionalTenorTypes": [
                        "str"  # Optional. An array of tenor types that can be used for
                          instruments in addition to the standard tenor.
                    ],
                    "referenceCurrency": {
                        "code": "str"  # The currency expressed in ISO 4217 alphabetical
                          format (e.g., 'EUR'). Required.
                    },
                    "sources": {
                        "baseFxForwards": "str",  # Optional. The source of FX forwards for
                          the base currency in the cross-currency pair.
                        "baseFxSpot": "str",  # Optional. The source of FX spot for the base
                          currency in the cross-currency pair.
                        "quotedFxForwards": "str",  # Optional. The source of FX forwards for
                          the quoted currency in the cross-currency pair.
                        "quotedFxSpot": "str"  # Optional. The source of FX spot for the
                          quoted currency in the cross-currency pair.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_definition_from_fx_forwards_in_direct_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.BuildDirectFromDepositsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self, body: _models.BuildInDirectFromDepositsRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Required.
        :type body: ~analyticsapi.models.BuildInDirectFromDepositsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"  # The currency pair of FX Cross, expressed in ISO 4217
                          alphabetical format (e.g., 'EURCHF'). Required.
                    },
                    "additionalTenorTypes": [
                        "str"  # Optional. An array of tenor types that can be used for
                          instruments in addition to the standard tenor.
                    ],
                    "referenceCurrency": {
                        "code": "str"  # The currency expressed in ISO 4217 alphabetical
                          format (e.g., 'EUR'). Required.
                    },
                    "sources": {
                        "baseDeposit": "str",  # Optional. The source of deposits for the
                          base currency in the cross-currency pair of the curve.
                        "baseFxSpot": "str",  # Optional. The source of FX spot for the base
                          currency in the cross-currency pair of the curve against the reference
                          currency.
                        "quotedDeposit": "str",  # Optional. The source of deposits for the
                          quoted currency in the cross-currency pair of the curve.
                        "quotedFxSpot": "str"  # Optional. The source of FX spot for the
                          quoted currency in the cross-currency pair of the curve against the reference
                          currency.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create_definition_from_deposits_in_direct(  # pylint: disable=name-too-long
        self, body: Union[_models.BuildInDirectFromDepositsRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create fx forward curve using Deposit constituents - via reference currency.

        :param body: Is one of the following types: BuildInDirectFromDepositsRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.BuildInDirectFromDepositsRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BuildDirectFromDepositsResponse or ServiceErrorResponse. The
         BuildDirectFromDepositsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildDirectFromDepositsResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "crossCurrency": {
                        "code": "str"  # The currency pair of FX Cross, expressed in ISO 4217
                          alphabetical format (e.g., 'EURCHF'). Required.
                    },
                    "additionalTenorTypes": [
                        "str"  # Optional. An array of tenor types that can be used for
                          instruments in addition to the standard tenor.
                    ],
                    "referenceCurrency": {
                        "code": "str"  # The currency expressed in ISO 4217 alphabetical
                          format (e.g., 'EUR'). Required.
                    },
                    "sources": {
                        "baseDeposit": "str",  # Optional. The source of deposits for the
                          base currency in the cross-currency pair of the curve.
                        "baseFxSpot": "str",  # Optional. The source of FX spot for the base
                          currency in the cross-currency pair of the curve against the reference
                          currency.
                        "quotedDeposit": "str",  # Optional. The source of deposits for the
                          quoted currency in the cross-currency pair of the curve.
                        "quotedFxSpot": "str"  # Optional. The source of FX spot for the
                          quoted currency in the cross-currency pair of the curve against the reference
                          currency.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "type": "str"  # Optional. Required.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.BuildDirectFromDepositsResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_definition_from_deposits_in_direct_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.BuildDirectFromDepositsResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def calculate_on_the_fly(
        self,
        body: _models.FxForwardCurveCalculateOnTheFlyRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,  # Optional.
                              An object to define calculation preferences for the curve.
                            "adjustAllSwapPointsToCrossCalendars": bool,  # Optional. An
                              object to define calculation preferences for the curve.
                            "extrapolationMode": "str",  # Optional. The extrapolation
                              method used in the curve bootstrapping. The default is None. Known values
                              are: "None", "Constant", and "Linear".
                            "ignoreInvalidInstruments": bool,  # Optional. Set to true to
                              ignore invalid instruments in the curve construction. The default is
                              false.
                            "ignorePivotCurrencyHolidays": bool,  # Optional. Set to true
                              to include holidays of the pivot currency in the pricing when dates are
                              calculated. The default is false.
                            "interpolationMode": "str",  # Optional. The interpolation
                              method used in the curve bootstrapping. The default is Linear. Known
                              values are: "CubicSpline", "Constant", "Linear", and "CubicDiscount".
                            "useDelayedDataIfDenied": bool  # Optional. Set to true to
                              use the delayed data defined in the request. The default is false.
                        },
                        "valuationDate": "2020-02-20"  # Optional. The date on which the
                          curve is constructed. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2023-01-01'). The valuation date should not be in the future.
                    },
                    "type": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def calculate_on_the_fly(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def calculate_on_the_fly(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def calculate_on_the_fly(
        self, body: Union[_models.FxForwardCurveCalculateOnTheFlyRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve constituents - on the fly.

        :param body: Is one of the following types: FxForwardCurveCalculateOnTheFlyRequest, JSON,
         IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateOnTheFlyResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateOnTheFlyResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateOnTheFlyResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,  # Optional.
                              An object to define calculation preferences for the curve.
                            "adjustAllSwapPointsToCrossCalendars": bool,  # Optional. An
                              object to define calculation preferences for the curve.
                            "extrapolationMode": "str",  # Optional. The extrapolation
                              method used in the curve bootstrapping. The default is None. Known values
                              are: "None", "Constant", and "Linear".
                            "ignoreInvalidInstruments": bool,  # Optional. Set to true to
                              ignore invalid instruments in the curve construction. The default is
                              false.
                            "ignorePivotCurrencyHolidays": bool,  # Optional. Set to true
                              to include holidays of the pivot currency in the pricing when dates are
                              calculated. The default is false.
                            "interpolationMode": "str",  # Optional. The interpolation
                              method used in the curve bootstrapping. The default is Linear. Known
                              values are: "CubicSpline", "Constant", "Linear", and "CubicDiscount".
                            "useDelayedDataIfDenied": bool  # Optional. Set to true to
                              use the delayed data defined in the request. The default is false.
                        },
                        "valuationDate": "2020-02-20"  # Optional. The date on which the
                          curve is constructed. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2023-01-01'). The valuation date should not be in the future.
                    },
                    "type": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveCalculateOnTheFlyResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_calculate_on_the_fly_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveCalculateOnTheFlyResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardCurveResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forward_curve_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, curve_id: str, **kwargs: Any) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Read resource.

        :param curve_id: Required.
        :type curve_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_curve_resource_read_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, curve_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param curve_id: Required.
        :type curve_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_curve_resource_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self,
        curve_id: str,
        body: _models.FxForwardCurveResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardCurveResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def overwrite(
        self, curve_id: str, body: Union[_models.FxForwardCurveResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Is one of the following types: FxForwardCurveResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardCurveResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        curve_id: str,
        body: _models.FxForwardCurveResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardCurveResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def update(
        self, curve_id: str, body: Union[_models.FxForwardCurveResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Is one of the following types: FxForwardCurveResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardCurveResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveResponse or ServiceErrorResponse. The FxForwardCurveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "crossCurrency": {
                            "code": "str"  # The currency pair of FX Cross, expressed in
                              ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                        },
                        "constituents": [
                            fx_forward_curve_constituent
                        ],
                        "referenceCurrency": {
                            "code": "str"  # The currency expressed in ISO 4217
                              alphabetical format (e.g., 'EUR'). Required.
                        }
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_update_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def calculate(
        self,
        curve_id: str,
        body: _models.FxForwardCurveCalculateRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardCurveCalculateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,  # Optional.
                              An object to define calculation preferences for the curve.
                            "adjustAllSwapPointsToCrossCalendars": bool,  # Optional. An
                              object to define calculation preferences for the curve.
                            "extrapolationMode": "str",  # Optional. The extrapolation
                              method used in the curve bootstrapping. The default is None. Known values
                              are: "None", "Constant", and "Linear".
                            "ignoreInvalidInstruments": bool,  # Optional. Set to true to
                              ignore invalid instruments in the curve construction. The default is
                              false.
                            "ignorePivotCurrencyHolidays": bool,  # Optional. Set to true
                              to include holidays of the pivot currency in the pricing when dates are
                              calculated. The default is false.
                            "interpolationMode": "str",  # Optional. The interpolation
                              method used in the curve bootstrapping. The default is Linear. Known
                              values are: "CubicSpline", "Constant", "Linear", and "CubicDiscount".
                            "useDelayedDataIfDenied": bool  # Optional. Set to true to
                              use the delayed data defined in the request. The default is false.
                        },
                        "valuationDate": "2020-02-20"  # Optional. The date on which the
                          curve is constructed. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2023-01-01'). The valuation date should not be in the future.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def calculate(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def calculate(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def calculate(
        self, curve_id: str, body: Union[_models.FxForwardCurveCalculateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Calculate fx forward curve points from curve definition.

        :param curve_id: Required.
        :type curve_id: str
        :param body: Is one of the following types: FxForwardCurveCalculateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.FxForwardCurveCalculateRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCurveCalculateResponse or ServiceErrorResponse. The
         FxForwardCurveCalculateResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "parameters": {
                        "fxForwardCurveCalculationPreferences": {
                            "adjustAllDepositPointsToCrossCalendars": bool,  # Optional.
                              An object to define calculation preferences for the curve.
                            "adjustAllSwapPointsToCrossCalendars": bool,  # Optional. An
                              object to define calculation preferences for the curve.
                            "extrapolationMode": "str",  # Optional. The extrapolation
                              method used in the curve bootstrapping. The default is None. Known values
                              are: "None", "Constant", and "Linear".
                            "ignoreInvalidInstruments": bool,  # Optional. Set to true to
                              ignore invalid instruments in the curve construction. The default is
                              false.
                            "ignorePivotCurrencyHolidays": bool,  # Optional. Set to true
                              to include holidays of the pivot currency in the pricing when dates are
                              calculated. The default is false.
                            "interpolationMode": "str",  # Optional. The interpolation
                              method used in the curve bootstrapping. The default is Linear. Known
                              values are: "CubicSpline", "Constant", "Linear", and "CubicDiscount".
                            "useDelayedDataIfDenied": bool  # Optional. Set to true to
                              use the delayed data defined in the request. The default is false.
                        },
                        "valuationDate": "2020-02-20"  # Optional. The date on which the
                          curve is constructed. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2023-01-01'). The valuation date should not be in the future.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "constituents": [
                                fx_forward_curve_constituent
                            ],
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "parameters": {
                            "fxForwardCurveCalculationPreferences": {
                                "adjustAllDepositPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "adjustAllSwapPointsToCrossCalendars": bool,  #
                                  Optional. An object to define calculation preferences for the curve.
                                "extrapolationMode": "str",  # Optional. The
                                  extrapolation method used in the curve bootstrapping. The default is
                                  None. Known values are: "None", "Constant", and "Linear".
                                "ignoreInvalidInstruments": bool,  # Optional. Set to
                                  true to ignore invalid instruments in the curve construction. The
                                  default is false.
                                "ignorePivotCurrencyHolidays": bool,  # Optional. Set
                                  to true to include holidays of the pivot currency in the pricing when
                                  dates are calculated. The default is false.
                                "interpolationMode": "str",  # Optional. The
                                  interpolation method used in the curve bootstrapping. The default is
                                  Linear. Known values are: "CubicSpline", "Constant", "Linear", and
                                  "CubicDiscount".
                                "useDelayedDataIfDenied": bool  # Optional. Set to
                                  true to use the delayed data defined in the request. The default is
                                  false.
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date on which
                              the curve is constructed. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2023-01-01'). The valuation date should not be in the
                              future.
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "curve": {
                            "constituents": [
                                fx_forward_curve_constituent_values
                            ],
                            "curvePoints": [
                                {
                                    "endDate": "2020-02-20",  # The end date of
                                      the curve point tenor. The value is expressed in ISO 8601 format:
                                      YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                    "outright": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "startDate": "2020-02-20",  # The start date
                                      of the curve point tenor. The value is expressed in ISO 8601
                                      format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                    "swapPoint": {
                                        "ask": 0.0,  # Optional. The ask
                                          value.
                                        "bid": 0.0,  # Optional. The bid
                                          value.
                                        "mid": 0.0  # Optional. The mid
                                          value.
                                    },
                                    "tenor": "str",  # A code indicating the
                                      length of the period between the start date and the end date of
                                      the curve point.  Predefined values are: ON (Overnight - A one
                                      business day period that starts today), TN (Tomorrow-Next - A one
                                      business day period that starts next business day, SPOT (Spot
                                      Date), SN (Spot-Next - A one business day period that starts at
                                      the spot date of a currency pair) or SW (Spot-Week - A one
                                      business week period that starts at the spot date of a currency
                                      pair). Tenors can also be specified as a whole number of time
                                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y
                                      (Years). For example, one month is written '1M', 3 years is
                                      written: '3Y'. Time units can be mixed. For example, 5M3D means
                                      '5 months and 3 days'. Note: units must be written in descending
                                      order of size (Y > M > W > D). Required.
                                    "instruments": [
                                        {
                                            "instrumentCode": "str"  #
                                              The identifier of the instrument used to calculate the
                                              curve point. Required.
                                        }
                                    ]
                                }
                            ],
                            "invalidConstituents": [
                                fx_invalid_constituent
                            ],
                            "underlyingCurves": {
                                "fxForwardCurves": [
                                    {
                                        "crossCurrency": {
                                            "code": "str"  # The currency
                                              pair of FX Cross, expressed in ISO 4217 alphabetical
                                              format (e.g., 'EURCHF'). Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "outright": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "swapPoint": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ],
                                "interestRateCurves": [
                                    {
                                        "currency": {
                                            "code": "str"  # The currency
                                              expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                              Required.
                                        },
                                        "curvePoints": [
                                            {
                                                "discountFactor":
                                                  0.0,  # The discount factor calculated for a given
                                                  curve point. Required.
                                                "endDate":
                                                  "2020-02-20",  # The end date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                                "ratePercent": {
                                                    "ask": 0.0,
                                                      # Optional. The ask value.
                                                    "bid": 0.0,
                                                      # Optional. The bid value.
                                                    "mid": 0.0  #
                                                      Optional. The mid value.
                                                },
                                                "startDate":
                                                  "2020-02-20",  # The start date of the curve point
                                                  tenor. The value is expressed in ISO 8601 format:
                                                  YYYY-MM-DD (e.g., '2023-01-01'). Required.
                                                "tenor": "str",  # A
                                                  code indicating the length of the period between the
                                                  start date and the end date of the curve point.
                                                  Predefined values are: ON (Overnight - A one business
                                                  day period that starts today), TN (Tomorrow-Next - A
                                                  one business day period that starts next business
                                                  day, SPOT (Spot Date), SN (Spot-Next - A one business
                                                  day period that starts at the spot date of a currency
                                                  pair) or SW (Spot-Week - A one business week period
                                                  that starts at the spot date of a currency pair).
                                                  Tenors can also be specified as a whole number of
                                                  time units. Possible units are: D (Days), W (Weeks),
                                                  M (Months) or Y (Years). For example, one month is
                                                  written '1M', 3 years is written: '3Y'. Time units
                                                  can be mixed. For example, 5M3D means '5 months and 3
                                                  days'. Note: units must be written in descending
                                                  order of size (Y > M > W > D). Required.
                                                "instruments": [
                                                    {
                "instrumentCode": "str"  # The identifier of
                                                          the instrument used to calculate the curve
                                                          point. Required.
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardCurveCalculateResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_calculate_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCurveCalculateResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forwards_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.FxForwardCollectionResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List resource.

        :keyword item_per_page: Default value is None.
        :paramtype item_per_page: int
        :keyword names: Default value is None.
        :paramtype names: list[str]
        :keyword spaces: Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardCollectionResponse or ServiceErrorResponse. The FxForwardCollectionResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "description": {
                                "summary": "str",  # Optional. A summary of
                                  information about the resource. Limited to 500 characters.
                                "tags": [
                                    "str"  # Optional. User-defined tags to
                                      identify the resource. Limited to 5 items and 50 characters each.
                                ]
                            },
                            "id": "str",  # Optional. Unique resource ID specified by
                              LSEG.
                            "type": "str"  # Optional. The resource type. Possible values
                              are: Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve,
                              Analytics, Loan, FxSpot, NonDeliverableForward, Deposit,
                              CrossCurrencySwap or Space.
                        }
                    ],
                    "links": {
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forwards_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.FxForwardResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create(
        self, body: Union[_models.FxForwardResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Is one of the following types: FxForwardResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price(
        self, body: _models.FxForwardOnTheFlyPriceRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardOnTheFlyPriceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def price(
        self, body: Union[_models.FxForwardOnTheFlyPriceRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade) on the fly.

        :param body: Is one of the following types: FxForwardOnTheFlyPriceRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.FxForwardOnTheFlyPriceRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyPriceResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardOnTheFlyPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_price_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardOnTheFlyPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value(
        self, body: _models.FxForwardOnTheFlyValuationRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardOnTheFlyValuationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def value(
        self, body: Union[_models.FxForwardOnTheFlyValuationRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade) on the fly.

        :param body: Is one of the following types: FxForwardOnTheFlyValuationRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.FxForwardOnTheFlyValuationRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxForwardOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardOnTheFlyValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_value_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardOnTheFlyValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_forward_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, instrument_id: str, **kwargs: Any) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Read resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_resource_read_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, instrument_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_forward_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self,
        instrument_id: str,
        body: _models.FxForwardResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def overwrite(
        self, instrument_id: str, body: Union[_models.FxForwardResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxForwardResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        instrument_id: str,
        body: _models.FxForwardResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def update(
        self, instrument_id: str, body: Union[_models.FxForwardResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxForwardResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardResponse or ServiceErrorResponse. The FxForwardResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "endDate": date,
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                          currency bought or sold.
                        "settlementType": "str",  # Optional. How the instrument is settled.
                          Possible values are: Physical or Cash. Default is Physical. Known values are:
                          "Cash" and "Physical".
                        "startDate": date
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_update_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price(
        self,
        instrument_id: str,
        body: _models.FxForwardPriceRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardPriceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def price(
        self, instrument_id: str, body: Union[_models.FxForwardPriceRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Forward Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxForwardPriceRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxForwardPriceRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardPriceResponse or ServiceErrorResponse. The FxForwardPriceResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "tradedCrossRate": 0.0,  # The contractual exchange rate
                              agreed by the parties. Required.
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxOutrightCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy1Ccy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "fxSwapsCcy2": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            },
                            "settlementAmount": 0.0  # Optional. The settlement amount in
                              an Fx Non-Deliverable Forward (NDF) contract. The value is expressed in
                              the settlement currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_price_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value(
        self,
        instrument_id: str,
        body: _models.FxForwardValuationRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxForwardValuationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def value(
        self, instrument_id: str, body: Union[_models.FxForwardValuationRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Forward Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxForwardValuationRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.FxForwardValuationRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxForwardValuationResponse or ServiceErrorResponse. The FxForwardValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "dateType":

                # JSON input template for discriminator value "AdjustableDate":
                date = {
                    "date": "2020-02-20",  # The date that will be adjusted based on the
                      dateMovingConvention.The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                      2021-01-01). Required.
                    "dateType": "AdjustableDate",
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str"  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                }

                # JSON input template for discriminator value "RelativeAdjustableDate":
                date = {
                    "dateType": "RelativeAdjustableDate",
                    "tenor": "str",  # A code indicating the length of the period between the
                      start date and the end date of the instrument.  Predefined values are: ON
                      (Overnight - A one business day period that starts today), TN (Tomorrow-Next - A
                      one business day period that starts next business day, SPOT (Spot Date), SN
                      (Spot-Next - A one business day period that starts at the spot date of a currency
                      pair) or SW (Spot-Week - A one business week period that starts at the spot date
                      of a currency pair). Tenors can also be specified as a whole number of time
                      units. Possible units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                      example, one month is written '1M', 3 years is written: '3Y'. Time units can be
                      mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
                      written in descending order of size (Y > M > W > D). Required.
                    "calendars": [
                        {
                            "id": "str",  # Optional. The unique id of the resource.
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "type": "str"  # Optional. The type of the resource.
                        }
                    ],
                    "dateMovingConvention": "str",  # Optional. The method to adjust dates to
                      working days. The possible values are: ModifiedFollowing: dates are adjusted to
                      the next business day convention unless it goes into the next month. In such
                      case, the previous business day convention is used, NextBusinessDay: dates are
                      moved to the following working day, PreviousBusinessDay: dates are moved to the
                      preceding working day, NoMoving: dates are not adjusted, EveryThirdWednesday:
                      dates are moved to the third Wednesday of the month, or to the next working day
                      if the third Wednesday is not a working day, BbswModifiedFollowing: dates are
                      adjusted to the next business day convention unless it goes into the next month,
                      or crosses mid-month (15th). In such case, the previous business day convention
                      is used. Default is ModifiedFollowing. Known values are: "ModifiedFollowing",
                      "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                      "BbswModifiedFollowing".
                    "referenceDate": "str"  # Optional. The date which has been used as a
                      reference date for the provided tenor. Possible values are: StartDate,
                      ValuationDate, SpotDate. Default is StartDate. Known values are: "SpotDate",
                      "StartDate", and "ValuationDate".
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "endDate": date,
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "settlementType": "str",  # Optional. How the instrument is
                              settled.  Possible values are: Physical or Cash. Default is Physical.
                              Known values are: "Cash" and "Physical".
                            "startDate": date
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "valuation": {
                            "discountFactor": 0.0,  # Optional.
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxForwardValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_value_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxForwardValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxSpotsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_spots_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        names: Optional[List[str]] = None,
        spaces: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Union[_models.FxSpotCollectionResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """List resource.

        :keyword item_per_page: Default value is None.
        :paramtype item_per_page: int
        :keyword names: Default value is None.
        :paramtype names: list[str]
        :keyword spaces: Default value is None.
        :paramtype spaces: list[str]
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotCollectionResponse or ServiceErrorResponse. The FxSpotCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotCollectionResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": [
                        {
                            "location": {
                                "name": "str",  # The name of the resource. Required.
                                "space": "str"  # Optional. The storage location for
                                  the resource.
                            },
                            "description": {
                                "summary": "str",  # Optional. A summary of
                                  information about the resource. Limited to 500 characters.
                                "tags": [
                                    "str"  # Optional. User-defined tags to
                                      identify the resource. Limited to 5 items and 50 characters each.
                                ]
                            },
                            "id": "str",  # Optional. Unique resource ID specified by
                              LSEG.
                            "type": "str"  # Optional. The resource type. Possible values
                              are: Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve,
                              Analytics, Loan, FxSpot, NonDeliverableForward, Deposit,
                              CrossCurrencySwap or Space.
                        }
                    ],
                    "links": {
                        "price": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "self": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "value": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional. Required.
                            "httpMethod": "str"  # Optional. Required.
                        },
                        "first": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "last": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "next": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        },
                        "prev": {
                            "href": "str",  # Required.
                            "hrefSchema": "str",  # Optional.
                            "httpMethod": "str"  # Optional.
                        }
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxSpotCollectionResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_spots_resource_list_request(
            item_per_page=item_per_page,
            names=names,
            spaces=spaces,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotCollectionResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.FxSpotResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def create(
        self, body: Union[_models.FxSpotResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Create resource.

        :param body: Is one of the following types: FxSpotResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxSpotResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 201
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price_on_the_fly(
        self, body: _models.FxSpotOnTheFlyPriceRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotOnTheFlyPriceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price_on_the_fly(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price_on_the_fly(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def price_on_the_fly(
        self, body: Union[_models.FxSpotOnTheFlyPriceRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade) on the fly.

        :param body: Is one of the following types: FxSpotOnTheFlyPriceRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.FxSpotOnTheFlyPriceRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyPriceResponse or ServiceErrorResponse. The FxSpotOnTheFlyPriceResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyPriceResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotOnTheFlyPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_price_on_the_fly_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotOnTheFlyPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value_on_the_fly(
        self, body: _models.FxSpotOnTheFlyValuationRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotOnTheFlyValuationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value_on_the_fly(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value_on_the_fly(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def value_on_the_fly(
        self, body: Union[_models.FxSpotOnTheFlyValuationRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade) on the fly.

        :param body: Is one of the following types: FxSpotOnTheFlyValuationRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.FxSpotOnTheFlyValuationRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotOnTheFlyValuationResponse or ServiceErrorResponse. The
         FxSpotOnTheFlyValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotOnTheFlyValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    },
                    "type": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotOnTheFlyValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_value_on_the_fly_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotOnTheFlyValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxSpotResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.AnalyticsAPIClient`'s
        :attr:`fx_spot_resource` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def read(self, instrument_id: str, **kwargs: Any) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Read resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 410, 428, 429,
                  500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_spot_resource_read_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def delete(self, instrument_id: str, **kwargs: Any) -> Optional[_models.ServiceErrorResponse]:
        """Delete resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: ServiceErrorResponse or None. The ServiceErrorResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ServiceErrorResponse or None
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        _request = build_fx_spot_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            204,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def overwrite(
        self, instrument_id: str, body: _models.FxSpotResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def overwrite(
        self, instrument_id: str, body: Union[_models.FxSpotResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Overwrite resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxSpotResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxSpotResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self, instrument_id: str, body: _models.FxSpotResource, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def update(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def update(
        self, instrument_id: str, body: Union[_models.FxSpotResource, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Patch resource.

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxSpotResource, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxSpotResource or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotResponse or ServiceErrorResponse. The FxSpotResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "definition": {
                        "fxRate": {
                            "crossCurrency": {
                                "code": "str"  # The currency pair of FX Cross,
                                  expressed in ISO 4217 alphabetical format (e.g., 'EURCHF'). Required.
                            },
                            "rate": 0.0  # Optional. The contractual exchange rate agreed
                              by the parties. This is used to compute the contra amount if it is not
                              provided.
                        },
                        "contraAmount": 0.0,  # Optional. The amount of contra currency
                          exchanged to buy or sell the deal (base) currency.
                        "dealAmount": 0.0  # Optional. The amount of the deal (base) currency
                          bought or sold.
                    },
                    "location": {
                        "name": "str",  # The name of the resource. Required.
                        "space": "str"  # Optional. The storage location for the resource.
                    },
                    "description": {
                        "summary": "str",  # Optional. A summary of information about the
                          resource. Limited to 500 characters.
                        "tags": [
                            "str"  # Optional. User-defined tags to identify the
                              resource. Limited to 5 items and 50 characters each.
                        ]
                    },
                    "id": "str",  # Optional. Unique resource ID specified by LSEG.
                    "type": "str"  # Optional. The resource type. Possible values are: Calendar,
                      Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan, FxSpot,
                      NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                }

                # response body for status code(s): 200
                response == {
                    "data": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "meta": {
                        "createTime": "2020-02-20 00:00:00",  # The date and time when the
                          resource was created.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z). Required.
                        "creator": "str",  # The uuid of the user who created the resource.
                          Required.
                        "revision": "str",  # The version of the resource. Required.
                        "status": "str",  # The status of the resource. Required. Known
                          values are: "Active" and "Deleted".
                        "deleteTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was deleted.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                          when the resource was updated.  The value is expressed in ISO 8601 format:
                          YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2023-01-01T00:00:00Z).
                        "updatedBy": "str"  # Optional. The name of the user who updated the
                          resource.
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 412,
                  415, 423, 428, 429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_update_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [
            200,
            400,
            401,
            403,
            404,
            405,
            406,
            408,
            409,
            410,
            412,
            415,
            423,
            428,
            429,
            500,
            501,
            503,
        ]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 412:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 415:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 423:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def price(
        self,
        instrument_id: str,
        body: _models.FxSpotPriceRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotPriceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def price(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def price(
        self, instrument_id: str, body: Union[_models.FxSpotPriceRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Price a Fx Spot Instrument (pre-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxSpotPriceRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxSpotPriceRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotPriceResponse or ServiceErrorResponse. The FxSpotPriceResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse or ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "pricingAnalysis": {
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the amount of the deal (base) currency.
                            "dealAmount": 0.0,  # Optional. The amount of the deal (base)
                              currency bought or sold.
                            "fxSpot": {
                                "ask": 0.0,  # Optional. The ask quote.
                                "bid": 0.0  # Optional. The bid quote.
                            }
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ]
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotPriceResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_price_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotPriceResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def value(
        self,
        instrument_id: str,
        body: _models.FxSpotValuationRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.FxSpotValuationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    @overload
    def value(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """

    def value(
        self, instrument_id: str, body: Union[_models.FxSpotValuationRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]:
        # pylint: disable=line-too-long
        """Valuate a Fx Spot Instrument (post-trade).

        :param instrument_id: Required.
        :type instrument_id: str
        :param body: Is one of the following types: FxSpotValuationRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.FxSpotValuationRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: FxSpotValuationResponse or ServiceErrorResponse. The FxSpotValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse or
         ~analyticsapi.models.ServiceErrorResponse
        :raises ~corehttp.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "constituents": [
                                    fx_forward_curve_constituent
                                ],
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "template": {
                                    "id": "str",  # Optional. The unique id of
                                      the resource.
                                    "location": {
                                        "name": "str",  # The name of the
                                          resource. Required.
                                        "space": "str"  # Optional. The
                                          storage location for the resource.
                                    },
                                    "type": "str"  # Optional. The type of the
                                      resource.
                                }
                            }
                        ]
                    },
                    "parameters": {
                        "fxPricingPreferences": {
                            "ignoreReferenceCurrencyHolidays": bool,  # Optional. Set to
                              True to ignore reference currency holidays.
                            "referenceCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            },
                            "reportCurrency": {
                                "code": "str"  # The currency expressed in ISO 4217
                                  alphabetical format (e.g., 'EUR'). Required.
                            }
                        },
                        "valuationDate": "2020-02-20"  # Optional. "The date at which the
                          instrument is valued. The value is expressed in ISO 8601 format: YYYY-MM-DD
                          (e.g., '2021-01-01').".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "context": {
                        "definition": {
                            "fxRate": {
                                "crossCurrency": {
                                    "code": "str"  # The currency pair of FX
                                      Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                      'EURCHF'). Required.
                                },
                                "rate": 0.0  # Optional. The contractual exchange
                                  rate agreed by the parties. This is used to compute the contra amount
                                  if it is not provided.
                            },
                            "contraAmount": 0.0,  # Optional. The amount of contra
                              currency exchanged to buy or sell the deal (base) currency.
                            "dealAmount": 0.0  # Optional. The amount of the deal (base)
                              currency bought or sold.
                        },
                        "location": {
                            "name": "str",  # The name of the resource. Required.
                            "space": "str"  # Optional. The storage location for the
                              resource.
                        },
                        "description": {
                            "summary": "str",  # Optional. A summary of information about
                              the resource. Limited to 500 characters.
                            "tags": [
                                "str"  # Optional. User-defined tags to identify the
                                  resource. Limited to 5 items and 50 characters each.
                            ]
                        },
                        "id": "str",  # Optional. Unique resource ID specified by LSEG.
                        "marketData": {
                            "fxForwardCurves": [
                                {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    },
                                    "template": {
                                        "id": "str",  # Optional. The unique
                                          id of the resource.
                                        "location": {
                                            "name": "str",  # The name of
                                              the resource. Required.
                                            "space": "str"  # Optional.
                                              The storage location for the resource.
                                        },
                                        "type": "str"  # Optional. The type
                                          of the resource.
                                    }
                                }
                            ]
                        },
                        "parameters": {
                            "fxPricingPreferences": {
                                "ignoreReferenceCurrencyHolidays": bool,  # Optional.
                                  Set to True to ignore reference currency holidays.
                                "referenceCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                },
                                "reportCurrency": {
                                    "code": "str"  # The currency expressed in
                                      ISO 4217 alphabetical format (e.g., 'EUR'). Required.
                                }
                            },
                            "valuationDate": "2020-02-20"  # Optional. "The date at which
                              the instrument is valued. The value is expressed in ISO 8601 format:
                              YYYY-MM-DD (e.g., '2021-01-01').".
                        },
                        "type": "str"  # Optional. The resource type. Possible values are:
                          Calendar, Currency, CrossCurrency, IrCurve, FxForwardCurve, Analytics, Loan,
                          FxSpot, NonDeliverableForward, Deposit, CrossCurrencySwap or Space.
                    },
                    "data": {
                        "description": {
                            "endDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "startDate": {
                                "adjusted": "2020-02-20",  # The date that has been
                                  adjusted based on the dateMovingConvention. The value is expressed in
                                  ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required.
                                "dateMovingConvention": "str",  # Required. Known
                                  values are: "ModifiedFollowing", "NextBusinessDay",
                                  "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
                                  "BbswModifiedFollowing".
                                "unAdjusted": "2020-02-20",  # The unadjusted date.
                                  The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
                                  2021-01-01). Required.
                                "date": "2020-02-20",  # Optional. The date provided
                                  in the request. The value is expressed in ISO 8601 format: YYYY-MM-DD
                                  (e.g. 2021-01-01).
                                "processingInformation": "str",  # Optional. The
                                  error message for the calculation in case of a non-blocking error.
                                "referenceDate": "str",  # Optional. The date which
                                  has been used as a reference date for the provided tenor. Possible
                                  values are: StartDate, ValuationDate, SpotDate. Known values are:
                                  "SpotDate", "StartDate", and "ValuationDate".
                                "tenor": "str"  # Optional. A tenor (relatvie date)
                                  expressed as a code indicating the period between
                                  referenceDate(default=startDate) to endDate of the instrument (e.g.,
                                  '6M', '1Y').
                            },
                            "valuationDate": "2020-02-20"  # Optional. The date at which
                              the instrument is valued. The date is expressed in ISO 8601 format:
                              YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
                        },
                        "greeks": {
                            "deltaAmountInContraCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the contra (quote) currency.
                            "deltaAmountInDealCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the deal currency.
                            "deltaAmountInReportCcy": 0.0,  # Optional. The change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument. The
                              value is expressed in the reporting currency.
                            "deltaPercent": 0.0  # Optional. The percentage change in the
                              instrument's price or market value caused by a one-unit change in the
                              price of the underlying asset, or by a 1bp change in the swap rate for a
                              swaption, or by a 100bp change in the outright for a FX instrument.
                        },
                        "processingInformation": [
                            "str"  # Optional.
                        ],
                        "valuation": {
                            "marketValueInContraCcy": 0.0,  # Optional. The market value
                              of the instrument in the contra (quote) currency.
                            "marketValueInDealCcy": 0.0,  # Optional. The market value of
                              the instrument in the deal currency.
                            "marketValueInReportCcy": 0.0  # Optional. The present value
                              of the future cash flow in the reporting currency.
                        }
                    },
                    "marketData": {
                        "fxForwardCurves": [
                            {
                                "data": [
                                    {
                                        "endDate": "2020-02-20",  # The end
                                          date of the curve point tenor. The value is expressed in ISO
                                          8601 format: YYYY-MM-DD (e.g., '2024-01-01'). Required.
                                        "outright": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "startDate": "2020-02-20",  # The
                                          start date of the curve point tenor. The value is expressed
                                          in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
                                          Required.
                                        "swapPoint": {
                                            "ask": 0.0,  # Optional. The
                                              ask value.
                                            "bid": 0.0,  # Optional. The
                                              bid value.
                                            "mid": 0.0  # Optional. The
                                              mid value.
                                        },
                                        "tenor": "str",  # A code indicating
                                          the length of the period between the start date and the end
                                          date of the curve point.  Predefined values are: ON
                                          (Overnight - A one business day period that starts today), TN
                                          (Tomorrow-Next - A one business day period that starts next
                                          business day, SPOT (Spot Date), SN (Spot-Next - A one
                                          business day period that starts at the spot date of a
                                          currency pair) or SW (Spot-Week - A one business week period
                                          that starts at the spot date of a currency pair). Tenors can
                                          also be specified as a whole number of time units. Possible
                                          units are: D (Days), W (Weeks), M (Months) or Y (Years). For
                                          example, one month is written '1M', 3 years is written: '3Y'.
                                          Time units can be mixed. For example, 5M3D means '5 months
                                          and 3 days'. Note: units must be written in descending order
                                          of size (Y > M > W > D). Required.
                                        "instruments": [
                                            {
                                                "instrumentCode":
                                                  "str"  # The identifier of the instrument used to
                                                  calculate the curve point. Required.
                                            }
                                        ]
                                    }
                                ],
                                "definition": {
                                    "crossCurrency": {
                                        "code": "str"  # The currency pair of
                                          FX Cross, expressed in ISO 4217 alphabetical format (e.g.,
                                          'EURCHF'). Required.
                                    },
                                    "constituents": [
                                        fx_forward_curve_constituent
                                    ],
                                    "referenceCurrency": {
                                        "code": "str"  # The currency
                                          expressed in ISO 4217 alphabetical format (e.g., 'EUR').
                                          Required.
                                    }
                                }
                            }
                        ]
                    }
                }
                # response body for status code(s): 400, 401, 403, 404, 405, 406, 408, 409, 410, 428,
                  429, 500, 501, 503
                response == {
                    "error": {
                        "code": "str",  # The code of the error. Required.
                        "id": "str",  # The identifier of the error. Required.
                        "message": "str",  # The message in case of a blocking error in
                          calculation. Required.
                        "errors": [
                            {
                                "key": "str",  # The specification of the request in
                                  which an error occurs. Required.
                                "reason": "str",  # The reason why an error occurs.
                                  Required.
                                "invalidName": "str",  # Optional. The name of the
                                  invalid property.
                                "name": "str"  # Optional. The name of the property
                                  causing the error.
                            }
                        ],
                        "status": "str"  # Optional. The status of the error.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.FxSpotValuationResponse, _models.ServiceErrorResponse]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_value_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client.pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 405, 406, 408, 409, 410, 428, 429, 500, 501, 503]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.FxSpotValuationResponse, response.json())

        if response.status_code == 400:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 401:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 403:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 405:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 406:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 408:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 409:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 410:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 428:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 429:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 500:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 501:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if response.status_code == 503:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ServiceErrorResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
