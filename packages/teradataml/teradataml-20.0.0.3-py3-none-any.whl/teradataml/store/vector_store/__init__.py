"""
Unpublished work.
Copyright (c) 2024 by Teradata Corporation. All rights reserved.
TERADATA CORPORATION CONFIDENTIAL AND TRADE SECRET

Primary Owner: aanchal.kavedia@teradata.com
Secondary Owner: adithya.avvaru@teradata.com

This file implements VectorStore class along with its method.
"""
import base64
import json, os, pandas as pd
from json.decoder import JSONDecodeError
from teradataml.common.constants import HTTPRequest, Action as action_enum, Permission as permission_enum
from teradataml.common.exceptions import TeradataMlException
from teradataml.common.messages import Messages
from teradataml.common.messagecodes import MessageCodes
from teradataml.common.utils import UtilFuncs
from teradataml.context.context import _get_user
from teradataml import configure
from teradataml.utils.validators import _Validators
from teradataml.utils.dtypes import _ListOf
from teradataml.scriptmgmt.UserEnv import _get_auth_token

class _SimilaritySearch:
    """
    Internal class to create a similarity search object which is needed
    to display the results in a tabular format and at the same time store
    the json object which is used in prepare response.
    """
    def __init__(self, response):
        self.similar_objects_count = response['similar_objects_count']
        self._json_obj = response['similar_objects_list']
        self.similar_objects = pd.DataFrame(self._json_obj)

    def __repr__(self):
        return f"similar_objects_count:{self.similar_objects_count}\nsimilar_objects:\n{self.similar_objects})"

class VectorStore:
    def __init__(self,
                 name=None,
                 enable_logging=False,
                 **kwargs):
        """
        DESCRIPTION:
            VectorStore contains a vectorized version of data.
            The vectorization typically is a result of embeddings generated by
            an AI LLM.
            There are two types of vector stores based on the use cases:
                * Content-based vector store: A vector store built on the
                  contents of table/view/teradataml DataFrame.
                  The table can be formed from the contents of file / pdf.
                  Questions can be asked against the contents of the table and
                  top matches of relevant rows are returned based on search.
                  This can be followed by a textual response generated using
                  an LLM by manipulating the top matches.

                * Metadata-based vector store: A vector store built on the
                  metadata of a set of tables. Questions can be asked
                  against a table or set of tables and top table
                  matches are returned.

        PARAMETERS:
            name:
                Required Argument.
                Specifies the name of the vector store either to connect to an
                existing vector store or to create a new vector store.
                Types: str

            enable_logging:
                Optional Argument.
                Specifies whether logging should be enabled for vector store
                methods.
                Default Value: False
                Types: bool

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            vs = VectorStore(name="vs", enable_logging=True)
        """
        # Initialize variables.
        self.name = name
        self._enable_logging = enable_logging

        # Validating name and enable_logging.
        arg_info_matrix = []
        arg_info_matrix.append(["name", self.name, False, (str), True])
        arg_info_matrix.append(["enable_logging", self._enable_logging, True, (bool)])

        _Validators._validate_missing_required_arguments(arg_info_matrix)
        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        # Check if vector_store_base_url is set or not.
        if configure._vector_store_base_url is None:
            error_msg = Messages.get_message(MessageCodes.FUNC_EXECUTION_FAILED,
                                             'VectorStore()', 'Auth token is not set.'
                                                              ' Set it by calling set_auth_token().')
            raise RuntimeError(error_msg)

        self.__base_url = f"{configure._vector_store_base_url}/api/v1/"
        self.__session_url = f"{self.__base_url}session/"
        self.__vectorstore_url = f"{self.__base_url}vectorstore/"

        # Call connect in case of CCP enabled tenant.
        # If non-ccp, connect should be explicitly called passing the required params.
        self._connect()

    def __set_vs_index_and_vs_parameters(self, **kwargs):
        """
        Internal function to set the parameters for the vector store.
        Keeping it common, as it will be required by update and initialize
        methods.
        """
        ## Initializing vs_index params
        self._database_name = kwargs.get('database_name', None)
        self._object_name = kwargs.get('object_name', None)
        self._key_columns = kwargs.get('key_columns', None)
        self._data_columns = kwargs.get('data_columns', None)
        self._vector_columns = kwargs.get('vector_columns', None)
        self._chunk_size = kwargs.get("chunk_size", None)
        self._optimized_chunking = kwargs.get('optimized_chunking', None)
        self._header_height = kwargs.get('header_height', None)
        self._footer_height = kwargs.get('footer_height', None)

        ## Initializing vs_parameters
        self._description = kwargs.get("description", None)
        self._embeddings_model = kwargs.get("embeddings_model", None)
        self._embeddings_dims = kwargs.get("embeddings_dims", None)
        self._initial_delay_ms = kwargs.get("initial_delay_ms", None)
        self._delay_max_retries = kwargs.get("delay_max_retries", None)
        self._delay_exp_base = kwargs.get("delay_exp_base", None)
        self._delay_jitter = kwargs.get("delay_jitter", None)
        self._metric = kwargs.get("metric", None)
        self._search_algorithm = kwargs.get("search_algorithm", None)
        self._top_k = kwargs.get("top_k", None)
        self._search_threshold = kwargs.get("search_threshold", None)
        self._initial_centroids_method = kwargs.get("initial_centroids_method", None)
        self._train_numcluster = kwargs.get("train_numcluster", None)
        self._max_iternum = kwargs.get("max_iternum", None)
        self._stop_threshold = kwargs.get("stop_threshold", None)
        self._seed = kwargs.get("seed", None)
        self._num_init = kwargs.get("num_init", None)
        self._search_numcluster = kwargs.get("search_numcluster", None)
        self._prompt = kwargs.get("prompt", None)
        self._document_files = kwargs.get("document_files", None)
        self._chat_completion_model = kwargs.get("chat_completion_model", None)

        # Validating vs_index
        arg_info_matrix = []
        arg_info_matrix.append(["database_name", self._database_name, True, (str), True])
        arg_info_matrix.append(["object_name", self._object_name, True, (str), True])
        arg_info_matrix.append(["key_columns", self._key_columns, True, (str, list), True])
        arg_info_matrix.append(["data_columns", self._data_columns, True, (str, list), True])
        arg_info_matrix.append(["vector_columns", self._vector_columns, True, (str), True])
        arg_info_matrix.append(["chunk_size", self._chunk_size, True, (int), True])
        arg_info_matrix.append(["optimized_chunking", self._optimized_chunking, True, (bool), True])
        arg_info_matrix.append(["header_height", self._header_height, True, (int), True])
        arg_info_matrix.append(["footer_height", self._footer_height, True, (int), True])

        # Validating vs_parameters
        arg_info_matrix.append(["description", self._description, True, (str), True])
        arg_info_matrix.append(["embeddings_model", self._embeddings_model, True, (str), True])
        arg_info_matrix.append(["embeddings_dims", self._embeddings_dims, True, (int), True])
        arg_info_matrix.append(["initial_delay_ms", self._initial_delay_ms, True, (int), True])
        arg_info_matrix.append(["delay_max_retries", self._delay_max_retries, True, (int), True])
        arg_info_matrix.append(["delay_exp_base", self._delay_exp_base, True, (int), True])
        arg_info_matrix.append(["delay_jitter", self._delay_jitter, True, (bool), True])
        arg_info_matrix.append(["metric", self._metric, True, (str), True])
        arg_info_matrix.append(["search_algorithm", self._search_algorithm, True, (str), True])
        arg_info_matrix.append(["top_k", self._top_k, True, (int), True])
        arg_info_matrix.append(["initial_centroids_method", self._initial_centroids_method, True, (str),
                           True])
        arg_info_matrix.append(["train_numcluster", self._train_numcluster, True, (int), True])
        arg_info_matrix.append(["max_iternum", self._max_iternum, True, (int), True])
        arg_info_matrix.append(["stop_threshold", self._stop_threshold, True, (float), True])
        arg_info_matrix.append(["seed", self._seed, True, (int), True])
        arg_info_matrix.append(["num_init", self._num_init, True, (int), True])
        arg_info_matrix.append(["search_threshold", self._search_threshold, True, (float), True])
        arg_info_matrix.append(["search_numcluster", self._search_numcluster, True, (int), True])
        arg_info_matrix.append(["prompt", self._prompt, True, (str), True])
        arg_info_matrix.append(["chat_completion_model", self._chat_completion_model, True, (str),
                           True])
        arg_info_matrix.append(["document_files", self._document_files, True, (str, list),
                           True])

        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        ## Input document files structure is: [fully_qualified_file_name1,
        #                                      fully_qualified_file_name2]
        # Forming document files structure as the API accepts:
        # document_files = [('document_files', ('file1.pdf',
        #                    open('/location/file1.pdf', 'rb'),
        #                    'application/pdf')),
        #                   ('document_files', ('file2.pdf',
        #                    open('/location/file2.pdf', 'rb'),
        #                    'application/pdf'))
        #                   ]

        if self._document_files:
            document_files = self._document_files
            self._document_files = []

            for file in document_files:
                # Get the file name from fully qualified path
                file_name = os.path.basename(file)
                # Form the string 'application/pdf' based on the file extension.
                file_type = f"application/{os.path.splitext(file_name)[1]}".replace(".", "")
                self._document_files.append(('document_files', (file_name,
                                                                open(file, 'rb'),
                                                                file_type)))

        vs_parameters = {"description": self._description,
                         "embeddings_model": self._embeddings_model,
                         "embeddings_dims": self._embeddings_dims,
                         "initial_delay_ms": self._initial_delay_ms,
                         "delay_max_retries": self._delay_max_retries,
                         "delay_exp_base": self._delay_exp_base,
                         "delay_jitter": self._delay_jitter,
                         "metric": self._metric,
                         "search_algorithm": self._search_algorithm,
                         "top_k": self._top_k,
                         "initial_centroids_method": self._initial_centroids_method,
                         "train_numcluster": self._train_numcluster,
                         "max_iternum": self._max_iternum,
                         "stop_threshold": self._stop_threshold,
                         "seed": self._seed,
                         "num_init": self._num_init,
                         "search_threshold": self._search_threshold,
                         "search_numcluster": self._search_numcluster,
                         "prompt": self._prompt,
                         "chat_completion_model": self._chat_completion_model}
        # Only add keys with non-None values
        self.__vs_parameters = {k: v for k, v in vs_parameters.items() if v is not None}

        vs_index = {
            'database_name': self._database_name,
            'object_name': self._object_name,
            'key_columns': self._key_columns,
            'data_columns': self._data_columns,
            'vector_column': self._vector_columns,
            'chunk_size': self._chunk_size,
            'optimized_chunking': self._optimized_chunking,
            'header_height': self._header_height,
            'footer_height': self._footer_height
        }
        # Only add keys with non-None values
        self.__vs_index = {k: v for k, v in vs_index.items() if v is not None}
        
    def __get_header(self):
        """
        DESCRIPTION:
            Function to get the latest token if it is expired for all
            the function calls.

        RETURNS:
            Latest header with auth_token in case of CCP enabled tenant
            or the header formed by passing user_id and password.

        """
        if self.__ccp_enabled:
            return _get_auth_token()
        else:
            return self.__headers

    def _connect(self,
                **kwargs):
        """
        DESCRIPTION:
            Function to connect to vector store in Teradata Vantage.

        PARAMETERS:
             host:
                Optional Argument.
                Specifies the fully qualified domain name or IP address of the
                Teradata System to connect to.
                Types: str

            username:
                Optional Argument.
                Specifies the username for connecting to/create a vector
                store in Teradata Vantage.
                Types: str

            password:
                Optional Argument.
                Specifies the password required for the username.
                Types: str

            database:
                Optional Argument.
                Specifies the initial database to use after logon,
                instead of the user's default database.
                Types: str

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore
            # Example 1: Connect to the database using host, database,
            #            username and password.
            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            # Call the connect method to connect to the database.
            vs._connect(host='<host>', username='<user>', password='<password>', database='<database>')
        """
        ## Initialize connection parameters.
        self.__host = kwargs.get("host", None)
        self.__user = kwargs.get("username", None)
        self.__password = kwargs.get("password", None)
        self.__database = kwargs.get("database", _get_user())
        # Default is always True
        self.__ssl_verify = kwargs.get("ssl_verify", True)

        # get the auth_token
        self.__headers = _get_auth_token()
        self.__ccp_enabled = True if self.__headers else False

        # Validations
        arg_info_matrix = []
        arg_info_matrix.append(["host", self.__host, True, (str), True])
        arg_info_matrix.append(["username", self.__user, True, (str), True])
        arg_info_matrix.append(["password", self.__password, True, (str), True])
        arg_info_matrix.append(["database", self.__database, True, (str), True])
        arg_info_matrix.append(["ssl_verify", self.__ssl_verify, True, (bool)])


        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        # Triggering the 'connect' API
        data = {
                'database_name': self.__database,
                'hostname': self.__host
                }
        data = {k: v for k, v in data.items() if v is not None}

        # Form the header with username and password if it not ccp enabled tenant.
        if not self.__ccp_enabled and self.__user:
            credentials = f"{self.__user}:{self.__password}"
            # Encode the credentials string using Base64
            encoded_credentials = base64.b64encode(
                credentials.encode('utf-8')).decode('utf-8')
            # Form the Authorization header value
            self.__headers = {"Authorization": f"Basic {encoded_credentials}"}
            self.__ssl_verify = False
        # Call the connect API only when the tenant is ccp enabled or header is
        # formed using user and password.

        # This check is needed to that when the tenant is non-ccp enabled,
        # the call from __init__ does not fail
        if self.__ccp_enabled or self.__headers:
            connect_url = f"{self.__session_url}connect"

            http_params = {
                "url": connect_url,
                "method_type": HTTPRequest.POST,
                "headers": self.__get_header(),
                "json": data
            }

            if self.__ssl_verify is not None:
                http_params["verify"] = self.__ssl_verify

            response = UtilFuncs._http_request(**http_params)

            self.__session_id = response.cookies.get("session_id")
            self._process_vs_response(api_name="connect", response=response)

    def initialize(self, **kwargs):
        """
        DESCRIPTION:
            Initialize a new vector store if it does not exist, otherwise
            provide an instance of an existing vector store.
            This call enables / configures a particular vector store to be used.

        PARAMETERS:
            description:
                Optional Argument.
                Specifies the description of the vector store.
                Types: str

            database_name:
                Optional Argument.
                Specifies the database name of the table or view to be indexed
                for vector store.
                When "document_files" is passed, it refers to the database where
                the file content splits are stored.
                Note:
                    The vector store is also created in this database.
                Types: str

            object_name:
                Optional Argument.
                Specifies the table name/teradataml DataFrame to be indexed for
                vector store.
                Note:
                    * Only one table name/teradataml DataFrame can be specified.
                    * For data residing in multiple tables, view should be
                      created and view name/teradataml DataFrame over the view should be specified
                      here.
                Types: str, DataFrame

            key_columns:
                Optional Argument.
                Specifies the names of the key columns to be used for indexing.
                Types: str, list of str

            data_columns:
                Optional Argument.
                Specifies the names of the data columns to be used for indexing.
                Types: str, list of str

            vector_columns:
                Optional Argument.
                Specifies the names of the columns to be used for storing
                the embeddings.
                Default Value: vector_index
                Types: str, list of str

            chunk_size:
                Optional Argument.
                Specifies the size of each chunk when dividing document files
                into chunks.
                Default Value: 512
                Types: int

            optimized_chunking:
                Optional Argument.
                Whether an optimized splitting mechanism supplied by Teradata
                should be used. Applicable only for "document_files".
                The documents are parsed internally in an intelligent fashion
                based on file structure and chunks are dynamically created
                based on section layout.
                Note:
                    The "chunk_size" field is not applicable when
                    "optimized_chunking" is set to True.
                Default Value: True
                Types: bool

            header_height:
                Optional Argument.
                Specifies the height (in points) of the header section of a PDF
                document to be trimmed before processing the main content.
                This is useful for removing unwanted header information
                from each page of the PDF.
                Recommended value is 55.
                Default Value: 0
                Types: int

            footer_height:
                Optional Argument.
                Specifies the height (in points) of the footer section of a PDF
                document to be trimmed before processing the main content.
                This is useful for removing unwanted footer information from
                each page of the PDF.
                Recommended value is 55.
                Default Value: 0
                Types: int

            embeddings_model:
                Optional Argument.
                Specifies the embeddings model to be used for generating the
                embeddings.
                Permitted Values:
                    * amazon.titan-embed-text-v1
                    * amazon.titan-embed-image-v1
                    * amazon.titan-embed-text-v2:0
                    * text-embedding-ada-002
                    * text-embedding-3-small
                    * text-embedding-3-large
                Types: str

            embeddings_dims:
                Optional Argument.
                Specifies the number of dimensions to be used for generating the embeddings.
                The value depends on the "embeddings_model".
                Permitted Values:
                    * amazon.titan-embed-text-v1: 1536 only
                    * amazon.titan-embed-image-v1: [256, 384, 1024]
                    * amazon.titan-embed-text-v2:0: [256, 512, 1024]
                    * text-embedding-ada-002: 1536 only
                    * text-embedding-3-small: 1 <= dims <= 1536
                    * text-embedding-3-large: 1 <= dims <= 3072
                Default Value:
                    * amazon.titan-embed-text-v1: 1536
                    * amazon.titan-embed-image-v1: 1024
                    * amazon.titan-embed-text-v2:0: 1024
                    * text-embedding-ada-002: 1536
                    * text-embedding-3-small: 1536
                    * text-embedding-3-large: 3072
                Types: int

            initial_delay_ms:
                Optional Argument.
                Specifies the millisecond delay after each input table
                row is sent for embeddings.
                Default Value: 5000
                Types: int

            delay_max_retries:
                Optional Argument.
                Specifies the maximum number of attempts after a failed
                input table row embedding request.
                Default Value: 12
                Types: int

            delay_exp_base:
                Optional Argument.
                Specifies the exponential base of delay time increase.
                Default Value: 1
                Types: int

            delay_jitter:
                Optional Argument.
                Specifies whether to use random sum term in exponent.
                Default Value: False
                Types: bool

            metric:
                Optional Argument.
                Specifies the metric to be used for calculating the distance
                between the vectors.
                Permitted Values:
                    * EUCLIDEAN
                    * COSINE
                    * MANHATTAN
                    * DOTPRODUCT
                    * MINKOWSKI
                Default Value: EUCLIDEAN
                Types: str

            search_algorithm:
                Optional Argument.
                Specifies the algorithm to be used for searching the
                tables and views relevant to the question.
                Permitted Values: VECTORDISTANCE, KMEANS.
                Default Value: VECTORDISTANCE
                Types: str

            initial_centroids_method:
                Optional Argument.
                Specifies the algorithm to be used for initializing the
                centroids when Search Algorithm is KMEANS.
                Permitted Values: RANDOM, KMEANS++
                Default Value: RANDOM
                Types: str

            train_numcluster:
                Optional Argument.
                Specifies the Number of clusters to be trained when
                "search_algorithm" is KMEANS.
                Default Value: 3
                Types: int

            max_iternum:
                Optional Argument.
                Specifies the maximum number of iterations to be run during
                training when "search_algorithm" is KMEANS.
                Default Value: 10
                Types: int

            stop_threshold:
                Optional Argument.
                Specifies the threshold value at which training should be
                stopped when "search_algorithm" is KMEANS.
                Default Value: 0.0395
                Types: int

            seed:
                Optional Argument.
                Specifies the seed value to be used for random number
                generation when "search_algorithm" is KMEANS.
                Default Value: 0
                Types: int

            num_init:
                Optional Argument.
                Specifies the number of times the k-means algorithm should
                run with different initial centroid seeds.
                Default Value: 1
                Types: int

            top_k:
                Optional Argument.
                Specifies the number of top clusters to be considered while searching.
                Value should be between 1-100(both inclusive).
                Default Value: 10
                Types: int

            search_threshold:
                Optional Argument.
                Specifies the threshold value to consider for matching tables
                while searching.
                Types: float

            search_numcluster:
                Optional Argument.
                Specifies the number of clusters to be considered while
                searching when "search_algorithm" is KMEANS.
                Default Value: 3
                Types: int

            prompt:
                Optional Argument.
                Specifies the prompt to be used by language model
                to generate responses using top matches.
                Types: str

            chat_completion_model:
                Optional Argument.
                Specifies the name of the chat completion model to be used for
                generating text responses.
                Permitted Values:
                    * anthropic.claude-3-haiku-20240307-v1:0
                    * anthropic.claude-3-opus-20240229-v1:0
                    * anthropic.claude-3-sonnet-20240229-v1:0
                    * anthropic.claude-3-5-sonnet-20240620-v1:0
                Default Value: anthropic.claude-3-haiku-20240307-v1:0
                Types: str

            document_files:
                Optional Argument.
                Specifies the input dataset in document files format.
                It can be used to specify input documents in file format.
                The files are processed internally, converted to chunks and stored
                into a database table.
                Alternatively, users can choose to chunk their files themselves,
                store them into a database table, create a table and specify
                the details of that using "database_name", "object_name",
                "data_columns" where the file content splits are stored.
                Note:
                    * Only PDF format is currently supported.
                    * Multiple document files can be supplied.
                    * Fully qualified file name should be specified.
                Examples:
                    document_files=['file1.pdf','file2.pdf']
                Types: str, list

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore

            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            # Example 1: The following example initializes the Vector Store using
            #            data residing in table.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          )

            # Example 2: The following example initializes the Vector Store using
            #            data residing in files.

            # Forming the fully qualified path for SQL_Fundamentals.pdf and
            # InDb_Analytical_Functions.pdf
            import teradataml
            files= [os.path.join(os.path.dirname(teradataml.__file__), "data",
                                 "SQL_Fundamentals.pdf"),
                    os.path.join(os.path.dirname(teradataml.__file__), "data",
                                 "InDb_Analytical_Functions.pdf")]

            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          document_files=files
                          )

            # Example 3: Initialize an existing Vector Store.
            vs.initialize()

        """
        self.__set_vs_index_and_vs_parameters(**kwargs)
        # As the rest call accepts 0, 1 converting it.
        self._enable_logging = 0 if not self._enable_logging else 1
        initialize_url = f'{self.__vectorstore_url}initialize?vs_name={self.name}&log_level={self._enable_logging}'

        data = {}
        if self.__vs_parameters or self.__vs_index:
            data = {}
            if self.__vs_parameters:
                data['vs_parameters'] = json.dumps(self.__vs_parameters)
            if self.__vs_index:
                data['vs_index'] = json.dumps(self.__vs_index)

        http_params = {
            "url": initialize_url,
            "method_type": HTTPRequest.POST,
            "headers": self.__get_header(),
            "data": data,
            "files": self._document_files,
            "cookies": {'session_id': self.__session_id}

        }
        response = UtilFuncs._http_request(**http_params)
        self._process_vs_response("initialize", response)

    def create(self):
        """
        DESCRIPTION:
            Creates a new vector store by generating the embeddings using the
            configuration specified at the time of instantiation.
            Note:
                For "search_algorithm" KMEANS, index is also trained
                because of which, it may take longer to set up compared
                to vector distance.

        PARAMETERS:
            None

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore

            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            # Example 1: The following example creates the Vector Store using
            #            data residing in table..
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          )
            # Create the Vector Store.
            vs.create()

            # Example 2: The following example creates the Vector Store using
            #            data residing in files.

            # Forming the fully qualified path for SQL_Fundamentals.pdf and
            # InDb_Analytical_Functions.pdf
            files= [os.path.join(os.path.dirname(teradataml.__file__), "data",
                                 "SQL_Fundamentals.pdf"),
                    os.path.join(os.path.dirname(teradataml.__file__), "data",
                                 "InDb_Analytical_Functions.pdf")]

            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          document_files=files
                          )

            # Create the Vector Store.
            vs.create()
        """
        create_url = f'{self.__vectorstore_url}create'
        response = UtilFuncs._http_request(create_url, HTTPRequest.POST,
                                           cookies={'session_id': self.__session_id},
                                           headers=self.__headers)
        self._process_vs_response("create", response)

    def disconnect(self):
        """
        DESCRIPTION:
            Logout from session and cleanup resources.

        PARAMETERS:
            None

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore
            # Example 1: Disconnect from the database.
            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            # Initialize vector store.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          )

            # Disconnect from the database.
            vs.diconnect()
        """
        disconnect_url = f'{self.__session_url}disconnect'

        response = UtilFuncs._http_request(disconnect_url, HTTPRequest.POST,
                                           cookies={'session_id': self.__session_id},
                                           headers=self.__headers)
        self._process_vs_response("disconnect", response)

    def destroy(self):
        """
        DESCRIPTION:
            Destroy the vector store.

        PARAMETERS:
            None

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore

            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            # Example 1: The following example destroys the Vector Store created
            #            by using data residing in table.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          )

            # Create the Vector Store.
            vs.create()

            # Destroy the Vector Store.
            vs.destroy()

            # Example 2: The following example destroys the Vector Store
            #            created by using data residing in files.

            # Forming the fully qualified path for SQL_Fundamentals.pdf and
            # InDb_Analytical_Functions.pdf
            import teradataml
            files = [os.path.join(os.path.dirname(teradataml.__file__), "data",
                                 "SQL_Fundamentals.pdf"),
                    os.path.join(os.path.dirname(teradataml.__file__), "data",
                                 "InDb_Analytical_Functions.pdf")]

            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name= 'oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          document_files=files
                          )

            # Create the Vector Store.
            vs.create()

            # Destroy the Vector Store.
            vs.destroy()
        """
        destroy_url = f'{self.__vectorstore_url}destroy'
        response = UtilFuncs._http_request(destroy_url, HTTPRequest.POST,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id})
        self._process_vs_response("destroy", response)

    def update(self, **kwargs):
        """
        DESCRIPTION:
            Update an existing vector store with the specified parameters.
            Note:
                Currently, there is no support for updating a vector store when
                input contents are updated or new data files become available.
                In such cases, user will need to create a new vector store.

        PARAMETERS:
            embeddings_model:
                Optional Argument.
                Specifies the embeddings model to be used for generating the
                embeddings.
                Permitted Values: text-embedding-ada-002, text-embedding-3-small,
                                  text-embedding-3-large.
                Types: str

            embeddings_dims:
                Optional Argument.
                Specifies the number of dimensions to be used for generating the embeddings.
                The value depends on the "embeddings_model".
                Permitted Values:
                    * amazon.titan-embed-text-v1: 1536 only
                    * amazon.titan-embed-image-v1: [256, 384, 1024]
                    * amazon.titan-embed-text-v2:0: [256, 512, 1024]
                    * text-embedding-ada-002: 1536 only
                    * text-embedding-3-small: 1 <= dims <= 1536
                    * text-embedding-3-large: 1 <= dims <= 3072
                Types: int

            initial_delay_ms:
                Optional Argument.
                Specifies the millisecond delay after each input table
                row is sent for embeddings.
                Types: int

            delay_max_retries:
                Optional Argument.
                Specifies the maximum number of attempts after a failed
                input table row embedding request.
                Types: int

            delay_exp_base:
                Optional Argument.
                Specifies the exponential base of delay time increase.
                Types: int

            delay_jitter:
                Optional Argument.
                Specifies the random sum term in exponent.
                Types: bool

            metric:
                Optional Argument.
                Specifies the metric to be used for calculating the distance
                between the vectors.
                Permitted Values:
                    * EUCLIDEAN
                    * COSINE
                    * MANHATTAN
                    * DOTPRODUCT
                    * MINKOWSKI
                Types: str

            search_algorithm:
                Optional Argument.
                Specifies the algorithm to be used for searching the tables and
                views relevant to the question.
                Permitted Values: VECTORDISTANCE, KMEANS.
                Types: str

            initial_centroids_method:
                Optional Argument.
                Specifies the Algorithm to be used for initializing the
                centroids when Search Algorithm is KMEANS.
                Allowed values are RANDOM and KMEANS++
                Permitted Values: RANDOM, KMEANS++
                Types: str

            train_numcluster:
                Optional Argument.
                Specifies the Number of clusters to be trained when
                "search_algorithm" is KMEANS.
                Types: int

            max_iternum:
                Optional Argument.
                Specifies the maximum number of iterations to be run during
                training when "search_algorithm" is KMEANS.
                Types: int

            stop_threshold:
                Optional Argument.
                Specifies the threshold value at which training should be
                stopped when "search_algorithm" is KMEANS.
                Types: int

            seed:
                Optional Argument.
                Specifies the seed value to be used for random number
                generation when "search_algorithm" is KMEANS.
                Types: int

            num_init:
                Optional Argument.
                Specifies the number of times the k-means algorithm will
                be run with different initial centroid seeds.
                Types: int

            top_k:
                Optional Argument.
                Specifies the number of top clusters to be considered while searching.
                Types: int

            search_threshold:
                Optional Argument.
                Specifies the threshold value to consider matching tables/views
                while searching.
                Types: float

            search_numcluster:
                Optional Argument.
                Specifies the number of clusters to be considered while
                searching when "search_algorithm" is KMEANS.
                Types: int

            prompt:
                Optional Argument.
                Specifies the prompt to be used for generating answers.
                Types: str

            document_files:
                Optional Argument.
                Specifies the list of PDF files to be divided into chunks and
                used for document embedding.
                Types: tuple, list of tuple

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore

            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            # Initialize the Vector Store.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          )
            # Create the Vector Store.
            vs.create()

            # Example 1: Update the search_algorithm, search_threshold and
            #            description of the Vector Store.
            vs.update(search_algorithm='KMEANS',
                      search_threshold=0.6,
                      description='KMeans clustering method')
        """
        self.__set_vs_index_and_vs_parameters(**kwargs)
        update_url = f'{self.__vectorstore_url}update'
        response = UtilFuncs._http_request(update_url, HTTPRequest.POST, json=self.__vs_parameters,
                                           files=self._document_files,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id})
        self._process_vs_response("update", response)

    def authenticate(self, user_name=None, action=None, permission=None, **kwargs):
        """
        DESCRIPTION:
            Grant or revoke read/write permissions for a user on the vector store.
            Every database user is permitted to create vector store according to
            existing access grants on corresponding data.
            That user becomes the owner/admin of the vector store
            and is the only one with read/write access to the vector store.
            Note:
                * The methods create(), authenticate(), update(), and destroy() need write
                  permissions to the vector store.
                * vector store initialization and the methods similarity_search(),
                  prepare_response() and ask() need read permissions to the
                  vector store.

        PARAMETERS:
            user_name:
                Required Argument.
                Specifies a database user to authenticate.
                Types: str

            action:
                Optional Argument.
                Specifies the type of grant to be provided.
                Permitted Values: GRANT, REVOKE
                Default Value: GRANT
                Types: Enum

            permission:
                Optional Argument.
                Specifies the type of permission to be provided.
                Permitted Values: READ, WRITE
                Default Value: READ
                Types: Enum

        RETURNS:
            None

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore, Action, Permission

            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vec1")

            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1"
                          )
            # Create the Vector Store.
            vs.create()

            # Example 1: GRANT READ access for user 'test_user1' to Vector Store 'vec1'.
            vs.authenticate(user_name='test_user1', action=Action.GRANT, permission=Permission.READ)

        """
        ## Initializing vs_index params
        self._user_name = user_name
        self._action = action
        self._permission = permission

        # Validating vs_index
        arg_info_matrix = []
        arg_info_matrix.append(["user_name", self._user_name, False, (str), True])
        arg_info_matrix.append(["action", self._action, True, (action_enum), True])
        arg_info_matrix.append(["permission", self._permission, True, (permission_enum), True])

        _Validators._validate_missing_required_arguments(arg_info_matrix)

        # Explicitly checking action and permission enum types, as correct message is not displayed.
        if self._action is not None and not isinstance(self._action, action_enum):
            raise TypeError(Messages.get_message(MessageCodes.UNSUPPORTED_DATATYPE,
                                                 "action", "Action Enum. Use 'Action' enum."
                                                           " Check example"))

        if self._permission is not None and not isinstance(self._permission, permission_enum):
            raise TypeError(Messages.get_message(MessageCodes.UNSUPPORTED_DATATYPE,
                                                 "permission", "Permission Enum. Use "
                                                               "'Permission' enum."
                                                               " Check example"))

        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        authenticate_url = f"{self.__vectorstore_url}authenticate?user_name={self._user_name}" \
                           f"&action={self._action.value}&permission={self._permission.value}"
        response = UtilFuncs._http_request(authenticate_url, HTTPRequest.POST,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id})
        self._process_vs_response(api_name="authenticate", response=response)

    def similarity_search(self, question=None):
        """
        DESCRIPTION:
            Perform similarity search in the Vector Store for the input question.
            The algorithm specified in "search_algorithm" is used to perform
            the search against the vector store.
            The result contains "top_k" rows along with similarity score
            found by the "search_algorithm".

        PARAMETERS:
            question:
                Required Argument.
                Specifies a string of text for which similarity search
                needs to be performed.
                Types: str

        RETURNS:
            list

        RAISES:
            TeradataMlException

        EXAMPLES:
            from teradataml import VectorStore

            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vs")

            # Initialize the Vector Store.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1",
                          search_algorithm='VECTORDISTANCE',
                          top_k=10
                          )

            # Create the Vector Store.
            vs.create()

            # Example: Perform similarity search in the Vector Store for
            #          the input question.

            question = 'Are there any reviews about books?'
            response = vs.similarity_search(question=question)
            print(response)

        """
        # Initializing params
        self._question = question

        # Validating params
        arg_info_matrix = []
        arg_info_matrix.append(["question", self._question, False, (str), True])
        _Validators._validate_missing_required_arguments(arg_info_matrix)

        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        similarity_search_url = f'{self.__vectorstore_url}similarity-search?question={question}'
        response = UtilFuncs._http_request(similarity_search_url, HTTPRequest.POST,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id})
        return _SimilaritySearch(self._process_vs_response(api_name="similarity-search",
                                      response=response))

    def prepare_response(self, question=None, similarity_results=None, prompt=None):
        """
        DESCRIPTION:
            Prepare a natural language response to the user using the input
            question and similarity_results provided by similarity_search.
            The response is generated by a language model configured
            in the environment using a pre-configured prompt.
            An optional parameter prompt can be used to specify a customized
            prompt that replaces the internal prompt.

        PARAMETERS:
            question:
                Required Argument.
                Specifies a string of text for which similarity search
                needs to be performed.
                Types: str

            similarity_results:
                Required Argument.
                Specifies the similarity results obtained by similarity_search().
                Types: str

            prompt:
                Optional Argument.
                Specifies a customized prompt that replaces the internal prompt.
                Types: str

        RETURNS:
            HTTP Response json.

        RAISES:
            None

        EXAMPLES:
            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vs")

            # Initialize the Vector Store.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1",
                          search_algorithm='VECTORDISTANCE',
                          top_k = 10
                          )
            # Create the Vector Store.
            vs.create()

            # Perform similarity search in the Vector Store for
            # the input question.
            question = 'Are there any reviews about books?'
            response = vs.similarity_search(question=question)

            # Example 1: Prepare a natural language response to the user
            #            using the input question and similarity_results
            #            provided by similarity_search().

            question='Did any one feel the book is thin?'
            similar_objects_list = response['similar_objects_list']
            vs.prepare_response(question=question,
                                similarity_results=similar_objects_list)
        """
        # Initializing params
        self._question = question
        self._similarity_results = similarity_results
        self._prompt = prompt

        # Validating params
        arg_info_matrix = []
        arg_info_matrix.append(["question", self._question, False, (str), True])
        arg_info_matrix.append(["similarity_results", self._similarity_results, False, _SimilaritySearch, True])
        arg_info_matrix.append(["prompt", self._prompt, True, (str), True])
        _Validators._validate_missing_required_arguments(arg_info_matrix)

        # Explicitly checking similarity search API, as correct message is not displayed.
        if not isinstance(similarity_results, _SimilaritySearch):
            raise TypeError(Messages.get_message(MessageCodes.UNSUPPORTED_DATATYPE,
                                                 "similarity_results", "output of similarity_search()"))
        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        data = {
            'question': self._question,
            'similar_objects_list': self._similarity_results._json_obj,
            'prompt': self._prompt,
        }
        prepare_response_url = f'{self.__vectorstore_url}prepare-response'
        response = UtilFuncs._http_request(prepare_response_url, HTTPRequest.POST,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id},
                                           json=data)
        return self._process_vs_response(api_name="prepare_response", response=response)

    def ask(self, question=None, prompt=None):
        """
        DESCRIPTION:
            Perform similarity search in the vector store for
            the input question followed by preparing a natural
            language response to the user. This method combines
            the operation of similarity_search() and prepare_response()
            into one call for faster response time.

        PARAMETERS:
            question:
                Required Argument.
                Specifies a string of text for which similarity search
                needs to be performed.
                Types: str

            prompt:
                Optional Argument.
                Specifies a customized prompt that replaces the internal prompt.
                Types: str

        RETURNS:
            dict

        RAISES:
            None

        EXAMPLES:
            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vs")

            # Initialize the Vector Store.
            vs.initialize(object_name="amazon_reviews_25",
                          description="vector store testing",
                          database_name='oaf',
                          key_columns=['rev_id', 'aid'],
                          data_columns=['rev_text'],
                          vector_columns='VectorIndex',
                          embeddings_model="amazon.titan-embed-text-v1",
                          search_algorithm='VECTORDISTANCE',
                          top_k=10
                          )
            # Create the Vector Store.
            vs.create()

            custom_prompt = '''List good reviews about the books. Do not assume information.
                               Only provide information that is present in the data.
                               Format results like this:
                               Review ID:
                               Author ID:
                               Review:
                            '''
            # Example 1: Perform similarity search in the Vector Store for
            #            the input question followed by preparing a natural
            #            language response to the user.

            question = 'Are there any reviews saying that the books are inspiring?'
            response = vs.ask(question=question, prompt=custom_prompt)
            print(response)

        """
        # Initializing params
        self._question = question
        self._prompt = prompt

        # Validating params
        arg_info_matrix = []
        arg_info_matrix.append(["question", self._question, False, (str), True])
        arg_info_matrix.append(["prompt", self._prompt, True, (str), True])
        _Validators._validate_missing_required_arguments(arg_info_matrix)

        # Validate argument types.
        _Validators._validate_function_arguments(arg_info_matrix)

        data = {
            'question': self._question,
            'prompt': self._prompt,
        }
        ask_url = f'{self.__vectorstore_url}ask'
        response = UtilFuncs._http_request(ask_url, HTTPRequest.POST,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id},
                                           json=data)
        return self._process_vs_response(api_name="ask", response=response)

    def _process_vs_response(self, api_name, response, success_status_code=None):
        """
        DESCRIPTION:
            Function to process and validate the UES Response.

        PARAMETERS:
            api_name:
                Required Argument.
                Specifies the name of the Vector Store method.
                Types: str

            response:
                Required Argument.
                Specifies the response recieved from Vector Store service.
                Types: requests.Response

            success_status_code:
                Optional Argument.
                Specifies the expected success status code for the corresponding
                Vector Store service.
                Default Value: None
                Types: int

        RETURNS:
            Response object.

        RAISES:
            TeradataMlException.

        EXAMPLES:
                >>> _process_vs_response("create", resp)
        """
        try:
            data = response.json()
            # Success status code ranges between 200-300.
            if (success_status_code is None and 200 <= response.status_code < 300) or \
                    (success_status_code == response.status_code):
                if "message" in data:
                    print(data['message'])
                else:
                    return data
                return

            # teradataml API got an error response. Error response is expected as follows -
            # Success
            # Response:
            # {
            #     "message": "success string"
            # }
            # Failure
            # Response:
            # {
            #     "detail": "error message string"
            # }
            # Validation
            # Error:
            # {
            #     "detail": [
            #         {
            #             "loc": [
            #                 "string",
            #                 0
            #             ],
            #             "msg": "string",
            #             "type": "string"
            #         }
            #     ]
            # }
            # Extract the fields and raise error accordingly.
            if isinstance(data['detail'], str):
                error_description = data['detail']
            else:
                error_description = []
                for dict_ele in data['detail']:
                    error_msg = f"{dict_ele['msg']} for {dict_ele['loc'][1] if len(dict_ele['loc']) > 1 else dict_ele['loc'][0]}"
                    error_description.append(error_msg)
                error_description = ",".join(error_description)

            exception_message = "Request Failed - {}".format(error_description)

            error_msg = Messages.get_message(MessageCodes.FUNC_EXECUTION_FAILED,
                                             api_name,
                                             exception_message)
            raise TeradataMlException(error_msg, MessageCodes.FUNC_EXECUTION_FAILED)

        # teradataml API may not get a Json API response in some cases.
        # So, raise an error with the response received as it is.
        except JSONDecodeError:
            error_msg = Messages.get_message(MessageCodes.FUNC_EXECUTION_FAILED,
                                             api_name,
                                             response.text)
            raise TeradataMlException(error_msg, MessageCodes.FUNC_EXECUTION_FAILED)

    def health(self):
        """
        DESCRIPTION:
            Perform sanity check for the service.

        PARAMETERS:
            None

        RETURNS:
            None

        RAISES:
            None

        EXAMPLES:
            # Create an instance of the VectorStore class.
            vs = VectorStore(name="vs")
            # Example 1: Check the health of the service.
            vs.health()
        """
        health_url = f'{self.__base_url}health'
        response = UtilFuncs._http_request(health_url, HTTPRequest.GET, headers=self.__get_header())
        return pd.DataFrame([self._process_vs_response("health", response)])

    def status(self):
        """
        DESCRIPTION:
            Check the status of the below operations:
               * initialize
               * create
               * destroy
               * update

        PARAMETERS:
            None

        RETURNS:
            None

        RAISES:
            None

        EXAMPLES:
           # Create an instance of the VectorStore class.
           vs = VectorStore(name="vs")
           # Example: Check the status of initialize and create operations.

           # Initialize VectorStore.
           vs.initialize(object_name="amazon_reviews_25",
                      description="vector store testing",
                      database_name='oaf',
                      key_columns=['rev_id', 'aid'],
                      data_columns=['rev_text'],
                      vector_columns='VectorIndex',
                      embeddings_model="amazon.titan-embed-text-v1"
                      )
           # Check status.
           vs.status()

           # Create VectorStore.
           vs.create()

           # Check status.
           vs.status()
        """
        status_url = f'{self.__vectorstore_url}status'
        response = UtilFuncs._http_request(status_url, HTTPRequest.GET,
                                           headers=self.__get_header(),
                                           cookies={'session_id': self.__session_id})
        return pd.DataFrame([self._process_vs_response("status", response)])