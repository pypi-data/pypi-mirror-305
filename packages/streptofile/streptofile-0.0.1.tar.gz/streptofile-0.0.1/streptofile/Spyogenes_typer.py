# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_Spyogenes_analysis.ipynb.

# %% auto 0
__all__ = ['arguments_present_check', 'check_arguments', 'Spyogenes_analysis', 'Spyogenes_manager', 'print_fasta_from_dict',
           'single_test', 'single_test_input_folder', 'folder_test', 'folder_test_with_metadata', 'samplesheet_test',
           'cli']

# %% ../nbs/03_Spyogenes_analysis.ipynb 2
# That export there, it makes sure this code goes into the module.

# standard libs
import os
import re

# Common to template
# add into settings.ini, requirements, package name is python-dotenv, for conda build ensure `conda config --add channels conda-forge`
import dotenv  # for loading config from .env files, https://pypi.org/project/python-dotenv/
import envyaml  # Allows to loads env vars into a yaml file, https://github.com/thesimj/envyaml
import fastcore  # To add functionality related to nbdev development, https://github.com/fastai/fastcore/
from fastcore import (
    test,
)
from fastcore.script import (
    call_parse,
)  # for @call_parse, https://fastcore.fast.ai/script
import json  # for nicely printing json and yaml
from fastcore import test
from streptofile import (
    core,
    sample_manager,
    analysis_utility,
)
from fastcore.script import call_parse
from pathlib import Path  # to be able write :Path in cli function

# Project specific libraries
import pandas as pd
import numpy as np
import subprocess

# %% ../nbs/03_Spyogenes_analysis.ipynb 6
def arguments_present_check(input_config):
    # Check if an input-file is provided, either as argument or unit-test. If not, exit with error
    if (
        input_config["assembly_file"] is None
        and input_config["Illumina_read_files"] is None
        and input_config["Nanopore_read_file"] is None
        and input_config["samplesheet"] is None
        and input_config["input_folder"] is None
    ):
        print(
            f"Input data must be given in the form of sequence data (assembly_file, Illumina_read_files and/or Nanopore_read_files), an input_dir with sequencing data, or a metadatas tsv with paths to those files"
        )
        return False
    elif input_config["load_from_folder"] and input_config["input_folder"] is None:
        print(
            f"When running --load_from_folder an input directory must be provided with --input_folder"
        )
    elif input_config["load_from_samplesheet"] and (
        not input_config["samplesheet"] or input_config["samplesheet"] is None
    ):
        print(
            f"When running --load_from_samplesheet a samplesheet must be provided with --samplesheet"
        )
    else:
        return True

# %% ../nbs/03_Spyogenes_analysis.ipynb 8
def check_arguments(input, config_file):
    exit_code = 0
    error_messages = list()
    # If a config-file was provided, check that it exists. If not, exit directly.
    if config_file is not None:
        config_dir = os.path.abspath(config_file)
        isConfig = os.path.isfile(config_dir)
        if not isConfig:
            print("ERROR: The provided config-file doesnt exist: " + config_dir)
            exit()
    input_dir = os.path.abspath(input)
    isInput = os.path.isfile(input_dir)
    if not isInput:
        error_msg = "Your input log-file does not exist: " + input_dir
        error_messages.append(error_msg)
        exit_code = 1
    # Report errors and exit (if any)
    if exit_code == 1:
        print("Error: there were problems with the following script arguments:")
        for msg in error_messages:
            print(msg)
        exit()

# %% ../nbs/03_Spyogenes_analysis.ipynb 10
class Spyogenes_analysis(analysis_utility.analysis_utility):
    species = "Streptococcus pyogenes"

    def __init__(self, attributes, input_folder, output_folder, analysis_config):
        attributes = attributes.copy()
        analysis_config = analysis_config.copy()
        super().__init__(attributes, input_folder, output_folder, analysis_config)
        self.run_analyses(analysis_config)

    def run_analyses(self, analysis_config):
        self.sample_setup()
        analyses_to_run = analysis_config["analyses_to_run"]
        if "assembly_lineage_determination" in analyses_to_run:
            lineage_determination_config = analysis_config[
                "assembly_lineage_determination"
            ]
            self._assembly_lineage_determination_(lineage_determination_config)
        if "emm_typing" in analyses_to_run:
            emm_typing_config = analysis_config["emm_typing"]
            self._emm_typing_(emm_typing_config)
        if "resistance_gene_detection" in analyses_to_run:
            AMR_blast_config = analysis_config["resistance_gene_detection"]
            self._blast_presence_absence_(AMR_blast_config)
        if "virulence_gene_detection" in analyses_to_run:
            VFDB_blast_config = analysis_config["virulence_gene_detection"]
            VFDB_blast_config["results_format"] = "string"
            self._blast_presence_absence_(VFDB_blast_config)
        self.sample_cleanup()
        self.write_to_tsv()

    def load_emm_clusters(emm_cluster_file):
        emm_clusters = {}
        with open(emm_cluster_file) as f:
            for line in f:
                line = line.rstrip("\n").split(" ")
                for i in range(1, len(line)):
                    try:
                        emm_clusters[line[i]] += f",{line[0]}"
                    except KeyError:
                        emm_clusters[line[i]] = line[0]
        return emm_clusters

    def _emm_typing_(self, emm_typing_config, output_folder=False):
        analysis_alias = emm_typing_config["alias"]
        if self.assembly_file is None:
            self.logger.critical(
                f"Assembly file not provided or not found. Skipping analysis {analysis_alias}"
            )
            self.analysis_results[analysis_alias] = {analysis_alias: "NA"}
        else:
            output_folder = self.analysis_setup(analysis_alias, output_folder)
            emm_blast_output_file = os.path.join(output_folder, "blast.tsv")
            try:
                with open(emm_typing_config["emm_cluster_file"]) as f:
                    emm_clusters = {}
                    for line in f:
                        line = line.rstrip("\n").split()
                        for ele in line:
                            emm_clusters[ele] = line[0]
                self.logger.info(
                    f"Loaded EMM clusters from file {emm_typing_config['emm_cluster_file']}"
                )
            except Exception as e:
                self.logger.error(
                    f"Failed to parse cluster EMM cluster file, error: {e}"
                )
            cmd = f"blastn -query {emm_typing_config['emm_allele_file']} -subject {self.assembly_file} -qcov_hsp_perc 90 -out {emm_blast_output_file} -outfmt \"6 {emm_typing_config['blast_header']}\""
            if not os.path.exists(emm_blast_output_file):
                stdout, stderr = self.execute_cmd_and_log(cmd)
            blast_df = pd.read_csv(emm_blast_output_file, sep="\t", header=None)
            blast_df.columns = emm_typing_config["blast_header"].split(" ")
            blast_df["plen"] = blast_df["length"] / blast_df["qlen"] * 100
            blast_df["extended_sstart"] = np.where(
                blast_df["sstart"] < blast_df["send"],
                round((blast_df["sstart"] - blast_df["qstart"] + 1) / 100),
                round((blast_df["send"] - blast_df["qstart"] + 1) / 100),
            )
            blast_df_sorted = blast_df.sort_values(by=["bitscore"], ascending=False)
            emm_typing_results = {
                "EMM_type": "-",
                "EMM_cluster": "-",
                "ENN_type": "-",
                "ENN_cluster": "-",
                "MRP_type": "-",
                "MRP_cluster": "-",
            }
            unclassified_alleles = []
            for start_pos in set(blast_df_sorted["extended_sstart"]):
                allele_type = False
                df_filtered = blast_df.query("extended_sstart == @start_pos")
                df_filtered_dict = df_filtered.to_dict("records")
                for row in df_filtered_dict:
                    allele_name = row["qseqid"][3:]
                    if allele_name in emm_clusters:
                        cluster = emm_clusters[allele_name]
                        allele_type = cluster[:3]
                        emm_typing_results[f"{allele_type}_cluster"] = cluster
                        break
                    elif allele_name.split(".")[0] in emm_clusters:
                        cluster = emm_clusters[allele_name.split(".")[0]]
                        allele_type = cluster[:3]
                        emm_typing_results[f"{allele_type}_cluster"] = cluster
                        break
                if row["pident"] < 100:
                    allele_name = f"{allele_name}*"
                if row["plen"] < 100:
                    allele_name = f"{allele_name}?"
                if not allele_type:
                    unclassified_alleles.append(allele_name)
                emm_typing_results[f"{allele_type}_type"] = allele_name
            if unclassified_alleles:
                emm_typing_results["unclassified_emm_like_alleles"] = ",".join(
                    unclassified_alleles
                )
                if emm_typing_results["EMM_type"] == "-":
                    emm_typing_results["EMM_type"] = (
                        "/".join(unclassified_alleles) + "+"
                    )
            else:
                emm_typing_results["unclassified_emm_like_alleles"] = "-"
            self.analysis_results[analysis_alias] = emm_typing_results
            self.analysis_output_files[analysis_alias] = {
                "blast": emm_blast_output_file
            }
            self.analysis_cleanup(analysis_alias, emm_typing_config["files_to_clean"])


class Spyogenes_manager(analysis_utility.analysis_manager):

    def __init__(self, input_config, analysis_settings_config):
        # self.analysis_settings: dict = analysis_settings_config
        super().__init__(input_config, analysis_settings_config)
        self.write_to_tsv()

    ### Initialize Spyogenes_analysis and add class instance to list in Spyogenes_manager.samples
    def init_sample(self, attributes):
        try:
            output_folder = os.path.abspath(attributes["output_folder"])
        except KeyError:
            output_folder = os.path.join(
                self.base_output_folder, attributes["sample_name"]
            )
        sample = Spyogenes_analysis(
            attributes,
            self.base_input_folder,
            output_folder,
            self.analysis_settings_config,
        )
        return sample


def print_fasta_from_dict(fasta_dict, output_file):
    printlines = ""
    for header, sequence in fasta_dict.items():
        printlines += ">" + header + "\n" + sequence + "\n"
    o = open(output_file, "w")
    o.write(printlines)
    o.close()

# %% ../nbs/03_Spyogenes_analysis.ipynb 12
def single_test():
    config = core.get_config()
    example_sample = Spyogenes_analysis(
        {  # "sample_name":"GAS-2022-1029",
            "assembly_file": "examples/GAS-2022-1029.fasta",
            "Illumina_read_files": [
                "examples/GAS-2022-1029_S42_L555_R1_001.fastq.gz",
                "examples/GAS-2022-1029_S42_L555_R2_001.fastq.gz",
            ],
        },
        input_folder=False,
        output_folder="output/GAS-2022-1029",
        analysis_config=config["analysis_settings"]["Spyogenes"],
    )
    # assert(example_sample.sample_name == "GAS-2022-1029")
    assert len(example_sample.Illumina_read_files) == 2
    assert not example_sample.Nanopore_read_file
    assert example_sample.analysis_results["emm_typing"]["EMM_type"] == "1.0"
    assert (
        example_sample.analysis_results["assembly_lineage_determination"]["Lineage"]
        == "M1DK"
    )


def single_test_input_folder():
    config = core.get_config()
    example_sample = Spyogenes_analysis(
        {
            "sample_name": "GAS-2024-0773",
            "assembly_file": "GAS-2024-0773.fasta",
            "Illumina_read_files": "GAS-2024-0773_S35_L555_R1_001.fastq.gz,GAS-2024-0773_S35_L555_R2_001.fastq.gz",
        },
        input_folder="examples",
        output_folder="output/GAS-2024-0773",
        analysis_config=config["analysis_settings"]["Spyogenes"],
    )
    assert example_sample.sample_name == "GAS-2024-0773"
    assert len(example_sample.Illumina_read_files) == 2
    assert not example_sample.Nanopore_read_file
    assert example_sample.analysis_results["emm_typing"]["EMM_type"] == "4.0"
    assert example_sample.analysis_results["emm_typing"]["ENN_type"] == "203.3*"
    assert example_sample.analysis_results["emm_typing"]["MRP_type"] == "156.0"
    assert (
        example_sample.analysis_results["assembly_lineage_determination"]["Lineage"]
        == "-"
    )


def folder_test():
    config = core.get_config()
    input_config = config["input_manager"]
    input_config["load_from_folder"] = True
    input_config["input_folder"] = "examples/"
    # input_config["samplesheet"] = "samplesheet.tsv"
    input_config["output_folder"] = "output_from_folder/"
    input_config["analysis_config"] = config["analysis_settings"]["Spyogenes"]
    test = Spyogenes_manager(input_config, config["analysis_settings"]["Spyogenes"])


def folder_test_with_metadata():
    config = core.get_config()
    input_config = config["input_manager"]
    input_config["load_from_folder"] = True
    input_config["input_folder"] = "examples/"
    input_config["samplesheet"] = "examples/samplesheet.tsv"
    input_config["output_folder"] = "output_from_folder/"
    input_config["analysis_config"] = config["analysis_settings"]["Spyogenes"]
    test = Spyogenes_manager(input_config, config["analysis_settings"]["Spyogenes"])


def samplesheet_test():
    config = core.get_config()
    input_config = config["input_manager"]
    input_config["load_from_samplesheet"] = True
    input_config["samplesheet"] = "examples/samplesheet.tsv"
    input_config["output_folder"] = "output_from_samplesheet/"
    input_config["analysis_config"] = config["analysis_settings"]["Spyogenes"]
    test = Spyogenes_manager(input_config, config["analysis_settings"]["Spyogenes"])
    print(test.__dict__)
    for x in test:
        print(x.__dict__)

# %% ../nbs/03_Spyogenes_analysis.ipynb 19
@call_parse
def cli(
    # Definition of command-line arguments
    assembly_file: str = None,  # Path to genome assembly file in fasta format
    Illumina_read_files: str = None,  # Path to paired end read files, comma separated.
    Nanopore_read_file: str = None,  # Path to single end Nanopore read file
    samplesheet: str = None,  # Path to samplesheet containing metadata in tsv-format
    input_folder: str = None,  # Path to input folder containing assembly files, Illumina read files or Nanopore read files. Overwrites any provided assembly_file and read_file input
    output_folder: str = None,  # Path to output folder
    analyses_to_run: str = "all",  # Comma separated list of analyses to perform. F.ex. "emm_typing,virulence_gene_detection"
    keep_files: str = None,  # Intermediate outputs to keep. See readme for details on string format
    # load_from_folder: bool = False, # Flag to indicate
    load_from_samplesheet: bool = False,  # Run analyses on samples listed in provided samplesheet
    config_file: Path = None,  # Config-file containing all required arguments (required, unless using input arg)
    show_analyses: bool = False,  # Print available analyses and exit
) -> None:
    # Set env vars and get config variables
    config = core.get_config(config_file)
    input_config = config["input_manager"]
    analysis_config = config["analysis_settings"]["Spyogenes"]
    if show_analyses:
        analysis_utility.print_analysis_options(analysis_config)
    else:
        input_config, analysis_config = analysis_utility.update_cli_input_config(
            input_config,
            analysis_config,
            samplesheet,
            input_folder,
            assembly_file,
            Illumina_read_files,
            Nanopore_read_file,
            output_folder,
            load_from_samplesheet,
            analyses_to_run,
            keep_files,
        )
        # Check if any required arguments are missing
        if arguments_present_check(input_config):
            print("Running analyses")
            if input_folder is not None or load_from_samplesheet:
                Spyogenes_manager(input_config, analysis_config)
            else:
                sample_attributes = sample_manager.get_single_sample_attributes(
                    input_config
                )
                Spyogenes_analysis(
                    sample_attributes,
                    input_folder=False,
                    output_folder=output_folder,
                    analysis_config=analysis_config,
                )
        # Possible next: print some summary information to stdout about transfers found? Not sure if that is necessary in production.
        # Next: write function that adds data into transfer-db
