

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_ironcore_alloy_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_ironcore_alloy_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_ironcore_alloy_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("ironcore_alloy")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_ironcore_alloy_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_deterministic() != 31260:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_standard() != 34754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_standard_attached() != 30924:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_vector() != 4357:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt() != 54434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt_batch() != 11155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt() != 31005:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt_batch() != 61277:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_generate_query_field_values() != 23753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_get_in_rotation_prefix() != 56768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_log_security_event() != 4965:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_rotate_fields() != 24386:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_decrypt() != 21816:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_decrypt_batch() != 57915:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_encrypt() != 56371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_encrypt_batch() != 62755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_get_searchable_edek_prefix() != 59898:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_log_security_event() != 54395:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_rekey_documents() != 13045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt() != 50440:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt_batch() != 61792:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt() != 27038:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_batch() != 23000:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_with_existing_edek() != 45695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_with_existing_edek_batch() != 14562:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_log_security_event() != 17759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_rekey_edeks() != 6027:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt() != 28090:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt_batch() != 25989:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt() != 29775:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt_batch() != 54157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_generate_query_vectors() != 31047:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_get_in_rotation_prefix() != 42837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_log_security_event() != 30611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_rotate_vectors() != 34909:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_deterministic() != 49012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_standard() != 22382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_standard_attached() != 63835:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_vector() != 23926:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt() != 36698:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt_batch() != 45944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt() != 5735:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt_batch() != 4903:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_generate_query_field_values() != 26283:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_get_in_rotation_prefix() != 40425:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_rotate_fields() != 10582:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_decrypt() != 4421:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_decrypt_batch() != 59678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_encrypt() != 59863:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_encrypt_batch() != 37842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_get_searchable_edek_prefix() != 10418:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_rekey_documents() != 54647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt() != 55756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt_batch() != 33787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt() != 24146:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_batch() != 21644:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_with_existing_edek() != 49737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_with_existing_edek_batch() != 24863:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_rekey_edeks() != 34016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt() != 16592:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt_batch() != 25329:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt() != 4896:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt_batch() != 55344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_generate_query_vectors() != 24826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_get_in_rotation_prefix() != 7568:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_rotate_vectors() != 20548:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new() != 6129:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new_simple() != 62870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_rotatablesecret_new() != 42942:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_saasshield_new() != 45344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_saasshieldconfiguration_new() != 3963:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_secret_new() != 64375:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standalone_new() != 58630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standaloneconfiguration_new() != 42330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standalonesecret_new() != 43792:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standardsecrets_new() != 45358:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_vectorsecret_new() != 56868:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_alloymetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_alloymetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_alloymetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_alloymetadata.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new_simple.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_rotatablesecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_rotatablesecret.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_rotatablesecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_rotatablesecret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_rotatablesecret_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_rotatablesecret_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshield.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshield.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshield.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshield.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshield_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshield_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_deterministic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_deterministic.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard_attached.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard_attached.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_vector.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldconfiguration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldconfiguration.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldconfiguration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldconfiguration.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshieldconfiguration_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshieldconfiguration_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshielddeterministicclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshielddeterministicclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshielddeterministicclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshielddeterministicclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_generate_query_field_values.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_generate_query_field_values.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_get_in_rotation_prefix.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_log_security_event.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_log_security_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_rotate_fields.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_rotate_fields.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldstandardattachedclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldstandardattachedclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardattachedclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardattachedclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_get_searchable_edek_prefix.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_get_searchable_edek_prefix.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_log_security_event.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_log_security_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_rekey_documents.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_rekey_documents.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldstandardclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldstandardclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_with_existing_edek.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_with_existing_edek.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_with_existing_edek_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_with_existing_edek_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_log_security_event.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_log_security_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_rekey_edeks.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_rekey_edeks.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldvectorclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldvectorclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldvectorclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldvectorclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_generate_query_vectors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_generate_query_vectors.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_get_in_rotation_prefix.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_log_security_event.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_log_security_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_rotate_vectors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_rotate_vectors.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_secret.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_secret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_secret_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_secret_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalone.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalone.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalone.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalone.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalone_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalone_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_deterministic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_deterministic.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard_attached.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard_attached.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_vector.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standaloneconfiguration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standaloneconfiguration.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standaloneconfiguration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standaloneconfiguration.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standaloneconfiguration_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standaloneconfiguration_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonedeterministicclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonedeterministicclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonedeterministicclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonedeterministicclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_generate_query_field_values.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_generate_query_field_values.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_get_in_rotation_prefix.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_rotate_fields.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_rotate_fields.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonesecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonesecret.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonesecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonesecret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalonesecret_new.argtypes = (
    ctypes.c_int32,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalonesecret_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonestandardattachedclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonestandardattachedclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardattachedclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardattachedclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_get_searchable_edek_prefix.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_get_searchable_edek_prefix.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_rekey_documents.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_rekey_documents.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonestandardclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonestandardclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_with_existing_edek.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_with_existing_edek.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_with_existing_edek_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_with_existing_edek_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_rekey_edeks.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_rekey_edeks.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonevectorclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonevectorclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonevectorclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonevectorclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt_batch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt_batch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_generate_query_vectors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_generate_query_vectors.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_get_in_rotation_prefix.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_rotate_vectors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_rotate_vectors.restype = ctypes.c_uint64
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standardsecrets.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_standardsecrets.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standardsecrets.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standardsecrets.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standardsecrets_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standardsecrets_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_clone_vectorsecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_clone_vectorsecret.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_vectorsecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_vectorsecret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_vectorsecret_new.argtypes = (
    ctypes.c_float,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_vectorsecret_new.restype = ctypes.c_void_p
_UniffiLib.ffi_ironcore_alloy_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_free.restype = None
_UniffiLib.ffi_ironcore_alloy_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_pointer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_void.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_void.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_void.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_void.restype = None
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_deterministic.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_deterministic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_standard.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_standard.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_standard_attached.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_standard_attached.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_vector.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_generate_query_field_values.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_generate_query_field_values.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_log_security_event.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_log_security_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_rotate_fields.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_rotate_fields.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_get_searchable_edek_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_get_searchable_edek_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_log_security_event.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_log_security_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_rekey_documents.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardattachedclient_rekey_documents.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_with_existing_edek.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_with_existing_edek.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_with_existing_edek_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt_with_existing_edek_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_log_security_event.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_log_security_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_rekey_edeks.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_rekey_edeks.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_generate_query_vectors.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_generate_query_vectors.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_log_security_event.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_log_security_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_rotate_vectors.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_rotate_vectors.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_deterministic.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_deterministic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_standard.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_standard.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_standard_attached.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_standard_attached.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_vector.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_generate_query_field_values.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_generate_query_field_values.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_rotate_fields.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_rotate_fields.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_get_searchable_edek_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_get_searchable_edek_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_rekey_documents.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardattachedclient_rekey_documents.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_with_existing_edek.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_with_existing_edek.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_with_existing_edek_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt_with_existing_edek_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_rekey_edeks.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_rekey_edeks.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt_batch.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_generate_query_vectors.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_generate_query_vectors.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_rotate_vectors.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_rotate_vectors.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new_simple.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_rotatablesecret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_rotatablesecret_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshield_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshield_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshieldconfiguration_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshieldconfiguration_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_secret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_secret_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalone_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalone_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standaloneconfiguration_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standaloneconfiguration_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalonesecret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalonesecret_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standardsecrets_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standardsecrets_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_vectorsecret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_vectorsecret_new.restype = ctypes.c_uint16
_UniffiLib.ffi_ironcore_alloy_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_ironcore_alloy_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterFloat(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_float()

    @staticmethod
    def write(value, buf):
        buf.write_float(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class AlloyMetadataProtocol(typing.Protocol):
    """
    Holds metadata fields as part of an SDK call. Each encrypted value will have metadata that associates
    it to a tenant ID as well as optional fields for other arbitrary key/value pairs and a request ID to send to the Tenant Security Proxy.
    Only the tenant ID will be used in Standalone SDKs, which can be created easily with `new_simple()`.
    """

    pass


class AlloyMetadata:
    """
    Holds metadata fields as part of an SDK call. Each encrypted value will have metadata that associates
    it to a tenant ID as well as optional fields for other arbitrary key/value pairs and a request ID to send to the Tenant Security Proxy.
    Only the tenant ID will be used in Standalone SDKs, which can be created easily with `new_simple()`.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, tenant_id: "TenantId",requesting_user_or_service_id: "typing.Optional[str]",data_label: "typing.Optional[str]",source_ip: "typing.Optional[str]",object_id: "typing.Optional[str]",request_id: "typing.Optional[str]",other_data: "dict[str, str]"):
        """
        Constructor for AlloyMetadata which contains the tenant's ID and other metadata to send to the
        Tenant Security Proxy.

        # Arguments
        - `tenant_id`                     - Unique ID of tenant that is performing the operation.
        - `requesting_user_or_service_id` - Unique ID of user/service that is processing data. Must be non-empty.
        - `data_label`                    - Classification of data being processed.
        - `source_ip`                     - IP address of the initiator of this document request.
        - `object_id`                     - ID of the object/document being acted on in the host system.
        - `request_id`                    - Unique ID that ties host application request ID to tenant.
        - `other_data`                    - Additional String key/value pairs to add to metadata.
        """

        _UniffiConverterTypeTenantId.check_lower(tenant_id)
        
        _UniffiConverterOptionalString.check_lower(requesting_user_or_service_id)
        
        _UniffiConverterOptionalString.check_lower(data_label)
        
        _UniffiConverterOptionalString.check_lower(source_ip)
        
        _UniffiConverterOptionalString.check_lower(object_id)
        
        _UniffiConverterOptionalString.check_lower(request_id)
        
        _UniffiConverterMapStringString.check_lower(other_data)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new,
        _UniffiConverterTypeTenantId.lower(tenant_id),
        _UniffiConverterOptionalString.lower(requesting_user_or_service_id),
        _UniffiConverterOptionalString.lower(data_label),
        _UniffiConverterOptionalString.lower(source_ip),
        _UniffiConverterOptionalString.lower(object_id),
        _UniffiConverterOptionalString.lower(request_id),
        _UniffiConverterMapStringString.lower(other_data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_alloymetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_alloymetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_simple(cls, tenant_id: "TenantId"):
        """
        Simplified constructor for AlloyMetadata that only takes the tenant's ID and the
        ID of the user/service that is processing data.

        # Arguments
        - `tenant_id` - Unique ID of tenant that is performing the operation.
        """

        _UniffiConverterTypeTenantId.check_lower(tenant_id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new_simple,
        _UniffiConverterTypeTenantId.lower(tenant_id))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeAlloyMetadata:

    @staticmethod
    def lift(value: int):
        return AlloyMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: AlloyMetadata):
        if not isinstance(value, AlloyMetadata):
            raise TypeError("Expected AlloyMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AlloyMetadataProtocol):
        if not isinstance(value, AlloyMetadata):
            raise TypeError("Expected AlloyMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AlloyMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RotatableSecretProtocol(typing.Protocol):
    """
    A single secret that allows for rotation within a secret path.
    Used for Deterministic and Vector operations.
    """

    pass


class RotatableSecret:
    """
    A single secret that allows for rotation within a secret path.
    Used for Deterministic and Vector operations.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, current_secret: "typing.Optional[StandaloneSecret]",in_rotation_secret: "typing.Optional[StandaloneSecret]"):
        """
        Create a rotating secret. This will error if both secrets are unset. If no secret for a path is desired, leave
        that path out of the configuration entirely instead.
        """

        _UniffiConverterOptionalTypeStandaloneSecret.check_lower(current_secret)
        
        _UniffiConverterOptionalTypeStandaloneSecret.check_lower(in_rotation_secret)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_rotatablesecret_new,
        _UniffiConverterOptionalTypeStandaloneSecret.lower(current_secret),
        _UniffiConverterOptionalTypeStandaloneSecret.lower(in_rotation_secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_rotatablesecret, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_rotatablesecret, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeRotatableSecret:

    @staticmethod
    def lift(value: int):
        return RotatableSecret._make_instance_(value)

    @staticmethod
    def check_lower(value: RotatableSecret):
        if not isinstance(value, RotatableSecret):
            raise TypeError("Expected RotatableSecret instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RotatableSecretProtocol):
        if not isinstance(value, RotatableSecret):
            raise TypeError("Expected RotatableSecret instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RotatableSecretProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SaasShieldProtocol(typing.Protocol):
    def deterministic(self, ):
        raise NotImplementedError
    def standard(self, ):
        raise NotImplementedError
    def standard_attached(self, ):
        raise NotImplementedError
    def vector(self, ):
        raise NotImplementedError


class SaasShield:
    _pointer: ctypes.c_void_p
    def __init__(self, config: "SaasShieldConfiguration"):
        _UniffiConverterTypeSaasShieldConfiguration.check_lower(config)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshield_new,
        _UniffiConverterTypeSaasShieldConfiguration.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshield, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshield, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def deterministic(self, ) -> "SaasShieldDeterministicClient":
        return _UniffiConverterTypeSaasShieldDeterministicClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_deterministic,self._uniffi_clone_pointer(),)
        )





    def standard(self, ) -> "SaasShieldStandardClient":
        return _UniffiConverterTypeSaasShieldStandardClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard,self._uniffi_clone_pointer(),)
        )





    def standard_attached(self, ) -> "SaasShieldStandardAttachedClient":
        return _UniffiConverterTypeSaasShieldStandardAttachedClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard_attached,self._uniffi_clone_pointer(),)
        )





    def vector(self, ) -> "SaasShieldVectorClient":
        return _UniffiConverterTypeSaasShieldVectorClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_vector,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSaasShield:

    @staticmethod
    def lift(value: int):
        return SaasShield._make_instance_(value)

    @staticmethod
    def check_lower(value: SaasShield):
        if not isinstance(value, SaasShield):
            raise TypeError("Expected SaasShield instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaasShieldProtocol):
        if not isinstance(value, SaasShield):
            raise TypeError("Expected SaasShield instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaasShieldProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SaasShieldConfigurationProtocol(typing.Protocol):
    """
    Configuration for the SaaS Shield SDKs. Sets the TSP domain/URI and API key to be used for SaaS Shield operations.
    """

    pass


class SaasShieldConfiguration:
    """
    Configuration for the SaaS Shield SDKs. Sets the TSP domain/URI and API key to be used for SaaS Shield operations.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, tsp_uri: "str",api_key: "str",accept_invalid_certs: "bool",approximation_factor: "typing.Optional[float]"):
        _UniffiConverterString.check_lower(tsp_uri)
        
        _UniffiConverterString.check_lower(api_key)
        
        _UniffiConverterBool.check_lower(accept_invalid_certs)
        
        _UniffiConverterOptionalFloat.check_lower(approximation_factor)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshieldconfiguration_new,
        _UniffiConverterString.lower(tsp_uri),
        _UniffiConverterString.lower(api_key),
        _UniffiConverterBool.lower(accept_invalid_certs),
        _UniffiConverterOptionalFloat.lower(approximation_factor))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldconfiguration, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldconfiguration, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeSaasShieldConfiguration:

    @staticmethod
    def lift(value: int):
        return SaasShieldConfiguration._make_instance_(value)

    @staticmethod
    def check_lower(value: SaasShieldConfiguration):
        if not isinstance(value, SaasShieldConfiguration):
            raise TypeError("Expected SaasShieldConfiguration instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaasShieldConfigurationProtocol):
        if not isinstance(value, SaasShieldConfiguration):
            raise TypeError("Expected SaasShieldConfiguration instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaasShieldConfigurationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SaasShieldDeterministicClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_field: "EncryptedField",metadata: "AlloyMetadata"):
        """
        Decrypt a field that was deterministically encrypted with the provided metadata.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata"):
        """
        Decrypt each of the fields that were deterministically encrypted with the provided metadata.
        Note that because the metadata is shared between the fields, they all must correspond to the
        same tenant ID.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_field: "PlaintextField",metadata: "AlloyMetadata"):
        """
        Encrypt a field with the provided metadata.
        Because the field is encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_fields: "PlaintextFields",metadata: "AlloyMetadata"):
        """
        Deterministically encrypt the provided fields with the provided metadata.
        Because the fields are encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        raise NotImplementedError
    def generate_query_field_values(self, fields_to_query: "PlaintextFields",metadata: "AlloyMetadata"):
        """
        Encrypt each plaintext field with any Current and InRotation keys for the provided secret path.
        The resulting encrypted fields should be used in tandem when querying the data store.
        """

        raise NotImplementedError
    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        """
        Generate a prefix that could used to search a data store for fields encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        """

        raise NotImplementedError
    def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]"):
        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        raise NotImplementedError
    def rotate_fields(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Re-encrypt already encrypted fields with the Current key for the provided tenant. The `metadata` passed
        must contain the tenant ID that the fields were originally encrypted to. If `new_tenant_id` is empty,
        the fields will simply be encrypted with the same tenant's current secret.
        """

        raise NotImplementedError


class SaasShieldDeterministicClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshielddeterministicclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshielddeterministicclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_field: "EncryptedField",metadata: "AlloyMetadata") -> "PlaintextField":
        """
        Decrypt a field that was deterministically encrypted with the provided metadata.
        """

        _UniffiConverterTypeEncryptedField.check_lower(encrypted_field)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedField.lower(encrypted_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextField.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata") -> "DeterministicDecryptBatchResult":
        """
        Decrypt each of the fields that were deterministically encrypted with the provided metadata.
        Note that because the metadata is shared between the fields, they all must correspond to the
        same tenant ID.
        """

        _UniffiConverterTypeEncryptedFields.check_lower(encrypted_fields)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedFields.lower(encrypted_fields),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDeterministicDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_field: "PlaintextField",metadata: "AlloyMetadata") -> "EncryptedField":
        """
        Encrypt a field with the provided metadata.
        Because the field is encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        _UniffiConverterTypePlaintextField.check_lower(plaintext_field)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextField.lower(plaintext_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedField.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_fields: "PlaintextFields",metadata: "AlloyMetadata") -> "DeterministicEncryptBatchResult":
        """
        Deterministically encrypt the provided fields with the provided metadata.
        Because the fields are encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        _UniffiConverterTypePlaintextFields.check_lower(plaintext_fields)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextFields.lower(plaintext_fields),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDeterministicEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def generate_query_field_values(self, fields_to_query: "PlaintextFields",metadata: "AlloyMetadata") -> "GenerateFieldQueryResult":
        """
        Encrypt each plaintext field with any Current and InRotation keys for the provided secret path.
        The resulting encrypted fields should be used in tandem when querying the data store.
        """

        _UniffiConverterTypePlaintextFields.check_lower(fields_to_query)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_generate_query_field_values(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextFields.lower(fields_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGenerateFieldQueryResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata") -> "bytes":
        """
        Generate a prefix that could used to search a data store for fields encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        """

        _UniffiConverterTypeSecretPath.check_lower(secret_path)
        
        _UniffiConverterTypeDerivationPath.check_lower(derivation_path)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_get_in_rotation_prefix(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]") -> None:

        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        _UniffiConverterTypeSecurityEvent.check_lower(event)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalInt64.check_lower(event_time_millis)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_log_security_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecurityEvent.lower(event),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalInt64.lower(event_time_millis)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rotate_fields(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "DeterministicRotateResult":
        """
        Re-encrypt already encrypted fields with the Current key for the provided tenant. The `metadata` passed
        must contain the tenant ID that the fields were originally encrypted to. If `new_tenant_id` is empty,
        the fields will simply be encrypted with the same tenant's current secret.
        """

        _UniffiConverterTypeEncryptedFields.check_lower(encrypted_fields)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_rotate_fields(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedFields.lower(encrypted_fields),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDeterministicRotateResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeSaasShieldDeterministicClient:

    @staticmethod
    def lift(value: int):
        return SaasShieldDeterministicClient._make_instance_(value)

    @staticmethod
    def check_lower(value: SaasShieldDeterministicClient):
        if not isinstance(value, SaasShieldDeterministicClient):
            raise TypeError("Expected SaasShieldDeterministicClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaasShieldDeterministicClientProtocol):
        if not isinstance(value, SaasShieldDeterministicClient):
            raise TypeError("Expected SaasShieldDeterministicClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaasShieldDeterministicClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SaasShieldStandardAttachedClientProtocol(typing.Protocol):
    def decrypt(self, attached_document: "EncryptedAttachedDocument",metadata: "AlloyMetadata"):
        """
        Decrypt a document that was encrypted with the provided metadata.
        The document must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata"):
        """
        Decrypt multiple documents that were encrypted with the provided metadata.
        The documents must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_document: "PlaintextAttachedDocument",metadata: "AlloyMetadata"):
        """
        Encrypt a document with the provided metadata.
        A DEK (document encryption key) will be generated and encrypted using a derived key.
        The result is a single blob of bytes with the edek put on the front of it.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_documents: "PlaintextAttachedDocuments",metadata: "AlloyMetadata"):
        """
        Encrypt multiple documents with the provided metadata.
        A DEK (document encryption key) will be generated for each document and encrypted using a derived key.
        """

        raise NotImplementedError
    def get_searchable_edek_prefix(self, id: "int"):
        """
        Generate a prefix that could used to search a data store for documents encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        Note that this will not work for matching values that don't use our key_id_header format, such as cloaked search.
        """

        raise NotImplementedError
    def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]"):
        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        raise NotImplementedError
    def rekey_documents(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Decrypt the provided documents and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the documents will be encrypted to the original tenant.
        """

        raise NotImplementedError


class SaasShieldStandardAttachedClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardattachedclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldstandardattachedclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, attached_document: "EncryptedAttachedDocument",metadata: "AlloyMetadata") -> "PlaintextAttachedDocument":
        """
        Decrypt a document that was encrypted with the provided metadata.
        The document must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        _UniffiConverterTypeEncryptedAttachedDocument.check_lower(attached_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedAttachedDocument.lower(attached_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextAttachedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata") -> "StandardAttachedDecryptBatchResult":
        """
        Decrypt multiple documents that were encrypted with the provided metadata.
        The documents must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        _UniffiConverterTypeEncryptedAttachedDocuments.check_lower(encrypted_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedAttachedDocuments.lower(encrypted_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardAttachedDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_document: "PlaintextAttachedDocument",metadata: "AlloyMetadata") -> "EncryptedAttachedDocument":
        """
        Encrypt a document with the provided metadata.
        A DEK (document encryption key) will be generated and encrypted using a derived key.
        The result is a single blob of bytes with the edek put on the front of it.
        """

        _UniffiConverterTypePlaintextAttachedDocument.check_lower(plaintext_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextAttachedDocument.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedAttachedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_documents: "PlaintextAttachedDocuments",metadata: "AlloyMetadata") -> "StandardAttachedEncryptBatchResult":
        """
        Encrypt multiple documents with the provided metadata.
        A DEK (document encryption key) will be generated for each document and encrypted using a derived key.
        """

        _UniffiConverterTypePlaintextAttachedDocuments.check_lower(plaintext_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextAttachedDocuments.lower(plaintext_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardAttachedEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )




    def get_searchable_edek_prefix(self, id: "int") -> "bytes":
        """
        Generate a prefix that could used to search a data store for documents encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        Note that this will not work for matching values that don't use our key_id_header format, such as cloaked search.
        """

        _UniffiConverterInt32.check_lower(id)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_get_searchable_edek_prefix,self._uniffi_clone_pointer(),
        _UniffiConverterInt32.lower(id))
        )




    async def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]") -> None:

        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        _UniffiConverterTypeSecurityEvent.check_lower(event)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalInt64.check_lower(event_time_millis)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_log_security_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecurityEvent.lower(event),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalInt64.lower(event_time_millis)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rekey_documents(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "RekeyAttachedDocumentsBatchResult":
        """
        Decrypt the provided documents and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the documents will be encrypted to the original tenant.
        """

        _UniffiConverterTypeEncryptedAttachedDocuments.check_lower(encrypted_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardattachedclient_rekey_documents(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedAttachedDocuments.lower(encrypted_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRekeyAttachedDocumentsBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeSaasShieldStandardAttachedClient:

    @staticmethod
    def lift(value: int):
        return SaasShieldStandardAttachedClient._make_instance_(value)

    @staticmethod
    def check_lower(value: SaasShieldStandardAttachedClient):
        if not isinstance(value, SaasShieldStandardAttachedClient):
            raise TypeError("Expected SaasShieldStandardAttachedClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaasShieldStandardAttachedClientProtocol):
        if not isinstance(value, SaasShieldStandardAttachedClient):
            raise TypeError("Expected SaasShieldStandardAttachedClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaasShieldStandardAttachedClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SaasShieldStandardClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_document: "EncryptedDocument",metadata: "AlloyMetadata"):
        """
        Decrypt a document that was encrypted with the provided metadata. The document must have been encrypted with one
        of the `StandardDocumentOps.encrypt` functions. The result contains a map from field identifiers to decrypted
        bytes.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_documents: "EncryptedDocuments",metadata: "AlloyMetadata"):
        """
        Decrypt each of the provided documents with the provided metadata.
        Note that because the metadata is shared between the documents, they all must correspond to the
        same tenant ID.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_document: "PlaintextDocument",metadata: "AlloyMetadata"):
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        A DEK (document encryption key) will be generated and encrypted using a derived key, then each field of the
        document will be encrypted separately using a random IV and this single generated DEK.
        The result contains a map from field identifiers to encrypted bytes as well as the EDEK (encrypted document
        encryption key) used for encryption.
        The document is encrypted differently with each call, so the result is not suited for exact matches or indexing.
        For the same reason however the strongest protection of the document is provided by this method.
        To support these uses, see the `DeterministicFieldOps.encrypt` function.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_documents: "PlaintextDocuments",metadata: "AlloyMetadata"):
        """
        Encrypt each of the provided documents with the provided metadata.
        Note that because only a single metadata value is passed, each document will be encrypted to the same tenant.
        """

        raise NotImplementedError
    def encrypt_with_existing_edek(self, plaintext_document: "PlaintextDocumentWithEdek",metadata: "AlloyMetadata"):
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        The provided EDEK will be decrypted and used to encrypt each field. This is useful when updating some fields
        of the document.
        """

        raise NotImplementedError
    def encrypt_with_existing_edek_batch(self, plaintext_documents: "PlaintextDocumentsWithEdeks",metadata: "AlloyMetadata"):
        """
        Encrypt multiple documents with the provided metadata.
        The provided EDEKs will be decrypted and used to encrypt each corresponding document's fields.
        This is useful when updating some fields of the document.
        """

        raise NotImplementedError
    def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]"):
        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        raise NotImplementedError
    def rekey_edeks(self, edeks: "dict[DocumentId, EdekWithKeyIdHeader]",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Decrypt the provided EDEKs and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the EDEK will be encrypted to the original tenant. Because the underlying DEK does not change, a document
        associated with the old EDEK can be decrypted with the new EDEK without changing its document data.
        """

        raise NotImplementedError


class SaasShieldStandardClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldstandardclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_document: "EncryptedDocument",metadata: "AlloyMetadata") -> "PlaintextDocument":
        """
        Decrypt a document that was encrypted with the provided metadata. The document must have been encrypted with one
        of the `StandardDocumentOps.encrypt` functions. The result contains a map from field identifiers to decrypted
        bytes.
        """

        _UniffiConverterTypeEncryptedDocument.check_lower(encrypted_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedDocument.lower(encrypted_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_documents: "EncryptedDocuments",metadata: "AlloyMetadata") -> "StandardDecryptBatchResult":
        """
        Decrypt each of the provided documents with the provided metadata.
        Note that because the metadata is shared between the documents, they all must correspond to the
        same tenant ID.
        """

        _UniffiConverterTypeEncryptedDocuments.check_lower(encrypted_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedDocuments.lower(encrypted_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_document: "PlaintextDocument",metadata: "AlloyMetadata") -> "EncryptedDocument":
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        A DEK (document encryption key) will be generated and encrypted using a derived key, then each field of the
        document will be encrypted separately using a random IV and this single generated DEK.
        The result contains a map from field identifiers to encrypted bytes as well as the EDEK (encrypted document
        encryption key) used for encryption.
        The document is encrypted differently with each call, so the result is not suited for exact matches or indexing.
        For the same reason however the strongest protection of the document is provided by this method.
        To support these uses, see the `DeterministicFieldOps.encrypt` function.
        """

        _UniffiConverterTypePlaintextDocument.check_lower(plaintext_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocument.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_documents: "PlaintextDocuments",metadata: "AlloyMetadata") -> "StandardEncryptBatchResult":
        """
        Encrypt each of the provided documents with the provided metadata.
        Note that because only a single metadata value is passed, each document will be encrypted to the same tenant.
        """

        _UniffiConverterTypePlaintextDocuments.check_lower(plaintext_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocuments.lower(plaintext_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_with_existing_edek(self, plaintext_document: "PlaintextDocumentWithEdek",metadata: "AlloyMetadata") -> "EncryptedDocument":
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        The provided EDEK will be decrypted and used to encrypt each field. This is useful when updating some fields
        of the document.
        """

        _UniffiConverterTypePlaintextDocumentWithEdek.check_lower(plaintext_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_with_existing_edek(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocumentWithEdek.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_with_existing_edek_batch(self, plaintext_documents: "PlaintextDocumentsWithEdeks",metadata: "AlloyMetadata") -> "StandardEncryptBatchResult":
        """
        Encrypt multiple documents with the provided metadata.
        The provided EDEKs will be decrypted and used to encrypt each corresponding document's fields.
        This is useful when updating some fields of the document.
        """

        _UniffiConverterTypePlaintextDocumentsWithEdeks.check_lower(plaintext_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt_with_existing_edek_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocumentsWithEdeks.lower(plaintext_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]") -> None:

        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        _UniffiConverterTypeSecurityEvent.check_lower(event)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalInt64.check_lower(event_time_millis)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_log_security_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecurityEvent.lower(event),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalInt64.lower(event_time_millis)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rekey_edeks(self, edeks: "dict[DocumentId, EdekWithKeyIdHeader]",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "RekeyEdeksBatchResult":
        """
        Decrypt the provided EDEKs and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the EDEK will be encrypted to the original tenant. Because the underlying DEK does not change, a document
        associated with the old EDEK can be decrypted with the new EDEK without changing its document data.
        """

        _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.check_lower(edeks)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_rekey_edeks(
                self._uniffi_clone_pointer(), 
        _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.lower(edeks),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRekeyEdeksBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeSaasShieldStandardClient:

    @staticmethod
    def lift(value: int):
        return SaasShieldStandardClient._make_instance_(value)

    @staticmethod
    def check_lower(value: SaasShieldStandardClient):
        if not isinstance(value, SaasShieldStandardClient):
            raise TypeError("Expected SaasShieldStandardClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaasShieldStandardClientProtocol):
        if not isinstance(value, SaasShieldStandardClient):
            raise TypeError("Expected SaasShieldStandardClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaasShieldStandardClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SaasShieldVectorClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_vector: "EncryptedVector",metadata: "AlloyMetadata"):
        """
        Decrypt a vector embedding that was encrypted with the provided metadata. The values of the embedding will
        be unshuffled to their original positions during decryption.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata"):
        """
        Decrypt multiple vector embeddings that were encrypted with the provided metadata. The values of the embeddings
        will be unshuffled to their original positions during decryption.
        Note that because the metadata is shared between the vectors, they all must correspond to the
        same tenant ID.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_vector: "PlaintextVector",metadata: "AlloyMetadata"):
        """
        Encrypt a vector embedding with the provided metadata. The provided embedding is assumed to be normalized
        and its values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embedding.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_vectors: "PlaintextVectors",metadata: "AlloyMetadata"):
        """
        Encrypt multiple vector embeddings with the provided metadata. The provided embeddings are assumed to be normalized
        and their values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embeddings.
        """

        raise NotImplementedError
    def generate_query_vectors(self, vectors_to_query: "PlaintextVectors",metadata: "AlloyMetadata"):
        """
        Encrypt each plaintext vector with any Current and InRotation keys for the provided secret path.
        The resulting encrypted vectors should be used in tandem when querying the vector database.
        """

        raise NotImplementedError
    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        """
        Get the byte prefix for the InRotation secret corresponding to this secret_path/derivation_path.
        Note that if you use z85 or ascii85 encoding, the result of this function should be passed to `base85_compat_prefix_bytes`
        before searching your datastore.
        """

        raise NotImplementedError
    def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]"):
        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        raise NotImplementedError
    def rotate_vectors(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        raise NotImplementedError


class SaasShieldVectorClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldvectorclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_saasshieldvectorclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_vector: "EncryptedVector",metadata: "AlloyMetadata") -> "PlaintextVector":
        """
        Decrypt a vector embedding that was encrypted with the provided metadata. The values of the embedding will
        be unshuffled to their original positions during decryption.
        """

        _UniffiConverterTypeEncryptedVector.check_lower(encrypted_vector)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedVector.lower(encrypted_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextVector.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata") -> "VectorDecryptBatchResult":
        """
        Decrypt multiple vector embeddings that were encrypted with the provided metadata. The values of the embeddings
        will be unshuffled to their original positions during decryption.
        Note that because the metadata is shared between the vectors, they all must correspond to the
        same tenant ID.
        """

        _UniffiConverterTypeEncryptedVectors.check_lower(encrypted_vectors)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedVectors.lower(encrypted_vectors),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVectorDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_vector: "PlaintextVector",metadata: "AlloyMetadata") -> "EncryptedVector":
        """
        Encrypt a vector embedding with the provided metadata. The provided embedding is assumed to be normalized
        and its values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embedding.
        """

        _UniffiConverterTypePlaintextVector.check_lower(plaintext_vector)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextVector.lower(plaintext_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedVector.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_vectors: "PlaintextVectors",metadata: "AlloyMetadata") -> "VectorEncryptBatchResult":
        """
        Encrypt multiple vector embeddings with the provided metadata. The provided embeddings are assumed to be normalized
        and their values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embeddings.
        """

        _UniffiConverterTypePlaintextVectors.check_lower(plaintext_vectors)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextVectors.lower(plaintext_vectors),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVectorEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def generate_query_vectors(self, vectors_to_query: "PlaintextVectors",metadata: "AlloyMetadata") -> "GenerateVectorQueryResult":
        """
        Encrypt each plaintext vector with any Current and InRotation keys for the provided secret path.
        The resulting encrypted vectors should be used in tandem when querying the vector database.
        """

        _UniffiConverterTypePlaintextVectors.check_lower(vectors_to_query)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_generate_query_vectors(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextVectors.lower(vectors_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGenerateVectorQueryResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata") -> "bytes":
        """
        Get the byte prefix for the InRotation secret corresponding to this secret_path/derivation_path.
        Note that if you use z85 or ascii85 encoding, the result of this function should be passed to `base85_compat_prefix_bytes`
        before searching your datastore.
        """

        _UniffiConverterTypeSecretPath.check_lower(secret_path)
        
        _UniffiConverterTypeDerivationPath.check_lower(derivation_path)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_get_in_rotation_prefix(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def log_security_event(self, event: "SecurityEvent",metadata: "AlloyMetadata",event_time_millis: "typing.Optional[int]") -> None:

        """
        Log the security event `event` to the tenant's log sink.
        If the event time is unspecified the current time will be used.
        """

        _UniffiConverterTypeSecurityEvent.check_lower(event)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalInt64.check_lower(event_time_millis)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_log_security_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecurityEvent.lower(event),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalInt64.lower(event_time_millis)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_void,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rotate_vectors(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "VectorRotateResult":
        _UniffiConverterTypeEncryptedVectors.check_lower(encrypted_vectors)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_rotate_vectors(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedVectors.lower(encrypted_vectors),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVectorRotateResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeSaasShieldVectorClient:

    @staticmethod
    def lift(value: int):
        return SaasShieldVectorClient._make_instance_(value)

    @staticmethod
    def check_lower(value: SaasShieldVectorClient):
        if not isinstance(value, SaasShieldVectorClient):
            raise TypeError("Expected SaasShieldVectorClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SaasShieldVectorClientProtocol):
        if not isinstance(value, SaasShieldVectorClient):
            raise TypeError("Expected SaasShieldVectorClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SaasShieldVectorClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SecretProtocol(typing.Protocol):
    pass


class Secret:
    _pointer: ctypes.c_void_p
    def __init__(self, secret: "bytes"):
        _UniffiConverterBytes.check_lower(secret)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_secret_new,
        _UniffiConverterBytes.lower(secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_secret, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_secret, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeSecret:

    @staticmethod
    def lift(value: int):
        return Secret._make_instance_(value)

    @staticmethod
    def check_lower(value: Secret):
        if not isinstance(value, Secret):
            raise TypeError("Expected Secret instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SecretProtocol):
        if not isinstance(value, Secret):
            raise TypeError("Expected Secret instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SecretProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneProtocol(typing.Protocol):
    def deterministic(self, ):
        raise NotImplementedError
    def standard(self, ):
        raise NotImplementedError
    def standard_attached(self, ):
        raise NotImplementedError
    def vector(self, ):
        raise NotImplementedError


class Standalone:
    _pointer: ctypes.c_void_p
    def __init__(self, config: "StandaloneConfiguration"):
        _UniffiConverterTypeStandaloneConfiguration.check_lower(config)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalone_new,
        _UniffiConverterTypeStandaloneConfiguration.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalone, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalone, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def deterministic(self, ) -> "StandaloneDeterministicClient":
        return _UniffiConverterTypeStandaloneDeterministicClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_deterministic,self._uniffi_clone_pointer(),)
        )





    def standard(self, ) -> "StandaloneStandardClient":
        return _UniffiConverterTypeStandaloneStandardClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard,self._uniffi_clone_pointer(),)
        )





    def standard_attached(self, ) -> "StandaloneStandardAttachedClient":
        return _UniffiConverterTypeStandaloneStandardAttachedClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard_attached,self._uniffi_clone_pointer(),)
        )





    def vector(self, ) -> "StandaloneVectorClient":
        return _UniffiConverterTypeStandaloneVectorClient.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_vector,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeStandalone:

    @staticmethod
    def lift(value: int):
        return Standalone._make_instance_(value)

    @staticmethod
    def check_lower(value: Standalone):
        if not isinstance(value, Standalone):
            raise TypeError("Expected Standalone instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneProtocol):
        if not isinstance(value, Standalone):
            raise TypeError("Expected Standalone instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneConfigurationProtocol(typing.Protocol):
    """
    Configuration for the standalone SDKs. Sets secrets and secret paths for the different SDK operations.
    If usage of only one set of SDK operations is desired the others can be left as empty objects, and will error if
    called in that state. If you want to share a secret between multiple SDK modes, you'll need to create secrets in each
    mode that share the same secret bytes.
    """

    pass


class StandaloneConfiguration:
    """
    Configuration for the standalone SDKs. Sets secrets and secret paths for the different SDK operations.
    If usage of only one set of SDK operations is desired the others can be left as empty objects, and will error if
    called in that state. If you want to share a secret between multiple SDK modes, you'll need to create secrets in each
    mode that share the same secret bytes.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, standard: "StandardSecrets",deterministic: "dict[SecretPath, RotatableSecret]",vector: "dict[SecretPath, VectorSecret]"):
        _UniffiConverterTypeStandardSecrets.check_lower(standard)
        
        _UniffiConverterMapTypeSecretPathTypeRotatableSecret.check_lower(deterministic)
        
        _UniffiConverterMapTypeSecretPathTypeVectorSecret.check_lower(vector)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standaloneconfiguration_new,
        _UniffiConverterTypeStandardSecrets.lower(standard),
        _UniffiConverterMapTypeSecretPathTypeRotatableSecret.lower(deterministic),
        _UniffiConverterMapTypeSecretPathTypeVectorSecret.lower(vector))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standaloneconfiguration, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standaloneconfiguration, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeStandaloneConfiguration:

    @staticmethod
    def lift(value: int):
        return StandaloneConfiguration._make_instance_(value)

    @staticmethod
    def check_lower(value: StandaloneConfiguration):
        if not isinstance(value, StandaloneConfiguration):
            raise TypeError("Expected StandaloneConfiguration instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneConfigurationProtocol):
        if not isinstance(value, StandaloneConfiguration):
            raise TypeError("Expected StandaloneConfiguration instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneConfigurationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneDeterministicClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_field: "EncryptedField",metadata: "AlloyMetadata"):
        """
        Decrypt a field that was deterministically encrypted with the provided metadata.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata"):
        """
        Decrypt each of the fields that were deterministically encrypted with the provided metadata.
        Note that because the metadata is shared between the fields, they all must correspond to the
        same tenant ID.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_field: "PlaintextField",metadata: "AlloyMetadata"):
        """
        Encrypt a field with the provided metadata.
        Because the field is encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_fields: "PlaintextFields",metadata: "AlloyMetadata"):
        """
        Deterministically encrypt the provided fields with the provided metadata.
        Because the fields are encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        raise NotImplementedError
    def generate_query_field_values(self, fields_to_query: "PlaintextFields",metadata: "AlloyMetadata"):
        """
        Encrypt each plaintext field with any Current and InRotation keys for the provided secret path.
        The resulting encrypted fields should be used in tandem when querying the data store.
        """

        raise NotImplementedError
    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        """
        Generate a prefix that could used to search a data store for fields encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        """

        raise NotImplementedError
    def rotate_fields(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Re-encrypt already encrypted fields with the Current key for the provided tenant. The `metadata` passed
        must contain the tenant ID that the fields were originally encrypted to. If `new_tenant_id` is empty,
        the fields will simply be encrypted with the same tenant's current secret.
        """

        raise NotImplementedError


class StandaloneDeterministicClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonedeterministicclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonedeterministicclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_field: "EncryptedField",metadata: "AlloyMetadata") -> "PlaintextField":
        """
        Decrypt a field that was deterministically encrypted with the provided metadata.
        """

        _UniffiConverterTypeEncryptedField.check_lower(encrypted_field)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedField.lower(encrypted_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextField.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata") -> "DeterministicDecryptBatchResult":
        """
        Decrypt each of the fields that were deterministically encrypted with the provided metadata.
        Note that because the metadata is shared between the fields, they all must correspond to the
        same tenant ID.
        """

        _UniffiConverterTypeEncryptedFields.check_lower(encrypted_fields)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedFields.lower(encrypted_fields),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDeterministicDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_field: "PlaintextField",metadata: "AlloyMetadata") -> "EncryptedField":
        """
        Encrypt a field with the provided metadata.
        Because the field is encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        _UniffiConverterTypePlaintextField.check_lower(plaintext_field)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextField.lower(plaintext_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedField.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_fields: "PlaintextFields",metadata: "AlloyMetadata") -> "DeterministicEncryptBatchResult":
        """
        Deterministically encrypt the provided fields with the provided metadata.
        Because the fields are encrypted deterministically with each call, the result will be the same for repeated calls.
        This allows for exact matches and indexing of the encrypted field, but comes with some security considerations.
        If you don't need to support these use cases, we recommend using `standard` encryption instead.
        """

        _UniffiConverterTypePlaintextFields.check_lower(plaintext_fields)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextFields.lower(plaintext_fields),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDeterministicEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def generate_query_field_values(self, fields_to_query: "PlaintextFields",metadata: "AlloyMetadata") -> "GenerateFieldQueryResult":
        """
        Encrypt each plaintext field with any Current and InRotation keys for the provided secret path.
        The resulting encrypted fields should be used in tandem when querying the data store.
        """

        _UniffiConverterTypePlaintextFields.check_lower(fields_to_query)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_generate_query_field_values(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextFields.lower(fields_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGenerateFieldQueryResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata") -> "bytes":
        """
        Generate a prefix that could used to search a data store for fields encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        """

        _UniffiConverterTypeSecretPath.check_lower(secret_path)
        
        _UniffiConverterTypeDerivationPath.check_lower(derivation_path)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_get_in_rotation_prefix(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rotate_fields(self, encrypted_fields: "EncryptedFields",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "DeterministicRotateResult":
        """
        Re-encrypt already encrypted fields with the Current key for the provided tenant. The `metadata` passed
        must contain the tenant ID that the fields were originally encrypted to. If `new_tenant_id` is empty,
        the fields will simply be encrypted with the same tenant's current secret.
        """

        _UniffiConverterTypeEncryptedFields.check_lower(encrypted_fields)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_rotate_fields(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedFields.lower(encrypted_fields),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDeterministicRotateResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeStandaloneDeterministicClient:

    @staticmethod
    def lift(value: int):
        return StandaloneDeterministicClient._make_instance_(value)

    @staticmethod
    def check_lower(value: StandaloneDeterministicClient):
        if not isinstance(value, StandaloneDeterministicClient):
            raise TypeError("Expected StandaloneDeterministicClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneDeterministicClientProtocol):
        if not isinstance(value, StandaloneDeterministicClient):
            raise TypeError("Expected StandaloneDeterministicClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneDeterministicClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneSecretProtocol(typing.Protocol):
    """
    A secret used by standalone mode to derive encryption keys.
    """

    pass


class StandaloneSecret:
    """
    A secret used by standalone mode to derive encryption keys.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, id: "int",secret: "Secret"):
        """
        Create a standalone secret. The secret needs to be cryptographically random bytes.
        """

        _UniffiConverterInt32.check_lower(id)
        
        _UniffiConverterTypeSecret.check_lower(secret)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalonesecret_new,
        _UniffiConverterInt32.lower(id),
        _UniffiConverterTypeSecret.lower(secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonesecret, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonesecret, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeStandaloneSecret:

    @staticmethod
    def lift(value: int):
        return StandaloneSecret._make_instance_(value)

    @staticmethod
    def check_lower(value: StandaloneSecret):
        if not isinstance(value, StandaloneSecret):
            raise TypeError("Expected StandaloneSecret instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneSecretProtocol):
        if not isinstance(value, StandaloneSecret):
            raise TypeError("Expected StandaloneSecret instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneSecretProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneStandardAttachedClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_document: "EncryptedAttachedDocument",metadata: "AlloyMetadata"):
        """
        Decrypt a document that was encrypted with the provided metadata.
        The document must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata"):
        """
        Decrypt multiple documents that were encrypted with the provided metadata.
        The documents must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_document: "PlaintextAttachedDocument",metadata: "AlloyMetadata"):
        """
        Encrypt a document with the provided metadata.
        A DEK (document encryption key) will be generated and encrypted using a derived key.
        The result is a single blob of bytes with the edek put on the front of it.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_documents: "PlaintextAttachedDocuments",metadata: "AlloyMetadata"):
        """
        Encrypt multiple documents with the provided metadata.
        A DEK (document encryption key) will be generated for each document and encrypted using a derived key.
        """

        raise NotImplementedError
    def get_searchable_edek_prefix(self, id: "int"):
        """
        Generate a prefix that could used to search a data store for documents encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        Note that this will not work for matching values that don't use our key_id_header format, such as cloaked search.
        """

        raise NotImplementedError
    def rekey_documents(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Decrypt the provided documents and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the documents will be encrypted to the original tenant.
        """

        raise NotImplementedError


class StandaloneStandardAttachedClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardattachedclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonestandardattachedclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_document: "EncryptedAttachedDocument",metadata: "AlloyMetadata") -> "PlaintextAttachedDocument":
        """
        Decrypt a document that was encrypted with the provided metadata.
        The document must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        _UniffiConverterTypeEncryptedAttachedDocument.check_lower(encrypted_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedAttachedDocument.lower(encrypted_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextAttachedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata") -> "StandardAttachedDecryptBatchResult":
        """
        Decrypt multiple documents that were encrypted with the provided metadata.
        The documents must have been encrypted using attached encryption and not deterministic or standard encryption.
        """

        _UniffiConverterTypeEncryptedAttachedDocuments.check_lower(encrypted_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedAttachedDocuments.lower(encrypted_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardAttachedDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_document: "PlaintextAttachedDocument",metadata: "AlloyMetadata") -> "EncryptedAttachedDocument":
        """
        Encrypt a document with the provided metadata.
        A DEK (document encryption key) will be generated and encrypted using a derived key.
        The result is a single blob of bytes with the edek put on the front of it.
        """

        _UniffiConverterTypePlaintextAttachedDocument.check_lower(plaintext_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextAttachedDocument.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedAttachedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_documents: "PlaintextAttachedDocuments",metadata: "AlloyMetadata") -> "StandardAttachedEncryptBatchResult":
        """
        Encrypt multiple documents with the provided metadata.
        A DEK (document encryption key) will be generated for each document and encrypted using a derived key.
        """

        _UniffiConverterTypePlaintextAttachedDocuments.check_lower(plaintext_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextAttachedDocuments.lower(plaintext_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardAttachedEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )




    def get_searchable_edek_prefix(self, id: "int") -> "bytes":
        """
        Generate a prefix that could used to search a data store for documents encrypted using an identifier (KMS
        config id for SaaS Shield, secret id for Standalone). These bytes should be encoded into
        a format matching the encoding in the data store. z85/ascii85 users should first pass these bytes through
        `encode_prefix_z85` or `base85_prefix_padding`. Make sure you've read the documentation of those functions to
        avoid pitfalls when encoding across byte boundaries.
        Note that this will not work for matching values that don't use our key_id_header format, such as cloaked search.
        """

        _UniffiConverterInt32.check_lower(id)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_get_searchable_edek_prefix,self._uniffi_clone_pointer(),
        _UniffiConverterInt32.lower(id))
        )




    async def rekey_documents(self, encrypted_documents: "EncryptedAttachedDocuments",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "RekeyAttachedDocumentsBatchResult":
        """
        Decrypt the provided documents and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the documents will be encrypted to the original tenant.
        """

        _UniffiConverterTypeEncryptedAttachedDocuments.check_lower(encrypted_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardattachedclient_rekey_documents(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedAttachedDocuments.lower(encrypted_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRekeyAttachedDocumentsBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeStandaloneStandardAttachedClient:

    @staticmethod
    def lift(value: int):
        return StandaloneStandardAttachedClient._make_instance_(value)

    @staticmethod
    def check_lower(value: StandaloneStandardAttachedClient):
        if not isinstance(value, StandaloneStandardAttachedClient):
            raise TypeError("Expected StandaloneStandardAttachedClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneStandardAttachedClientProtocol):
        if not isinstance(value, StandaloneStandardAttachedClient):
            raise TypeError("Expected StandaloneStandardAttachedClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneStandardAttachedClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneStandardClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_document: "EncryptedDocument",metadata: "AlloyMetadata"):
        """
        Decrypt a document that was encrypted with the provided metadata. The document must have been encrypted with one
        of the `StandardDocumentOps.encrypt` functions. The result contains a map from field identifiers to decrypted
        bytes.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_documents: "EncryptedDocuments",metadata: "AlloyMetadata"):
        """
        Decrypt each of the provided documents with the provided metadata.
        Note that because the metadata is shared between the documents, they all must correspond to the
        same tenant ID.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_document: "PlaintextDocument",metadata: "AlloyMetadata"):
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        A DEK (document encryption key) will be generated and encrypted using a derived key, then each field of the
        document will be encrypted separately using a random IV and this single generated DEK.
        The result contains a map from field identifiers to encrypted bytes as well as the EDEK (encrypted document
        encryption key) used for encryption.
        The document is encrypted differently with each call, so the result is not suited for exact matches or indexing.
        For the same reason however the strongest protection of the document is provided by this method.
        To support these uses, see the `DeterministicFieldOps.encrypt` function.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_documents: "PlaintextDocuments",metadata: "AlloyMetadata"):
        """
        Encrypt each of the provided documents with the provided metadata.
        Note that because only a single metadata value is passed, each document will be encrypted to the same tenant.
        """

        raise NotImplementedError
    def encrypt_with_existing_edek(self, plaintext_document: "PlaintextDocumentWithEdek",metadata: "AlloyMetadata"):
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        The provided EDEK will be decrypted and used to encrypt each field. This is useful when updating some fields
        of the document.
        """

        raise NotImplementedError
    def encrypt_with_existing_edek_batch(self, plaintext_documents: "PlaintextDocumentsWithEdeks",metadata: "AlloyMetadata"):
        """
        Encrypt multiple documents with the provided metadata.
        The provided EDEKs will be decrypted and used to encrypt each corresponding document's fields.
        This is useful when updating some fields of the document.
        """

        raise NotImplementedError
    def rekey_edeks(self, edeks: "dict[DocumentId, EdekWithKeyIdHeader]",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Decrypt the provided EDEKs and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the EDEK will be encrypted to the original tenant. Because the underlying DEK does not change, a document
        associated with the old EDEK can be decrypted with the new EDEK without changing its document data.
        """

        raise NotImplementedError


class StandaloneStandardClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonestandardclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_document: "EncryptedDocument",metadata: "AlloyMetadata") -> "PlaintextDocument":
        """
        Decrypt a document that was encrypted with the provided metadata. The document must have been encrypted with one
        of the `StandardDocumentOps.encrypt` functions. The result contains a map from field identifiers to decrypted
        bytes.
        """

        _UniffiConverterTypeEncryptedDocument.check_lower(encrypted_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedDocument.lower(encrypted_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_documents: "EncryptedDocuments",metadata: "AlloyMetadata") -> "StandardDecryptBatchResult":
        """
        Decrypt each of the provided documents with the provided metadata.
        Note that because the metadata is shared between the documents, they all must correspond to the
        same tenant ID.
        """

        _UniffiConverterTypeEncryptedDocuments.check_lower(encrypted_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedDocuments.lower(encrypted_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_document: "PlaintextDocument",metadata: "AlloyMetadata") -> "EncryptedDocument":
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        A DEK (document encryption key) will be generated and encrypted using a derived key, then each field of the
        document will be encrypted separately using a random IV and this single generated DEK.
        The result contains a map from field identifiers to encrypted bytes as well as the EDEK (encrypted document
        encryption key) used for encryption.
        The document is encrypted differently with each call, so the result is not suited for exact matches or indexing.
        For the same reason however the strongest protection of the document is provided by this method.
        To support these uses, see the `DeterministicFieldOps.encrypt` function.
        """

        _UniffiConverterTypePlaintextDocument.check_lower(plaintext_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocument.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_documents: "PlaintextDocuments",metadata: "AlloyMetadata") -> "StandardEncryptBatchResult":
        """
        Encrypt each of the provided documents with the provided metadata.
        Note that because only a single metadata value is passed, each document will be encrypted to the same tenant.
        """

        _UniffiConverterTypePlaintextDocuments.check_lower(plaintext_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocuments.lower(plaintext_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_with_existing_edek(self, plaintext_document: "PlaintextDocumentWithEdek",metadata: "AlloyMetadata") -> "EncryptedDocument":
        """
        Encrypt a document with the provided metadata. The document must be a map from field identifiers to plaintext
        bytes, and the same metadata must be provided when decrypting the document.
        The provided EDEK will be decrypted and used to encrypt each field. This is useful when updating some fields
        of the document.
        """

        _UniffiConverterTypePlaintextDocumentWithEdek.check_lower(plaintext_document)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_with_existing_edek(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocumentWithEdek.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedDocument.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_with_existing_edek_batch(self, plaintext_documents: "PlaintextDocumentsWithEdeks",metadata: "AlloyMetadata") -> "StandardEncryptBatchResult":
        """
        Encrypt multiple documents with the provided metadata.
        The provided EDEKs will be decrypted and used to encrypt each corresponding document's fields.
        This is useful when updating some fields of the document.
        """

        _UniffiConverterTypePlaintextDocumentsWithEdeks.check_lower(plaintext_documents)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt_with_existing_edek_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextDocumentsWithEdeks.lower(plaintext_documents),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStandardEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rekey_edeks(self, edeks: "dict[DocumentId, EdekWithKeyIdHeader]",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "RekeyEdeksBatchResult":
        """
        Decrypt the provided EDEKs and re-encrypt them using the tenant's current key. If `new_tenant_id` is `None`,
        the EDEK will be encrypted to the original tenant. Because the underlying DEK does not change, a document
        associated with the old EDEK can be decrypted with the new EDEK without changing its document data.
        """

        _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.check_lower(edeks)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_rekey_edeks(
                self._uniffi_clone_pointer(), 
        _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.lower(edeks),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRekeyEdeksBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeStandaloneStandardClient:

    @staticmethod
    def lift(value: int):
        return StandaloneStandardClient._make_instance_(value)

    @staticmethod
    def check_lower(value: StandaloneStandardClient):
        if not isinstance(value, StandaloneStandardClient):
            raise TypeError("Expected StandaloneStandardClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneStandardClientProtocol):
        if not isinstance(value, StandaloneStandardClient):
            raise TypeError("Expected StandaloneStandardClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneStandardClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandaloneVectorClientProtocol(typing.Protocol):
    def decrypt(self, encrypted_vector: "EncryptedVector",metadata: "AlloyMetadata"):
        """
        Decrypt a vector embedding that was encrypted with the provided metadata. The values of the embedding will
        be unshuffled to their original positions during decryption.
        """

        raise NotImplementedError
    def decrypt_batch(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata"):
        """
        Decrypt multiple vector embeddings that were encrypted with the provided metadata. The values of the embeddings
        will be unshuffled to their original positions during decryption.
        Note that because the metadata is shared between the vectors, they all must correspond to the
        same tenant ID.
        """

        raise NotImplementedError
    def encrypt(self, plaintext_vector: "PlaintextVector",metadata: "AlloyMetadata"):
        """
        Encrypt a vector embedding with the provided metadata. The provided embedding is assumed to be normalized
        and its values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embedding.
        """

        raise NotImplementedError
    def encrypt_batch(self, plaintext_vectors: "PlaintextVectors",metadata: "AlloyMetadata"):
        """
        Encrypt multiple vector embeddings with the provided metadata. The provided embeddings are assumed to be normalized
        and their values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embeddings.
        """

        raise NotImplementedError
    def generate_query_vectors(self, vectors_to_query: "PlaintextVectors",metadata: "AlloyMetadata"):
        """
        Encrypt each plaintext vector with any Current and InRotation keys for the provided secret path.
        The resulting encrypted vectors should be used in tandem when querying the vector database.
        """

        raise NotImplementedError
    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        """
        Get the byte prefix for the InRotation secret corresponding to this secret_path.
        Note that if you use z85 or ascii85 encoding, the result of this function should be passed to `base85_compat_prefix_bytes`
        before searching your datastore.
        Note: The derivation_path and metadata are not actually required for this function and can be passed any value.
        """

        raise NotImplementedError
    def rotate_vectors(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]"):
        """
        Rotates vectors from the in-rotation secret for their secret path to the current secret.
        This can also be used to rotate data from one tenant ID to a new one, which most useful when a tenant is
        internally migrated.

        WARNINGS:
        * this involves decrypting then encrypting vectors. Since the vectors are full of floating point numbers,
        this process is lossy, which will cause some drift over time. If you need perfectly preserved accuracy
        store the source vector encrypted with `standard` next to the encrypted vector. `standard` decrypt
        that, `vector` encrypt it again, and replace the encrypted vector with the result.
        * only one metadata and new tenant ID argument means each call to this needs to have one tenant's vectors.
        """

        raise NotImplementedError


class StandaloneVectorClient:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonevectorclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standalonevectorclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def decrypt(self, encrypted_vector: "EncryptedVector",metadata: "AlloyMetadata") -> "PlaintextVector":
        """
        Decrypt a vector embedding that was encrypted with the provided metadata. The values of the embedding will
        be unshuffled to their original positions during decryption.
        """

        _UniffiConverterTypeEncryptedVector.check_lower(encrypted_vector)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedVector.lower(encrypted_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextVector.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def decrypt_batch(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata") -> "VectorDecryptBatchResult":
        """
        Decrypt multiple vector embeddings that were encrypted with the provided metadata. The values of the embeddings
        will be unshuffled to their original positions during decryption.
        Note that because the metadata is shared between the vectors, they all must correspond to the
        same tenant ID.
        """

        _UniffiConverterTypeEncryptedVectors.check_lower(encrypted_vectors)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedVectors.lower(encrypted_vectors),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVectorDecryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt(self, plaintext_vector: "PlaintextVector",metadata: "AlloyMetadata") -> "EncryptedVector":
        """
        Encrypt a vector embedding with the provided metadata. The provided embedding is assumed to be normalized
        and its values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embedding.
        """

        _UniffiConverterTypePlaintextVector.check_lower(plaintext_vector)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextVector.lower(plaintext_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedVector.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def encrypt_batch(self, plaintext_vectors: "PlaintextVectors",metadata: "AlloyMetadata") -> "VectorEncryptBatchResult":
        """
        Encrypt multiple vector embeddings with the provided metadata. The provided embeddings are assumed to be normalized
        and their values will be shuffled as part of the encryption.
        The same tenant ID must be provided in the metadata when decrypting the embeddings.
        """

        _UniffiConverterTypePlaintextVectors.check_lower(plaintext_vectors)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt_batch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextVectors.lower(plaintext_vectors),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVectorEncryptBatchResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def generate_query_vectors(self, vectors_to_query: "PlaintextVectors",metadata: "AlloyMetadata") -> "GenerateVectorQueryResult":
        """
        Encrypt each plaintext vector with any Current and InRotation keys for the provided secret path.
        The resulting encrypted vectors should be used in tandem when querying the vector database.
        """

        _UniffiConverterTypePlaintextVectors.check_lower(vectors_to_query)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_generate_query_vectors(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePlaintextVectors.lower(vectors_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGenerateVectorQueryResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata") -> "bytes":
        """
        Get the byte prefix for the InRotation secret corresponding to this secret_path.
        Note that if you use z85 or ascii85 encoding, the result of this function should be passed to `base85_compat_prefix_bytes`
        before searching your datastore.
        Note: The derivation_path and metadata are not actually required for this function and can be passed any value.
        """

        _UniffiConverterTypeSecretPath.check_lower(secret_path)
        
        _UniffiConverterTypeDerivationPath.check_lower(derivation_path)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_get_in_rotation_prefix(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )



    async def rotate_vectors(self, encrypted_vectors: "EncryptedVectors",metadata: "AlloyMetadata",new_tenant_id: "typing.Optional[TenantId]") -> "VectorRotateResult":
        """
        Rotates vectors from the in-rotation secret for their secret path to the current secret.
        This can also be used to rotate data from one tenant ID to a new one, which most useful when a tenant is
        internally migrated.

        WARNINGS:
        * this involves decrypting then encrypting vectors. Since the vectors are full of floating point numbers,
        this process is lossy, which will cause some drift over time. If you need perfectly preserved accuracy
        store the source vector encrypted with `standard` next to the encrypted vector. `standard` decrypt
        that, `vector` encrypt it again, and replace the encrypted vector with the result.
        * only one metadata and new tenant ID argument means each call to this needs to have one tenant's vectors.
        """

        _UniffiConverterTypeEncryptedVectors.check_lower(encrypted_vectors)
        
        _UniffiConverterTypeAlloyMetadata.check_lower(metadata)
        
        _UniffiConverterOptionalTypeTenantId.check_lower(new_tenant_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_rotate_vectors(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEncryptedVectors.lower(encrypted_vectors),
        _UniffiConverterTypeAlloyMetadata.lower(metadata),
        _UniffiConverterOptionalTypeTenantId.lower(new_tenant_id)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVectorRotateResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeAlloyError,

        )





class _UniffiConverterTypeStandaloneVectorClient:

    @staticmethod
    def lift(value: int):
        return StandaloneVectorClient._make_instance_(value)

    @staticmethod
    def check_lower(value: StandaloneVectorClient):
        if not isinstance(value, StandaloneVectorClient):
            raise TypeError("Expected StandaloneVectorClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandaloneVectorClientProtocol):
        if not isinstance(value, StandaloneVectorClient):
            raise TypeError("Expected StandaloneVectorClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandaloneVectorClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class StandardSecretsProtocol(typing.Protocol):
    """
    A collection of secrets for standalone standard mode used to derive encryption keys.
    The primary secret id is used to look up the primary secret, which will be used for encrypting new documents.
    The rest of the secrets will only be used to decrypt existing documents when encountered.
    """

    pass


class StandardSecrets:
    """
    A collection of secrets for standalone standard mode used to derive encryption keys.
    The primary secret id is used to look up the primary secret, which will be used for encrypting new documents.
    The rest of the secrets will only be used to decrypt existing documents when encountered.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, primary_secret_id: "typing.Optional[int]",secrets: "typing.List[StandaloneSecret]"):
        """
        Create a collection of standard secrets.
        This will error if secret ids aren't unique or the primary secret id isn't in the secrets list.
        """

        _UniffiConverterOptionalInt32.check_lower(primary_secret_id)
        
        _UniffiConverterSequenceTypeStandaloneSecret.check_lower(secrets)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standardsecrets_new,
        _UniffiConverterOptionalInt32.lower(primary_secret_id),
        _UniffiConverterSequenceTypeStandaloneSecret.lower(secrets))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standardsecrets, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_standardsecrets, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeStandardSecrets:

    @staticmethod
    def lift(value: int):
        return StandardSecrets._make_instance_(value)

    @staticmethod
    def check_lower(value: StandardSecrets):
        if not isinstance(value, StandardSecrets):
            raise TypeError("Expected StandardSecrets instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StandardSecretsProtocol):
        if not isinstance(value, StandardSecrets):
            raise TypeError("Expected StandardSecrets instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StandardSecretsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class VectorSecretProtocol(typing.Protocol):
    pass


class VectorSecret:
    _pointer: ctypes.c_void_p
    def __init__(self, approximation_factor: "float",secret: "RotatableSecret"):
        """
        The approximation factor should be chosen in a way that balances security with search performance.
        A higher approximation factor is more secure, but introduces more variance into encrypted embeddings,
        possibly leading to degraded performance. A lower bound for the approximation factor to start with is `sqrt(M)`,
        where M is the absolute value of the largest data point in the input embeddings.
        """

        _UniffiConverterFloat.check_lower(approximation_factor)
        
        _UniffiConverterTypeRotatableSecret.check_lower(secret)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_vectorsecret_new,
        _UniffiConverterFloat.lower(approximation_factor),
        _UniffiConverterTypeRotatableSecret.lower(secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_vectorsecret, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_clone_vectorsecret, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeVectorSecret:

    @staticmethod
    def lift(value: int):
        return VectorSecret._make_instance_(value)

    @staticmethod
    def check_lower(value: VectorSecret):
        if not isinstance(value, VectorSecret):
            raise TypeError("Expected VectorSecret instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: VectorSecretProtocol):
        if not isinstance(value, VectorSecret):
            raise TypeError("Expected VectorSecret instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: VectorSecretProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class CustomEvent:
    """
    A custom event. The event must have a screaming snake case name and cannot start with an `_`.
    """

    event_name: "str"
    def __init__(self, *, event_name: "str"):
        self.event_name = event_name

    def __str__(self):
        return "CustomEvent(event_name={})".format(self.event_name)

    def __eq__(self, other):
        if self.event_name != other.event_name:
            return False
        return True

class _UniffiConverterTypeCustomEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CustomEvent(
            event_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.event_name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.event_name, buf)


class DeterministicDecryptBatchResult:
    successes: "PlaintextFields"
    failures: "dict[FieldId, AlloyError]"
    def __init__(self, *, successes: "PlaintextFields", failures: "dict[FieldId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "DeterministicDecryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeDeterministicDecryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DeterministicDecryptBatchResult(
            successes=_UniffiConverterTypePlaintextFields.read(buf),
            failures=_UniffiConverterMapTypeFieldIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePlaintextFields.check_lower(value.successes)
        _UniffiConverterMapTypeFieldIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePlaintextFields.write(value.successes, buf)
        _UniffiConverterMapTypeFieldIdTypeAlloyError.write(value.failures, buf)


class DeterministicEncryptBatchResult:
    successes: "EncryptedFields"
    failures: "dict[FieldId, AlloyError]"
    def __init__(self, *, successes: "EncryptedFields", failures: "dict[FieldId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "DeterministicEncryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeDeterministicEncryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DeterministicEncryptBatchResult(
            successes=_UniffiConverterTypeEncryptedFields.read(buf),
            failures=_UniffiConverterMapTypeFieldIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEncryptedFields.check_lower(value.successes)
        _UniffiConverterMapTypeFieldIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedFields.write(value.successes, buf)
        _UniffiConverterMapTypeFieldIdTypeAlloyError.write(value.failures, buf)


class DeterministicRotateResult:
    successes: "dict[FieldId, EncryptedField]"
    failures: "dict[FieldId, AlloyError]"
    def __init__(self, *, successes: "dict[FieldId, EncryptedField]", failures: "dict[FieldId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "DeterministicRotateResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeDeterministicRotateResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DeterministicRotateResult(
            successes=_UniffiConverterMapTypeFieldIdTypeEncryptedField.read(buf),
            failures=_UniffiConverterMapTypeFieldIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterMapTypeFieldIdTypeEncryptedField.check_lower(value.successes)
        _UniffiConverterMapTypeFieldIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeFieldIdTypeEncryptedField.write(value.successes, buf)
        _UniffiConverterMapTypeFieldIdTypeAlloyError.write(value.failures, buf)


class EncryptedDocument:
    """
    Document and EDEK (encrypted document encryption key) generated by `document_encrypt`/`documentEncrypt`.
    Note that `document_encrypt_deterministic`/`documentEncryptDeterministic` doesn't use this type
    as it prefixes an encryption header to the encrypted document map instead of using a separate EDEK.
    """

    edek: "EdekWithKeyIdHeader"
    """
    Encrypted Document Encryption Key used when the document was encrypted
    """

    document: "dict[FieldId, EncryptedBytes]"
    """
    Map from field name to encrypted document bytes
    """

    def __init__(self, *, edek: "EdekWithKeyIdHeader", document: "dict[FieldId, EncryptedBytes]"):
        self.edek = edek
        self.document = document

    def __str__(self):
        return "EncryptedDocument(edek={}, document={})".format(self.edek, self.document)

    def __eq__(self, other):
        if self.edek != other.edek:
            return False
        if self.document != other.document:
            return False
        return True

class _UniffiConverterTypeEncryptedDocument(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedDocument(
            edek=_UniffiConverterTypeEdekWithKeyIdHeader.read(buf),
            document=_UniffiConverterMapTypeFieldIdTypeEncryptedBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEdekWithKeyIdHeader.check_lower(value.edek)
        _UniffiConverterMapTypeFieldIdTypeEncryptedBytes.check_lower(value.document)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEdekWithKeyIdHeader.write(value.edek, buf)
        _UniffiConverterMapTypeFieldIdTypeEncryptedBytes.write(value.document, buf)


class EncryptedField:
    encrypted_field: "EncryptedBytes"
    secret_path: "SecretPath"
    derivation_path: "DerivationPath"
    def __init__(self, *, encrypted_field: "EncryptedBytes", secret_path: "SecretPath", derivation_path: "DerivationPath"):
        self.encrypted_field = encrypted_field
        self.secret_path = secret_path
        self.derivation_path = derivation_path

    def __str__(self):
        return "EncryptedField(encrypted_field={}, secret_path={}, derivation_path={})".format(self.encrypted_field, self.secret_path, self.derivation_path)

    def __eq__(self, other):
        if self.encrypted_field != other.encrypted_field:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        return True

class _UniffiConverterTypeEncryptedField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedField(
            encrypted_field=_UniffiConverterTypeEncryptedBytes.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEncryptedBytes.check_lower(value.encrypted_field)
        _UniffiConverterTypeSecretPath.check_lower(value.secret_path)
        _UniffiConverterTypeDerivationPath.check_lower(value.derivation_path)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedBytes.write(value.encrypted_field, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)


class EncryptedVector:
    encrypted_vector: "typing.List[float]"
    secret_path: "SecretPath"
    derivation_path: "DerivationPath"
    paired_icl_info: "EncryptedBytes"
    def __init__(self, *, encrypted_vector: "typing.List[float]", secret_path: "SecretPath", derivation_path: "DerivationPath", paired_icl_info: "EncryptedBytes"):
        self.encrypted_vector = encrypted_vector
        self.secret_path = secret_path
        self.derivation_path = derivation_path
        self.paired_icl_info = paired_icl_info

    def __str__(self):
        return "EncryptedVector(encrypted_vector={}, secret_path={}, derivation_path={}, paired_icl_info={})".format(self.encrypted_vector, self.secret_path, self.derivation_path, self.paired_icl_info)

    def __eq__(self, other):
        if self.encrypted_vector != other.encrypted_vector:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        if self.paired_icl_info != other.paired_icl_info:
            return False
        return True

class _UniffiConverterTypeEncryptedVector(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedVector(
            encrypted_vector=_UniffiConverterSequenceFloat.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
            paired_icl_info=_UniffiConverterTypeEncryptedBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceFloat.check_lower(value.encrypted_vector)
        _UniffiConverterTypeSecretPath.check_lower(value.secret_path)
        _UniffiConverterTypeDerivationPath.check_lower(value.derivation_path)
        _UniffiConverterTypeEncryptedBytes.check_lower(value.paired_icl_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceFloat.write(value.encrypted_vector, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)
        _UniffiConverterTypeEncryptedBytes.write(value.paired_icl_info, buf)


class PlaintextDocumentWithEdek:
    edek: "EdekWithKeyIdHeader"
    document: "PlaintextDocument"
    def __init__(self, *, edek: "EdekWithKeyIdHeader", document: "PlaintextDocument"):
        self.edek = edek
        self.document = document

    def __str__(self):
        return "PlaintextDocumentWithEdek(edek={}, document={})".format(self.edek, self.document)

    def __eq__(self, other):
        if self.edek != other.edek:
            return False
        if self.document != other.document:
            return False
        return True

class _UniffiConverterTypePlaintextDocumentWithEdek(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlaintextDocumentWithEdek(
            edek=_UniffiConverterTypeEdekWithKeyIdHeader.read(buf),
            document=_UniffiConverterTypePlaintextDocument.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEdekWithKeyIdHeader.check_lower(value.edek)
        _UniffiConverterTypePlaintextDocument.check_lower(value.document)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEdekWithKeyIdHeader.write(value.edek, buf)
        _UniffiConverterTypePlaintextDocument.write(value.document, buf)


class PlaintextField:
    plaintext_field: "PlaintextBytes"
    secret_path: "SecretPath"
    derivation_path: "DerivationPath"
    def __init__(self, *, plaintext_field: "PlaintextBytes", secret_path: "SecretPath", derivation_path: "DerivationPath"):
        self.plaintext_field = plaintext_field
        self.secret_path = secret_path
        self.derivation_path = derivation_path

    def __str__(self):
        return "PlaintextField(plaintext_field={}, secret_path={}, derivation_path={})".format(self.plaintext_field, self.secret_path, self.derivation_path)

    def __eq__(self, other):
        if self.plaintext_field != other.plaintext_field:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        return True

class _UniffiConverterTypePlaintextField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlaintextField(
            plaintext_field=_UniffiConverterTypePlaintextBytes.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePlaintextBytes.check_lower(value.plaintext_field)
        _UniffiConverterTypeSecretPath.check_lower(value.secret_path)
        _UniffiConverterTypeDerivationPath.check_lower(value.derivation_path)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePlaintextBytes.write(value.plaintext_field, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)


class PlaintextVector:
    plaintext_vector: "typing.List[float]"
    secret_path: "SecretPath"
    derivation_path: "DerivationPath"
    def __init__(self, *, plaintext_vector: "typing.List[float]", secret_path: "SecretPath", derivation_path: "DerivationPath"):
        self.plaintext_vector = plaintext_vector
        self.secret_path = secret_path
        self.derivation_path = derivation_path

    def __str__(self):
        return "PlaintextVector(plaintext_vector={}, secret_path={}, derivation_path={})".format(self.plaintext_vector, self.secret_path, self.derivation_path)

    def __eq__(self, other):
        if self.plaintext_vector != other.plaintext_vector:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        return True

class _UniffiConverterTypePlaintextVector(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlaintextVector(
            plaintext_vector=_UniffiConverterSequenceFloat.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceFloat.check_lower(value.plaintext_vector)
        _UniffiConverterTypeSecretPath.check_lower(value.secret_path)
        _UniffiConverterTypeDerivationPath.check_lower(value.derivation_path)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceFloat.write(value.plaintext_vector, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)


class RekeyAttachedDocumentsBatchResult:
    successes: "dict[DocumentId, EncryptedAttachedDocument]"
    failures: "dict[DocumentId, AlloyError]"
    def __init__(self, *, successes: "dict[DocumentId, EncryptedAttachedDocument]", failures: "dict[DocumentId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "RekeyAttachedDocumentsBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeRekeyAttachedDocumentsBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RekeyAttachedDocumentsBatchResult(
            successes=_UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.read(buf),
            failures=_UniffiConverterMapTypeDocumentIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.check_lower(value.successes)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.write(value.successes, buf)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.write(value.failures, buf)


class RekeyEdeksBatchResult:
    successes: "dict[DocumentId, EdekWithKeyIdHeader]"
    failures: "dict[DocumentId, AlloyError]"
    def __init__(self, *, successes: "dict[DocumentId, EdekWithKeyIdHeader]", failures: "dict[DocumentId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "RekeyEdeksBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeRekeyEdeksBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RekeyEdeksBatchResult(
            successes=_UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.read(buf),
            failures=_UniffiConverterMapTypeDocumentIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.check_lower(value.successes)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader.write(value.successes, buf)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.write(value.failures, buf)


class StandardAttachedDecryptBatchResult:
    successes: "PlaintextAttachedDocuments"
    failures: "dict[DocumentId, AlloyError]"
    def __init__(self, *, successes: "PlaintextAttachedDocuments", failures: "dict[DocumentId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "StandardAttachedDecryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeStandardAttachedDecryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StandardAttachedDecryptBatchResult(
            successes=_UniffiConverterTypePlaintextAttachedDocuments.read(buf),
            failures=_UniffiConverterMapTypeDocumentIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePlaintextAttachedDocuments.check_lower(value.successes)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePlaintextAttachedDocuments.write(value.successes, buf)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.write(value.failures, buf)


class StandardAttachedEncryptBatchResult:
    successes: "EncryptedAttachedDocuments"
    failures: "dict[DocumentId, AlloyError]"
    def __init__(self, *, successes: "EncryptedAttachedDocuments", failures: "dict[DocumentId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "StandardAttachedEncryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeStandardAttachedEncryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StandardAttachedEncryptBatchResult(
            successes=_UniffiConverterTypeEncryptedAttachedDocuments.read(buf),
            failures=_UniffiConverterMapTypeDocumentIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEncryptedAttachedDocuments.check_lower(value.successes)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedAttachedDocuments.write(value.successes, buf)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.write(value.failures, buf)


class StandardDecryptBatchResult:
    successes: "PlaintextDocuments"
    failures: "dict[DocumentId, AlloyError]"
    def __init__(self, *, successes: "PlaintextDocuments", failures: "dict[DocumentId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "StandardDecryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeStandardDecryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StandardDecryptBatchResult(
            successes=_UniffiConverterTypePlaintextDocuments.read(buf),
            failures=_UniffiConverterMapTypeDocumentIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePlaintextDocuments.check_lower(value.successes)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePlaintextDocuments.write(value.successes, buf)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.write(value.failures, buf)


class StandardEncryptBatchResult:
    successes: "EncryptedDocuments"
    failures: "dict[DocumentId, AlloyError]"
    def __init__(self, *, successes: "EncryptedDocuments", failures: "dict[DocumentId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "StandardEncryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeStandardEncryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StandardEncryptBatchResult(
            successes=_UniffiConverterTypeEncryptedDocuments.read(buf),
            failures=_UniffiConverterMapTypeDocumentIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEncryptedDocuments.check_lower(value.successes)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedDocuments.write(value.successes, buf)
        _UniffiConverterMapTypeDocumentIdTypeAlloyError.write(value.failures, buf)


class VectorDecryptBatchResult:
    successes: "PlaintextVectors"
    failures: "dict[VectorId, AlloyError]"
    def __init__(self, *, successes: "PlaintextVectors", failures: "dict[VectorId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "VectorDecryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeVectorDecryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return VectorDecryptBatchResult(
            successes=_UniffiConverterTypePlaintextVectors.read(buf),
            failures=_UniffiConverterMapTypeVectorIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePlaintextVectors.check_lower(value.successes)
        _UniffiConverterMapTypeVectorIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePlaintextVectors.write(value.successes, buf)
        _UniffiConverterMapTypeVectorIdTypeAlloyError.write(value.failures, buf)


class VectorEncryptBatchResult:
    successes: "EncryptedVectors"
    failures: "dict[VectorId, AlloyError]"
    def __init__(self, *, successes: "EncryptedVectors", failures: "dict[VectorId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "VectorEncryptBatchResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeVectorEncryptBatchResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return VectorEncryptBatchResult(
            successes=_UniffiConverterTypeEncryptedVectors.read(buf),
            failures=_UniffiConverterMapTypeVectorIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeEncryptedVectors.check_lower(value.successes)
        _UniffiConverterMapTypeVectorIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedVectors.write(value.successes, buf)
        _UniffiConverterMapTypeVectorIdTypeAlloyError.write(value.failures, buf)


class VectorRotateResult:
    successes: "dict[VectorId, EncryptedVector]"
    failures: "dict[VectorId, AlloyError]"
    def __init__(self, *, successes: "dict[VectorId, EncryptedVector]", failures: "dict[VectorId, AlloyError]"):
        self.successes = successes
        self.failures = failures

    def __str__(self):
        return "VectorRotateResult(successes={}, failures={})".format(self.successes, self.failures)

    def __eq__(self, other):
        if self.successes != other.successes:
            return False
        if self.failures != other.failures:
            return False
        return True

class _UniffiConverterTypeVectorRotateResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return VectorRotateResult(
            successes=_UniffiConverterMapTypeVectorIdTypeEncryptedVector.read(buf),
            failures=_UniffiConverterMapTypeVectorIdTypeAlloyError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterMapTypeVectorIdTypeEncryptedVector.check_lower(value.successes)
        _UniffiConverterMapTypeVectorIdTypeAlloyError.check_lower(value.failures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeVectorIdTypeEncryptedVector.write(value.successes, buf)
        _UniffiConverterMapTypeVectorIdTypeAlloyError.write(value.failures, buf)





class AdminEvent(enum.Enum):
    ADD = 0
    
    CHANGE_PERMISSIONS = 1
    
    CHANGE_SETTING = 2
    
    REMOVE = 3
    


class _UniffiConverterTypeAdminEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AdminEvent.ADD
        if variant == 2:
            return AdminEvent.CHANGE_PERMISSIONS
        if variant == 3:
            return AdminEvent.CHANGE_SETTING
        if variant == 4:
            return AdminEvent.REMOVE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AdminEvent.ADD:
            return
        if value == AdminEvent.CHANGE_PERMISSIONS:
            return
        if value == AdminEvent.CHANGE_SETTING:
            return
        if value == AdminEvent.REMOVE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AdminEvent.ADD:
            buf.write_i32(1)
        if value == AdminEvent.CHANGE_PERMISSIONS:
            buf.write_i32(2)
        if value == AdminEvent.CHANGE_SETTING:
            buf.write_i32(3)
        if value == AdminEvent.REMOVE:
            buf.write_i32(4)




# AlloyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AlloyError(Exception):
    """
    Errors related to IronCore Alloy SDK
    """

    pass

_UniffiTempAlloyError = AlloyError

class AlloyError:  # type: ignore
    """
    Errors related to IronCore Alloy SDK
    """

    class InvalidConfiguration(_UniffiTempAlloyError):
        """
        Error while loading configuration.
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.InvalidConfiguration({})".format(str(self))
    _UniffiTempAlloyError.InvalidConfiguration = InvalidConfiguration # type: ignore
    class InvalidKey(_UniffiTempAlloyError):
        """
        Error with key used
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.InvalidKey({})".format(str(self))
    _UniffiTempAlloyError.InvalidKey = InvalidKey # type: ignore
    class InvalidInput(_UniffiTempAlloyError):
        """
        Error with user input
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.InvalidInput({})".format(str(self))
    _UniffiTempAlloyError.InvalidInput = InvalidInput # type: ignore
    class EncryptError(_UniffiTempAlloyError):
        """
        Errors while encrypting
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.EncryptError({})".format(str(self))
    _UniffiTempAlloyError.EncryptError = EncryptError # type: ignore
    class DecryptError(_UniffiTempAlloyError):
        """
        Errors while decrypting
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.DecryptError({})".format(str(self))
    _UniffiTempAlloyError.DecryptError = DecryptError # type: ignore
    class ProtobufError(_UniffiTempAlloyError):
        """
        Error when parsing encryption headers/metadata
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.ProtobufError({})".format(str(self))
    _UniffiTempAlloyError.ProtobufError = ProtobufError # type: ignore
    class RequestError(_UniffiTempAlloyError):
        """
        Error when making a request to the TSP
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.RequestError({})".format(str(self))
    _UniffiTempAlloyError.RequestError = RequestError # type: ignore
    class SerdeJsonError(_UniffiTempAlloyError):
        """
        Error converting request data to JSON
        """

        def __init__(self, msg):
            super().__init__(", ".join([
                "msg={!r}".format(msg),
            ]))
            self.msg = msg

        def __repr__(self):
            return "AlloyError.SerdeJsonError({})".format(str(self))
    _UniffiTempAlloyError.SerdeJsonError = SerdeJsonError # type: ignore
    class TspError(_UniffiTempAlloyError):
        """
        Error directly from the TSP. See https://ironcorelabs.com/docs/saas-shield/tenant-security-proxy/errors/
        for details about these error codes.
        """

        def __init__(self, error, http_code, tsp_code, msg):
            super().__init__(", ".join([
                "error={!r}".format(error),
                "http_code={!r}".format(http_code),
                "tsp_code={!r}".format(tsp_code),
                "msg={!r}".format(msg),
            ]))
            self.error = error
            self.http_code = http_code
            self.tsp_code = tsp_code
            self.msg = msg

        def __repr__(self):
            return "AlloyError.TspError({})".format(str(self))
    _UniffiTempAlloyError.TspError = TspError # type: ignore

AlloyError = _UniffiTempAlloyError # type: ignore
del _UniffiTempAlloyError


class _UniffiConverterTypeAlloyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AlloyError.InvalidConfiguration(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return AlloyError.InvalidKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return AlloyError.InvalidInput(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return AlloyError.EncryptError(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return AlloyError.DecryptError(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return AlloyError.ProtobufError(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return AlloyError.RequestError(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return AlloyError.SerdeJsonError(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return AlloyError.TspError(
                _UniffiConverterTypeTenantSecurityProxyError.read(buf),
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AlloyError.InvalidConfiguration):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.InvalidKey):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.InvalidInput):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.EncryptError):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.DecryptError):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.ProtobufError):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.RequestError):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.SerdeJsonError):
            _UniffiConverterString.check_lower(value.msg)
            return
        if isinstance(value, AlloyError.TspError):
            _UniffiConverterTypeTenantSecurityProxyError.check_lower(value.error)
            _UniffiConverterUInt16.check_lower(value.http_code)
            _UniffiConverterUInt16.check_lower(value.tsp_code)
            _UniffiConverterString.check_lower(value.msg)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AlloyError.InvalidConfiguration):
            buf.write_i32(1)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.InvalidKey):
            buf.write_i32(2)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.InvalidInput):
            buf.write_i32(3)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.EncryptError):
            buf.write_i32(4)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.DecryptError):
            buf.write_i32(5)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.ProtobufError):
            buf.write_i32(6)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.RequestError):
            buf.write_i32(7)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.SerdeJsonError):
            buf.write_i32(8)
            _UniffiConverterString.write(value.msg, buf)
        if isinstance(value, AlloyError.TspError):
            buf.write_i32(9)
            _UniffiConverterTypeTenantSecurityProxyError.write(value.error, buf)
            _UniffiConverterUInt16.write(value.http_code, buf)
            _UniffiConverterUInt16.write(value.tsp_code, buf)
            _UniffiConverterString.write(value.msg, buf)





class DataEvent(enum.Enum):
    IMPORT = 0
    
    EXPORT = 1
    
    ENCRYPT = 2
    
    DECRYPT = 3
    
    CREATE = 4
    
    DELETE = 5
    
    DENY_ACCESS = 6
    
    CHANGE_PERMISSIONS = 7
    


class _UniffiConverterTypeDataEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DataEvent.IMPORT
        if variant == 2:
            return DataEvent.EXPORT
        if variant == 3:
            return DataEvent.ENCRYPT
        if variant == 4:
            return DataEvent.DECRYPT
        if variant == 5:
            return DataEvent.CREATE
        if variant == 6:
            return DataEvent.DELETE
        if variant == 7:
            return DataEvent.DENY_ACCESS
        if variant == 8:
            return DataEvent.CHANGE_PERMISSIONS
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DataEvent.IMPORT:
            return
        if value == DataEvent.EXPORT:
            return
        if value == DataEvent.ENCRYPT:
            return
        if value == DataEvent.DECRYPT:
            return
        if value == DataEvent.CREATE:
            return
        if value == DataEvent.DELETE:
            return
        if value == DataEvent.DENY_ACCESS:
            return
        if value == DataEvent.CHANGE_PERMISSIONS:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == DataEvent.IMPORT:
            buf.write_i32(1)
        if value == DataEvent.EXPORT:
            buf.write_i32(2)
        if value == DataEvent.ENCRYPT:
            buf.write_i32(3)
        if value == DataEvent.DECRYPT:
            buf.write_i32(4)
        if value == DataEvent.CREATE:
            buf.write_i32(5)
        if value == DataEvent.DELETE:
            buf.write_i32(6)
        if value == DataEvent.DENY_ACCESS:
            buf.write_i32(7)
        if value == DataEvent.CHANGE_PERMISSIONS:
            buf.write_i32(8)







class KmsError(enum.Enum):
    """
    Errors originating from or relating to the tenant's KMS
    """

    NO_PRIMARY_KMS_CONFIGURATION = 0
    
    UNKNOWN_TENANT_OR_NO_ACTIVE_KMS_CONFIGURATIONS = 1
    
    KMS_CONFIGURATION_DISABLED = 2
    
    INVALID_PROVIDED_EDEK = 3
    
    KMS_WRAP_FAILED = 4
    
    KMS_UNWRAP_FAILED = 5
    
    KMS_AUTHORIZATION_FAILED = 6
    
    KMS_CONFIGURATION_INVALID = 7
    
    KMS_UNREACHABLE = 8
    
    KMS_THROTTLED = 9
    
    KMS_ACCOUNT_ISSUE = 10
    


class _UniffiConverterTypeKmsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KmsError.NO_PRIMARY_KMS_CONFIGURATION
        if variant == 2:
            return KmsError.UNKNOWN_TENANT_OR_NO_ACTIVE_KMS_CONFIGURATIONS
        if variant == 3:
            return KmsError.KMS_CONFIGURATION_DISABLED
        if variant == 4:
            return KmsError.INVALID_PROVIDED_EDEK
        if variant == 5:
            return KmsError.KMS_WRAP_FAILED
        if variant == 6:
            return KmsError.KMS_UNWRAP_FAILED
        if variant == 7:
            return KmsError.KMS_AUTHORIZATION_FAILED
        if variant == 8:
            return KmsError.KMS_CONFIGURATION_INVALID
        if variant == 9:
            return KmsError.KMS_UNREACHABLE
        if variant == 10:
            return KmsError.KMS_THROTTLED
        if variant == 11:
            return KmsError.KMS_ACCOUNT_ISSUE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KmsError.NO_PRIMARY_KMS_CONFIGURATION:
            return
        if value == KmsError.UNKNOWN_TENANT_OR_NO_ACTIVE_KMS_CONFIGURATIONS:
            return
        if value == KmsError.KMS_CONFIGURATION_DISABLED:
            return
        if value == KmsError.INVALID_PROVIDED_EDEK:
            return
        if value == KmsError.KMS_WRAP_FAILED:
            return
        if value == KmsError.KMS_UNWRAP_FAILED:
            return
        if value == KmsError.KMS_AUTHORIZATION_FAILED:
            return
        if value == KmsError.KMS_CONFIGURATION_INVALID:
            return
        if value == KmsError.KMS_UNREACHABLE:
            return
        if value == KmsError.KMS_THROTTLED:
            return
        if value == KmsError.KMS_ACCOUNT_ISSUE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == KmsError.NO_PRIMARY_KMS_CONFIGURATION:
            buf.write_i32(1)
        if value == KmsError.UNKNOWN_TENANT_OR_NO_ACTIVE_KMS_CONFIGURATIONS:
            buf.write_i32(2)
        if value == KmsError.KMS_CONFIGURATION_DISABLED:
            buf.write_i32(3)
        if value == KmsError.INVALID_PROVIDED_EDEK:
            buf.write_i32(4)
        if value == KmsError.KMS_WRAP_FAILED:
            buf.write_i32(5)
        if value == KmsError.KMS_UNWRAP_FAILED:
            buf.write_i32(6)
        if value == KmsError.KMS_AUTHORIZATION_FAILED:
            buf.write_i32(7)
        if value == KmsError.KMS_CONFIGURATION_INVALID:
            buf.write_i32(8)
        if value == KmsError.KMS_UNREACHABLE:
            buf.write_i32(9)
        if value == KmsError.KMS_THROTTLED:
            buf.write_i32(10)
        if value == KmsError.KMS_ACCOUNT_ISSUE:
            buf.write_i32(11)







class PeriodicEvent(enum.Enum):
    ENFORCE_RETENTION_POLICY = 0
    
    CREATE_BACKUP = 1
    


class _UniffiConverterTypePeriodicEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PeriodicEvent.ENFORCE_RETENTION_POLICY
        if variant == 2:
            return PeriodicEvent.CREATE_BACKUP
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PeriodicEvent.ENFORCE_RETENTION_POLICY:
            return
        if value == PeriodicEvent.CREATE_BACKUP:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PeriodicEvent.ENFORCE_RETENTION_POLICY:
            buf.write_i32(1)
        if value == PeriodicEvent.CREATE_BACKUP:
            buf.write_i32(2)







class SecurityEvent:
    def __init__(self):
        raise RuntimeError("SecurityEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ADMIN:
        event: "AdminEvent"

        def __init__(self,event: "AdminEvent"):
            self.event = event

        def __str__(self):
            return "SecurityEvent.ADMIN(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_admin():
                return False
            if self.event != other.event:
                return False
            return True
    
    class DATA:
        event: "DataEvent"

        def __init__(self,event: "DataEvent"):
            self.event = event

        def __str__(self):
            return "SecurityEvent.DATA(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_data():
                return False
            if self.event != other.event:
                return False
            return True
    
    class PERIODIC:
        event: "PeriodicEvent"

        def __init__(self,event: "PeriodicEvent"):
            self.event = event

        def __str__(self):
            return "SecurityEvent.PERIODIC(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_periodic():
                return False
            if self.event != other.event:
                return False
            return True
    
    class USER:
        event: "UserEvent"

        def __init__(self,event: "UserEvent"):
            self.event = event

        def __str__(self):
            return "SecurityEvent.USER(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_user():
                return False
            if self.event != other.event:
                return False
            return True
    
    class CUSTOM:
        event: "CustomEvent"

        def __init__(self,event: "CustomEvent"):
            self.event = event

        def __str__(self):
            return "SecurityEvent.CUSTOM(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.event != other.event:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_admin(self) -> bool:
        return isinstance(self, SecurityEvent.ADMIN)
    def is_data(self) -> bool:
        return isinstance(self, SecurityEvent.DATA)
    def is_periodic(self) -> bool:
        return isinstance(self, SecurityEvent.PERIODIC)
    def is_user(self) -> bool:
        return isinstance(self, SecurityEvent.USER)
    def is_custom(self) -> bool:
        return isinstance(self, SecurityEvent.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SecurityEvent.ADMIN = type("SecurityEvent.ADMIN", (SecurityEvent.ADMIN, SecurityEvent,), {})  # type: ignore
SecurityEvent.DATA = type("SecurityEvent.DATA", (SecurityEvent.DATA, SecurityEvent,), {})  # type: ignore
SecurityEvent.PERIODIC = type("SecurityEvent.PERIODIC", (SecurityEvent.PERIODIC, SecurityEvent,), {})  # type: ignore
SecurityEvent.USER = type("SecurityEvent.USER", (SecurityEvent.USER, SecurityEvent,), {})  # type: ignore
SecurityEvent.CUSTOM = type("SecurityEvent.CUSTOM", (SecurityEvent.CUSTOM, SecurityEvent,), {})  # type: ignore




class _UniffiConverterTypeSecurityEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SecurityEvent.ADMIN(
                _UniffiConverterTypeAdminEvent.read(buf),
            )
        if variant == 2:
            return SecurityEvent.DATA(
                _UniffiConverterTypeDataEvent.read(buf),
            )
        if variant == 3:
            return SecurityEvent.PERIODIC(
                _UniffiConverterTypePeriodicEvent.read(buf),
            )
        if variant == 4:
            return SecurityEvent.USER(
                _UniffiConverterTypeUserEvent.read(buf),
            )
        if variant == 5:
            return SecurityEvent.CUSTOM(
                _UniffiConverterTypeCustomEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_admin():
            _UniffiConverterTypeAdminEvent.check_lower(value.event)
            return
        if value.is_data():
            _UniffiConverterTypeDataEvent.check_lower(value.event)
            return
        if value.is_periodic():
            _UniffiConverterTypePeriodicEvent.check_lower(value.event)
            return
        if value.is_user():
            _UniffiConverterTypeUserEvent.check_lower(value.event)
            return
        if value.is_custom():
            _UniffiConverterTypeCustomEvent.check_lower(value.event)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_admin():
            buf.write_i32(1)
            _UniffiConverterTypeAdminEvent.write(value.event, buf)
        if value.is_data():
            buf.write_i32(2)
            _UniffiConverterTypeDataEvent.write(value.event, buf)
        if value.is_periodic():
            buf.write_i32(3)
            _UniffiConverterTypePeriodicEvent.write(value.event, buf)
        if value.is_user():
            buf.write_i32(4)
            _UniffiConverterTypeUserEvent.write(value.event, buf)
        if value.is_custom():
            buf.write_i32(5)
            _UniffiConverterTypeCustomEvent.write(value.event, buf)







class SecurityEventError(enum.Enum):
    """
    Errors related to security events
    """

    SECURITY_EVENT_REJECTED = 0
    


class _UniffiConverterTypeSecurityEventError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SecurityEventError.SECURITY_EVENT_REJECTED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SecurityEventError.SECURITY_EVENT_REJECTED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SecurityEventError.SECURITY_EVENT_REJECTED:
            buf.write_i32(1)







class ServiceError(enum.Enum):
    """
    Errors communicating with the TSP
    """

    UNKNOWN_ERROR = 0
    
    UNAUTHORIZED_REQUEST = 1
    
    INVALID_REQUEST_BODY = 2
    


class _UniffiConverterTypeServiceError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ServiceError.UNKNOWN_ERROR
        if variant == 2:
            return ServiceError.UNAUTHORIZED_REQUEST
        if variant == 3:
            return ServiceError.INVALID_REQUEST_BODY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ServiceError.UNKNOWN_ERROR:
            return
        if value == ServiceError.UNAUTHORIZED_REQUEST:
            return
        if value == ServiceError.INVALID_REQUEST_BODY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ServiceError.UNKNOWN_ERROR:
            buf.write_i32(1)
        if value == ServiceError.UNAUTHORIZED_REQUEST:
            buf.write_i32(2)
        if value == ServiceError.INVALID_REQUEST_BODY:
            buf.write_i32(3)







class TenantSecretError(enum.Enum):
    """
    Errors related to tenant secrets
    """

    SECRET_CREATION_FAILED = 0
    


class _UniffiConverterTypeTenantSecretError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TenantSecretError.SECRET_CREATION_FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TenantSecretError.SECRET_CREATION_FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TenantSecretError.SECRET_CREATION_FAILED:
            buf.write_i32(1)







class TenantSecurityProxyError:
    """
    Errors originating from the Tenant Security Proxy.
    These errors are broken into 4 types: service errors, KMS errors,
    security event errors, and tenant secret errors.
    """

    def __init__(self):
        raise RuntimeError("TenantSecurityProxyError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SERVICE:
        error: "ServiceError"

        def __init__(self,error: "ServiceError"):
            self.error = error

        def __str__(self):
            return "TenantSecurityProxyError.SERVICE(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_service():
                return False
            if self.error != other.error:
                return False
            return True
    
    class KMS:
        error: "KmsError"

        def __init__(self,error: "KmsError"):
            self.error = error

        def __str__(self):
            return "TenantSecurityProxyError.KMS(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_kms():
                return False
            if self.error != other.error:
                return False
            return True
    
    class SECURITY_EVENT:
        error: "SecurityEventError"

        def __init__(self,error: "SecurityEventError"):
            self.error = error

        def __str__(self):
            return "TenantSecurityProxyError.SECURITY_EVENT(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_security_event():
                return False
            if self.error != other.error:
                return False
            return True
    
    class TENANT_SECRET:
        error: "TenantSecretError"

        def __init__(self,error: "TenantSecretError"):
            self.error = error

        def __str__(self):
            return "TenantSecurityProxyError.TENANT_SECRET(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_tenant_secret():
                return False
            if self.error != other.error:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_service(self) -> bool:
        return isinstance(self, TenantSecurityProxyError.SERVICE)
    def is_kms(self) -> bool:
        return isinstance(self, TenantSecurityProxyError.KMS)
    def is_security_event(self) -> bool:
        return isinstance(self, TenantSecurityProxyError.SECURITY_EVENT)
    def is_tenant_secret(self) -> bool:
        return isinstance(self, TenantSecurityProxyError.TENANT_SECRET)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TenantSecurityProxyError.SERVICE = type("TenantSecurityProxyError.SERVICE", (TenantSecurityProxyError.SERVICE, TenantSecurityProxyError,), {})  # type: ignore
TenantSecurityProxyError.KMS = type("TenantSecurityProxyError.KMS", (TenantSecurityProxyError.KMS, TenantSecurityProxyError,), {})  # type: ignore
TenantSecurityProxyError.SECURITY_EVENT = type("TenantSecurityProxyError.SECURITY_EVENT", (TenantSecurityProxyError.SECURITY_EVENT, TenantSecurityProxyError,), {})  # type: ignore
TenantSecurityProxyError.TENANT_SECRET = type("TenantSecurityProxyError.TENANT_SECRET", (TenantSecurityProxyError.TENANT_SECRET, TenantSecurityProxyError,), {})  # type: ignore




class _UniffiConverterTypeTenantSecurityProxyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TenantSecurityProxyError.SERVICE(
                _UniffiConverterTypeServiceError.read(buf),
            )
        if variant == 2:
            return TenantSecurityProxyError.KMS(
                _UniffiConverterTypeKmsError.read(buf),
            )
        if variant == 3:
            return TenantSecurityProxyError.SECURITY_EVENT(
                _UniffiConverterTypeSecurityEventError.read(buf),
            )
        if variant == 4:
            return TenantSecurityProxyError.TENANT_SECRET(
                _UniffiConverterTypeTenantSecretError.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_service():
            _UniffiConverterTypeServiceError.check_lower(value.error)
            return
        if value.is_kms():
            _UniffiConverterTypeKmsError.check_lower(value.error)
            return
        if value.is_security_event():
            _UniffiConverterTypeSecurityEventError.check_lower(value.error)
            return
        if value.is_tenant_secret():
            _UniffiConverterTypeTenantSecretError.check_lower(value.error)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_service():
            buf.write_i32(1)
            _UniffiConverterTypeServiceError.write(value.error, buf)
        if value.is_kms():
            buf.write_i32(2)
            _UniffiConverterTypeKmsError.write(value.error, buf)
        if value.is_security_event():
            buf.write_i32(3)
            _UniffiConverterTypeSecurityEventError.write(value.error, buf)
        if value.is_tenant_secret():
            buf.write_i32(4)
            _UniffiConverterTypeTenantSecretError.write(value.error, buf)







class UserEvent(enum.Enum):
    ADD = 0
    
    SUSPEND = 1
    
    REMOVE = 2
    
    LOGIN = 3
    
    TIMEOUT_SESSION = 4
    
    LOCKOUT = 5
    
    LOGOUT = 6
    
    CHANGE_PERMISSIONS = 7
    
    EXPIRE_PASSWORD = 8
    
    RESET_PASSWORD = 9
    
    CHANGE_PASSWORD = 10
    
    REJECT_LOGIN = 11
    
    ENABLE_TWO_FACTOR = 12
    
    DISABLE_TWO_FACTOR = 13
    
    CHANGE_EMAIL = 14
    
    REQUEST_EMAIL_VERIFICATION = 15
    
    VERIFY_EMAIL = 16
    


class _UniffiConverterTypeUserEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UserEvent.ADD
        if variant == 2:
            return UserEvent.SUSPEND
        if variant == 3:
            return UserEvent.REMOVE
        if variant == 4:
            return UserEvent.LOGIN
        if variant == 5:
            return UserEvent.TIMEOUT_SESSION
        if variant == 6:
            return UserEvent.LOCKOUT
        if variant == 7:
            return UserEvent.LOGOUT
        if variant == 8:
            return UserEvent.CHANGE_PERMISSIONS
        if variant == 9:
            return UserEvent.EXPIRE_PASSWORD
        if variant == 10:
            return UserEvent.RESET_PASSWORD
        if variant == 11:
            return UserEvent.CHANGE_PASSWORD
        if variant == 12:
            return UserEvent.REJECT_LOGIN
        if variant == 13:
            return UserEvent.ENABLE_TWO_FACTOR
        if variant == 14:
            return UserEvent.DISABLE_TWO_FACTOR
        if variant == 15:
            return UserEvent.CHANGE_EMAIL
        if variant == 16:
            return UserEvent.REQUEST_EMAIL_VERIFICATION
        if variant == 17:
            return UserEvent.VERIFY_EMAIL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == UserEvent.ADD:
            return
        if value == UserEvent.SUSPEND:
            return
        if value == UserEvent.REMOVE:
            return
        if value == UserEvent.LOGIN:
            return
        if value == UserEvent.TIMEOUT_SESSION:
            return
        if value == UserEvent.LOCKOUT:
            return
        if value == UserEvent.LOGOUT:
            return
        if value == UserEvent.CHANGE_PERMISSIONS:
            return
        if value == UserEvent.EXPIRE_PASSWORD:
            return
        if value == UserEvent.RESET_PASSWORD:
            return
        if value == UserEvent.CHANGE_PASSWORD:
            return
        if value == UserEvent.REJECT_LOGIN:
            return
        if value == UserEvent.ENABLE_TWO_FACTOR:
            return
        if value == UserEvent.DISABLE_TWO_FACTOR:
            return
        if value == UserEvent.CHANGE_EMAIL:
            return
        if value == UserEvent.REQUEST_EMAIL_VERIFICATION:
            return
        if value == UserEvent.VERIFY_EMAIL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == UserEvent.ADD:
            buf.write_i32(1)
        if value == UserEvent.SUSPEND:
            buf.write_i32(2)
        if value == UserEvent.REMOVE:
            buf.write_i32(3)
        if value == UserEvent.LOGIN:
            buf.write_i32(4)
        if value == UserEvent.TIMEOUT_SESSION:
            buf.write_i32(5)
        if value == UserEvent.LOCKOUT:
            buf.write_i32(6)
        if value == UserEvent.LOGOUT:
            buf.write_i32(7)
        if value == UserEvent.CHANGE_PERMISSIONS:
            buf.write_i32(8)
        if value == UserEvent.EXPIRE_PASSWORD:
            buf.write_i32(9)
        if value == UserEvent.RESET_PASSWORD:
            buf.write_i32(10)
        if value == UserEvent.CHANGE_PASSWORD:
            buf.write_i32(11)
        if value == UserEvent.REJECT_LOGIN:
            buf.write_i32(12)
        if value == UserEvent.ENABLE_TWO_FACTOR:
            buf.write_i32(13)
        if value == UserEvent.DISABLE_TWO_FACTOR:
            buf.write_i32(14)
        if value == UserEvent.CHANGE_EMAIL:
            buf.write_i32(15)
        if value == UserEvent.REQUEST_EMAIL_VERIFICATION:
            buf.write_i32(16)
        if value == UserEvent.VERIFY_EMAIL:
            buf.write_i32(17)





class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalFloat(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterFloat.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterFloat.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterFloat.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeStandaloneSecret(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeStandaloneSecret.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeStandaloneSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeStandaloneSecret.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTenantId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTenantId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTenantId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTenantId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceFloat(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterFloat.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterFloat.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterFloat.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeStandaloneSecret(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeStandaloneSecret.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeStandaloneSecret.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeStandaloneSecret.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEncryptedField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEncryptedField.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEncryptedField.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEncryptedField.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEncryptedVector(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEncryptedVector.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEncryptedVector.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEncryptedVector.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypeEncryptedDocument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypeEncryptedDocument.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypeEncryptedDocument.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypeEncryptedDocument.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypePlaintextDocumentWithEdek(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypePlaintextDocumentWithEdek.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypePlaintextDocumentWithEdek.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypePlaintextDocumentWithEdek.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypeAlloyError(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypeAlloyError.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypeAlloyError.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypeAlloyError.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypeEdekWithKeyIdHeader(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypeEdekWithKeyIdHeader.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypeEdekWithKeyIdHeader.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypeEdekWithKeyIdHeader.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypeEncryptedAttachedDocument.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypeEncryptedAttachedDocument.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypeEncryptedAttachedDocument.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypePlaintextAttachedDocument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypePlaintextAttachedDocument.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypePlaintextAttachedDocument.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypePlaintextAttachedDocument.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeDocumentIdTypePlaintextDocument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.check_lower(key)
            _UniffiConverterTypePlaintextDocument.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeDocumentId.write(key, buf)
            _UniffiConverterTypePlaintextDocument.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeDocumentId.read(buf)
            val = _UniffiConverterTypePlaintextDocument.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFieldIdTypeEncryptedField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.check_lower(key)
            _UniffiConverterTypeEncryptedField.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.write(key, buf)
            _UniffiConverterTypeEncryptedField.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFieldId.read(buf)
            val = _UniffiConverterTypeEncryptedField.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFieldIdTypePlaintextField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.check_lower(key)
            _UniffiConverterTypePlaintextField.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.write(key, buf)
            _UniffiConverterTypePlaintextField.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFieldId.read(buf)
            val = _UniffiConverterTypePlaintextField.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFieldIdTypeAlloyError(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.check_lower(key)
            _UniffiConverterTypeAlloyError.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.write(key, buf)
            _UniffiConverterTypeAlloyError.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFieldId.read(buf)
            val = _UniffiConverterTypeAlloyError.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFieldIdSequenceTypeEncryptedField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.check_lower(key)
            _UniffiConverterSequenceTypeEncryptedField.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.write(key, buf)
            _UniffiConverterSequenceTypeEncryptedField.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFieldId.read(buf)
            val = _UniffiConverterSequenceTypeEncryptedField.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFieldIdTypeEncryptedBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.check_lower(key)
            _UniffiConverterTypeEncryptedBytes.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.write(key, buf)
            _UniffiConverterTypeEncryptedBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFieldId.read(buf)
            val = _UniffiConverterTypeEncryptedBytes.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFieldIdTypePlaintextBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.check_lower(key)
            _UniffiConverterTypePlaintextBytes.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFieldId.write(key, buf)
            _UniffiConverterTypePlaintextBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFieldId.read(buf)
            val = _UniffiConverterTypePlaintextBytes.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeSecretPathTypeRotatableSecret(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeSecretPath.check_lower(key)
            _UniffiConverterTypeRotatableSecret.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeSecretPath.write(key, buf)
            _UniffiConverterTypeRotatableSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeSecretPath.read(buf)
            val = _UniffiConverterTypeRotatableSecret.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeSecretPathTypeVectorSecret(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeSecretPath.check_lower(key)
            _UniffiConverterTypeVectorSecret.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeSecretPath.write(key, buf)
            _UniffiConverterTypeVectorSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeSecretPath.read(buf)
            val = _UniffiConverterTypeVectorSecret.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeVectorIdTypeEncryptedVector(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.check_lower(key)
            _UniffiConverterTypeEncryptedVector.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.write(key, buf)
            _UniffiConverterTypeEncryptedVector.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeVectorId.read(buf)
            val = _UniffiConverterTypeEncryptedVector.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeVectorIdTypePlaintextVector(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.check_lower(key)
            _UniffiConverterTypePlaintextVector.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.write(key, buf)
            _UniffiConverterTypePlaintextVector.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeVectorId.read(buf)
            val = _UniffiConverterTypePlaintextVector.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeVectorIdTypeAlloyError(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.check_lower(key)
            _UniffiConverterTypeAlloyError.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.write(key, buf)
            _UniffiConverterTypeAlloyError.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeVectorId.read(buf)
            val = _UniffiConverterTypeAlloyError.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeVectorIdSequenceTypeEncryptedVector(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.check_lower(key)
            _UniffiConverterSequenceTypeEncryptedVector.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeVectorId.write(key, buf)
            _UniffiConverterSequenceTypeEncryptedVector.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeVectorId.read(buf)
            val = _UniffiConverterSequenceTypeEncryptedVector.read(buf)
            d[key] = val
        return d


class _UniffiConverterTypeDerivationPath:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeDocumentId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeEdekWithKeyIdHeader:
    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterTypeEncryptedBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterTypeEncryptedBytes.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterTypeEncryptedBytes.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterTypeEncryptedBytes.lower(value)


class _UniffiConverterTypeEncryptedAttachedDocument:
    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEncryptedBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterTypeEncryptedBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterTypeEncryptedBytes.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterTypeEncryptedBytes.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterTypeEncryptedBytes.lower(value)


class _UniffiConverterTypeEncryptedAttachedDocuments:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedAttachedDocument.lower(value)


class _UniffiConverterTypeEncryptedBytes:
    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterBytes.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterBytes.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterBytes.lower(value)


class _UniffiConverterTypeEncryptedDocuments:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypeEncryptedDocument.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedDocument.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedDocument.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedDocument.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeDocumentIdTypeEncryptedDocument.lower(value)


class _UniffiConverterTypeEncryptedFields:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeFieldIdTypeEncryptedField.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeFieldIdTypeEncryptedField.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeFieldIdTypeEncryptedField.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeFieldIdTypeEncryptedField.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeFieldIdTypeEncryptedField.lower(value)


class _UniffiConverterTypeEncryptedVectors:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeVectorIdTypeEncryptedVector.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeVectorIdTypeEncryptedVector.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeVectorIdTypeEncryptedVector.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeVectorIdTypeEncryptedVector.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeVectorIdTypeEncryptedVector.lower(value)


class _UniffiConverterTypeFieldId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeGenerateFieldQueryResult:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeFieldIdSequenceTypeEncryptedField.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeFieldIdSequenceTypeEncryptedField.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeFieldIdSequenceTypeEncryptedField.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeFieldIdSequenceTypeEncryptedField.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeFieldIdSequenceTypeEncryptedField.lower(value)


class _UniffiConverterTypeGenerateVectorQueryResult:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeVectorIdSequenceTypeEncryptedVector.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeVectorIdSequenceTypeEncryptedVector.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeVectorIdSequenceTypeEncryptedVector.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeVectorIdSequenceTypeEncryptedVector.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeVectorIdSequenceTypeEncryptedVector.lower(value)


class _UniffiConverterTypePlaintextAttachedDocument:
    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePlaintextBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterTypePlaintextBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterTypePlaintextBytes.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterTypePlaintextBytes.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterTypePlaintextBytes.lower(value)


class _UniffiConverterTypePlaintextAttachedDocuments:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypePlaintextAttachedDocument.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextAttachedDocument.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextAttachedDocument.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextAttachedDocument.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextAttachedDocument.lower(value)


class _UniffiConverterTypePlaintextBytes:
    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterBytes.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterBytes.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterBytes.lower(value)


class _UniffiConverterTypePlaintextDocument:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeFieldIdTypePlaintextBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeFieldIdTypePlaintextBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeFieldIdTypePlaintextBytes.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeFieldIdTypePlaintextBytes.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeFieldIdTypePlaintextBytes.lower(value)


class _UniffiConverterTypePlaintextDocuments:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypePlaintextDocument.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocument.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocument.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocument.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocument.lower(value)


class _UniffiConverterTypePlaintextDocumentsWithEdeks:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeDocumentIdTypePlaintextDocumentWithEdek.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocumentWithEdek.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocumentWithEdek.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocumentWithEdek.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeDocumentIdTypePlaintextDocumentWithEdek.lower(value)


class _UniffiConverterTypePlaintextFields:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeFieldIdTypePlaintextField.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeFieldIdTypePlaintextField.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeFieldIdTypePlaintextField.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeFieldIdTypePlaintextField.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeFieldIdTypePlaintextField.lower(value)


class _UniffiConverterTypePlaintextVectors:
    @staticmethod
    def write(value, buf):
        _UniffiConverterMapTypeVectorIdTypePlaintextVector.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterMapTypeVectorIdTypePlaintextVector.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterMapTypeVectorIdTypePlaintextVector.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterMapTypeVectorIdTypePlaintextVector.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterMapTypeVectorIdTypePlaintextVector.lower(value)


class _UniffiConverterTypeSecretPath:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeTenantId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeVectorId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)
DerivationPath = str
DocumentId = str
EncryptedBytes = bytes
EdekWithKeyIdHeader = EncryptedBytes
EncryptedAttachedDocument = EncryptedBytes
EncryptedAttachedDocuments = dict[DocumentId, EncryptedAttachedDocument]
EncryptedDocuments = dict[DocumentId, EncryptedDocument]
FieldId = str
EncryptedFields = dict[FieldId, EncryptedField]
VectorId = str
EncryptedVectors = dict[VectorId, EncryptedVector]
GenerateFieldQueryResult = dict[FieldId, typing.List[EncryptedField]]
GenerateVectorQueryResult = dict[VectorId, typing.List[EncryptedVector]]
PlaintextBytes = bytes
PlaintextAttachedDocument = PlaintextBytes
PlaintextAttachedDocuments = dict[DocumentId, PlaintextAttachedDocument]
PlaintextDocument = dict[FieldId, PlaintextBytes]
PlaintextDocuments = dict[DocumentId, PlaintextDocument]
PlaintextDocumentsWithEdeks = dict[DocumentId, PlaintextDocumentWithEdek]
PlaintextFields = dict[FieldId, PlaintextField]
PlaintextVectors = dict[VectorId, PlaintextVector]
SecretPath = str
TenantId = str

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

__all__ = [
    "InternalError",
    "AdminEvent",
    "AlloyError",
    "DataEvent",
    "KmsError",
    "PeriodicEvent",
    "SecurityEvent",
    "SecurityEventError",
    "ServiceError",
    "TenantSecretError",
    "TenantSecurityProxyError",
    "UserEvent",
    "CustomEvent",
    "DeterministicDecryptBatchResult",
    "DeterministicEncryptBatchResult",
    "DeterministicRotateResult",
    "EncryptedDocument",
    "EncryptedField",
    "EncryptedVector",
    "PlaintextDocumentWithEdek",
    "PlaintextField",
    "PlaintextVector",
    "RekeyAttachedDocumentsBatchResult",
    "RekeyEdeksBatchResult",
    "StandardAttachedDecryptBatchResult",
    "StandardAttachedEncryptBatchResult",
    "StandardDecryptBatchResult",
    "StandardEncryptBatchResult",
    "VectorDecryptBatchResult",
    "VectorEncryptBatchResult",
    "VectorRotateResult",
    "AlloyMetadata",
    "RotatableSecret",
    "SaasShield",
    "SaasShieldConfiguration",
    "SaasShieldDeterministicClient",
    "SaasShieldStandardAttachedClient",
    "SaasShieldStandardClient",
    "SaasShieldVectorClient",
    "Secret",
    "Standalone",
    "StandaloneConfiguration",
    "StandaloneDeterministicClient",
    "StandaloneSecret",
    "StandaloneStandardAttachedClient",
    "StandaloneStandardClient",
    "StandaloneVectorClient",
    "StandardSecrets",
    "VectorSecret",
]

