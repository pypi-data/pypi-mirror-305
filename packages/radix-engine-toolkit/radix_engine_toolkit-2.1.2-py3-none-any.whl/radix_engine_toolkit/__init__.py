# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(
            _UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc, size
        )

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(
            _UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve,
            rbuf,
            additional,
        )

    def free(self):
        return _rust_call(
            _UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_free, self
        )

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity, self.len, self.data[0 : self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(
                    "junk data left in buffer at end of consume_with_stream"
                )
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")


class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(
            self.len, self.data[0 : self.len]
        )


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset : self.offset + size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset : self.offset + size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t), "@N")


class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t), "@N", v)


# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.


class InternalError(Exception):
    pass


class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """

    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"


def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)


def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(
        code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None)
    )

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result


def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError(
                "_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None"
            )
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError(
            "Invalid _UniffiRustCallStatus code: {}".format(call_status.code)
        )


# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(
    ctypes.c_int,
    ctypes.c_ulonglong,
    ctypes.c_ulong,
    ctypes.POINTER(ctypes.c_char),
    ctypes.c_int,
    ctypes.POINTER(_UniffiRustBuffer),
)

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)


class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value


class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]


# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == "CPython":
    _UniffiPointerManager = _UniffiPointerManagerCPython  # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral  # type: ignore


# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)


class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError(
                "'{}' object cannot be interpreted as an integer".format(
                    type(value).__name__
                )
            )
        if not isinstance(value, int):
            raise TypeError(
                "__index__ returned non-int (type {})".format(type(value).__name__)
            )
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError(
                "{} requires {} <= value < {}".format(
                    cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX
                )
            )
        return super().check(value)


class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError(
                "__float__ returned non-float (type {})".format(type(value).__name__)
            )
        return super().check(value)


# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()


# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(
    ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p
)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)


def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)


def _uniffi_load_indirect() -> ctypes.CDLL:
    """
    This is how we find and load the dynamic library provided by the component.
    The dynamic library is assumed to exist right beside the code and it's name if the same as the
    target triple.

    Currently, the supported architectures are:
    * x86-64 and Arm64 Apple Darwin
    * x86-64 and Arm64 Linux GNU
    * x86-64 Win64
    """

    def library_file_name() -> str:
        is_x86: bool = platform.machine() in ("AMD64", "x86_64")
        is_arm: bool = platform.machine() in ("arm64", "aarch64")
        system: str = platform.system()

        if is_x86 and system == "Darwin":
            return "x86_64-apple-darwin"
        elif is_arm and system == "Darwin":
            return "aarch64-apple-darwin"
        elif is_x86 and system == "Linux":
            return "x86_64-unknown-linux-gnu"
        elif is_arm and system == "Linux":
            return "aarch64-unknown-linux-gnu"
        elif is_x86 and system == "Windows":
            return "x86_64-pc-windows-gnu.dll"
        else:
            raise NotImplemented(
                f"No implementation of the Radix Engine Toolkit is available on your platform. Information detected: is_x86: {is_x86}, is_arm: {is_arm}, os: {system}"
            )

    file_name: str = library_file_name()
    path: str = os.path.join(os.path.dirname(__file__), file_name)
    return ctypes.cdll.LoadLibrary(path)


def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 24
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = (
        lib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version()
    )
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError(
            "UniFFI contract version mismatch: try cleaning and rebuilding your project"
        )


def _uniffi_check_api_checksums(lib):
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key()
        != 19647
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address()
        != 45205
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address()
        != 11639
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address()
        != 24509
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key()
        != 36758
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_global_caller_non_fungible_global_id_from_component_address()
        != 55602
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key()
        != 11003
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address()
        != 42759
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key()
        != 61146
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_build_information()
        != 61037
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_hash() != 23353:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_known_addresses()
        != 16556
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation()
        != 19578
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode()
        != 54114
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode()
        != 11090
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str()
        != 10663
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str()
        != 27404
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode()
        != 5482
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode()
        != 44017
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_from_vec()
        != 41521
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_to_vec()
        != 4950
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation()
        != 11831
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event()
        != 43789
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation()
        != 50232
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation()
        != 24947
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic() != 25407:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and() != 5785:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or() != 27266:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string()
        != 5709
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str() != 38197:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes() != 16699:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type()
        != 40172
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global()
        != 25808
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component()
        != 58252
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager()
        != 48841
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager()
        != 55847
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager()
        != 16959
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package()
        != 10761
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager()
        != 34705
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual()
        != 44552
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal()
        != 34745
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault()
        != 26605
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store()
        != 4366
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault()
        != 30524
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault()
        != 10507
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id()
        != 20026
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs() != 31072:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add() != 42883:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str() != 18253:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt() != 18756:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling()
        != 62165
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div() != 25038:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal() != 45597:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor() != 31716:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than()
        != 16609
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal()
        != 3170
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative()
        != 27762
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive()
        != 15349
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero()
        != 27694
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than()
        != 30546
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal()
        != 2387
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mantissa()
        != 41794
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul() != 18912:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal()
        != 61801
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root()
        != 6178
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi() != 35861:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round() != 31873:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt() != 43295:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub() != 26365:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_to_le_bytes()
        != 17037
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str() != 46597:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes() != 57303:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str()
        != 2403
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list()
        != 45845
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id()
        != 55489
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile() != 31325:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash() != 993:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header() != 49719:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash()
        != 63530
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest()
        != 60823
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message() != 49610:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate()
        != 18502
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_primary_role_badge_withdraw_attempt()
        != 48569
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_primary_role_recovery_proposal()
        != 15034
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_recovery_role_badge_withdraw_attempt()
        != 302
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_recovery_role_recovery_proposal()
        != 29975
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create()
        != 58316
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create_proof()
        != 64981
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create_with_security_structure()
        != 28637
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_primary()
        != 61645
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_recovery()
        != 57712
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery_as_primary()
        != 20119
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery_as_recovery()
        != 33445
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_lock_primary_role()
        != 31780
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_mint_recovery_badges()
        != 4851
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_new_from_public_keys()
        != 6146
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt()
        != 12412
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_primary_role_recovery_proposal()
        != 45088
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt()
        != 17833
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery_role_recovery_proposal()
        != 62781
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_stop_timed_recovery()
        != 34245
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_timed_confirm_recovery()
        != 45733
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_unlock_primary_role()
        != 30029
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_add_authorized_depositor()
        != 59221
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_burn()
        != 64728
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_burn_non_fungibles()
        != 40710
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create()
        != 6013
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_advanced()
        != 54940
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_proof_of_amount()
        != 17393
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_proof_of_non_fungibles()
        != 43091
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit()
        != 3687
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch()
        != 43520
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_entire_worktop()
        != 59635
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_contingent_fee()
        != 54668
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee()
        != 38082
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee_and_withdraw()
        != 19367
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee_and_withdraw_non_fungibles()
        != 46012
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_airdrop()
        != 40671
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_claim()
        != 20662
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_claim_non_fungibles()
        != 38683
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_get_amount()
        != 29397
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_get_non_fungible_local_ids()
        != 23927
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_instantiate()
        != 7727
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_instantiate_simple()
        != 65307
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_recover()
        != 2999
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_recover_non_fungibles()
        != 65115
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_store()
        != 40050
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_remove_authorized_depositor()
        != 17654
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_remove_resource_preference()
        != 57432
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_securify()
        != 20811
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_set_default_deposit_rule()
        != 28798
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_set_resource_preference()
        != 24940
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort()
        != 18649
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund()
        != 34909
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_entire_worktop_or_abort()
        != 42658
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_entire_worktop_or_refund()
        != 9020
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort()
        != 21998
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund()
        != 39086
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_withdraw()
        != 29156
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_withdraw_non_fungibles()
        != 56678
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address()
        != 18604
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains()
        != 37738
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any()
        != 20665
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles()
        != 58282
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build()
        != 36705
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource()
        != 52445
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method()
        != 19399
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method()
        != 53674
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function()
        != 38619
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method()
        != 42239
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method()
        != 39370
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method()
        != 25488
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof()
        != 52407
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager()
        != 45955
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all()
        != 51538
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount()
        != 51265
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles()
        != 49166
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all()
        != 46129
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount()
        != 20827
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles()
        != 25333
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs()
        != 12341
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs()
        != 63484
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs()
        != 2952
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof()
        != 29894
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd()
        != 59721
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee()
        != 5856
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_create()
        != 22657
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_create_advanced()
        != 53046
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_securify()
        != 24322
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_get()
        != 37782
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_lock()
        != 53375
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_remove()
        != 30456
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_set()
        != 11186
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible()
        != 41635
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_contribute()
        != 54648
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_get_redemption_value()
        != 1278
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_get_vault_amount()
        != 53964
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_instantiate()
        != 17825
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_protected_deposit()
        != 10939
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_protected_withdraw()
        != 3505
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_redeem()
        != 16912
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_contribute()
        != 25120
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_get_redemption_value()
        != 27814
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_get_vault_amount()
        != 37942
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_instantiate()
        != 5474
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_protected_deposit()
        != 1325
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_protected_withdraw()
        != 47007
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_redeem()
        != 16139
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_claim_royalty()
        != 54897
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_publish()
        != 43039
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_publish_advanced()
        != 7234
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone()
        != 54385
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone()
        != 59668
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop()
        != 48542
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_get()
        != 57962
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_lock_owner()
        != 26186
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_set()
        != 27207
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_set_owner()
        != 64161
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_claim()
        != 23601
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_lock()
        != 50599
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_set()
        != 26584
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop()
        != 61948
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop()
        != 7334
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop()
        != 49676
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_contribute()
        != 3256
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_get_redemption_value()
        != 41038
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_get_vault_amount()
        != 44545
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_instantiate()
        != 22784
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_protected_deposit()
        != 8937
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_protected_withdraw()
        != 35351
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_redeem()
        != 4503
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_accepts_delegated_stake()
        != 63411
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_claim_xrd()
        != 13361
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_finish_unlock_owner_stake_units()
        != 24114
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_get_protocol_update_readiness()
        != 56572
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_get_redemption_value()
        != 30890
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_lock_owner_stake_units()
        != 26840
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_register()
        != 38592
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_signal_protocol_update_readiness()
        != 41037
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_stake()
        != 46849
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_stake_as_owner()
        != 43974
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_start_unlock_owner_stake_units()
        != 53351
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_total_stake_unit_supply()
        != 14885
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_total_stake_xrd_amount()
        != 44141
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_unregister()
        != 55641
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_unstake()
        != 53557
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_accept_delegated_stake()
        != 38363
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_fee()
        != 10602
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_key()
        != 41122
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors()
        != 45350
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length()
        != 10753
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length()
        != 15824
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length()
        != 53437
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str()
        != 12617
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id()
        != 42729
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address()
        != 26038
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile()
        != 65183
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash()
        != 64270
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash()
        != 51688
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash()
        != 17757
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature()
        != 46873
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent()
        != 11409
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash()
        != 60604
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate()
        != 11188
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str()
        != 211
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key()
        != 33649
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs()
        != 753
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add()
        != 50067
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str()
        != 50135
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt()
        != 31353
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling()
        != 6632
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div()
        != 47336
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal()
        != 35658
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor()
        != 6297
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than()
        != 21292
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal()
        != 34931
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative()
        != 11588
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive()
        != 30868
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero()
        != 41566
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than()
        != 50862
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal()
        != 33893
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mantissa()
        != 2374
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul()
        != 35568
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal()
        != 17368
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root()
        != 60037
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi()
        != 57119
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round()
        != 22122
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt()
        != 18565
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub()
        != 2969
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_to_le_bytes()
        != 6841
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_curve()
        != 56035
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key()
        != 49403
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key_bytes()
        != 8464
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw() != 43216:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw_hex()
        != 64460
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign()
        != 21427
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature()
        != 4246
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key()
        != 41168
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile()
        != 26394
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash()
        != 60260
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent()
        != 19540
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash()
        != 9462
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures()
        != 46037
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash()
        != 20757
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate()
        != 27682
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header()
        != 40383
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest()
        != 8446
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key()
        != 57025
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer()
        != 32547
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key()
        != 29671
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer()
        != 17372
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message()
        != 55782
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key()
        != 60073
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer()
        != 21713
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash()
        != 1343
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str()
        != 9829
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes()
        != 40875
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id()
        != 4187
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs()
        != 55127
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_compile()
        != 11452
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_execution_summary()
        != 6206
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses()
        != 5474
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions()
        != 3783
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify()
        != 4850
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate()
        != 42656
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_summary()
        != 53923
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range()
        != 31430
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size()
        != 39564
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage()
        != 28981
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation()
        != 52946
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage()
        != 2069
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id()
        != 63098
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all()
        != 26074
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all()
        != 40312
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require()
        != 10110
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of()
        != 11748
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount()
        != 34714
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of()
        != 30352
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of()
        != 59472
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature()
        != 41270
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw()
        != 43797
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new()
        != 37549
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address()
        != 64771
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address()
        != 31070
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key()
        != 738
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key()
        != 32432
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_from_le_bytes()
        != 14760
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max()
        != 38313
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min()
        != 18079
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new()
        != 15617
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one()
        != 42470
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero()
        != 39451
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string()
        != 64410
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes()
        != 17030
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new() != 17594:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_sbor_decode()
        != 26443
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions()
        != 51039
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string()
        != 47420
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile()
        != 565
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new() != 4284:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new()
        != 30710
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default()
        != 54905
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new()
        != 60275
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts()
        != 36478
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_global_caller_badge()
        != 5635
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new()
        != 58056
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_package_of_direct_caller_badge()
        != 11141
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge()
        != 22546
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile()
        != 58667
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new()
        != 56154
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new()
        != 12724
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_from_le_bytes()
        != 24547
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max()
        != 49495
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min()
        != 4453
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new()
        != 34846
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one()
        != 9121
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero()
        != 5648
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new()
        != 47612
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519()
        != 4005
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1()
        != 20991
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile()
        != 12765
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new()
        != 36392
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new()
        != 46196
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilderintentsignaturesstep_new()
        != 17229
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str()
        != 37610
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_decompile()
        != 51209
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new()
        != 62865
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default()
        != 1435
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new()
        != 36594
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign() != 46892:
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature()
        != 15804
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key()
        != 9393
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )
    if (
        lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key()
        != 61195
    ):
        raise InternalError(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project"
        )


# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of.argtypes = (
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_address.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id.restype = (
    ctypes.c_uint8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_from_le_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_from_le_bytes.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mantissa.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mantissa.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_to_le_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_to_le_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_hash.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_sbor_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_sbor_decode.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id.restype = (
    ctypes.c_uint8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_intent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_intent.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_primary_role_badge_withdraw_attempt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_primary_role_badge_withdraw_attempt.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_primary_role_recovery_proposal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_primary_role_recovery_proposal.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_recovery_role_badge_withdraw_attempt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_recovery_role_badge_withdraw_attempt.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_recovery_role_recovery_proposal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_recovery_role_recovery_proposal.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create_proof.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create_with_security_structure.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create_with_security_structure.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_primary.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_primary.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_recovery.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_recovery.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery_as_primary.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery_as_primary.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery_as_recovery.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery_as_recovery.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_lock_primary_role.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_lock_primary_role.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_mint_recovery_badges.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_mint_recovery_badges.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_new_from_public_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_new_from_public_keys.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_primary_role_recovery_proposal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_primary_role_recovery_proposal.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery_role_recovery_proposal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery_role_recovery_proposal.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_stop_timed_recovery.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_stop_timed_recovery.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_timed_confirm_recovery.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_timed_confirm_recovery.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_unlock_primary_role.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_unlock_primary_role.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_add_authorized_depositor.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_add_authorized_depositor.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_burn.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_burn.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_burn_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_burn_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_advanced.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_advanced.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_proof_of_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_proof_of_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_proof_of_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_proof_of_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_entire_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_entire_worktop.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_contingent_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_contingent_fee.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee_and_withdraw.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee_and_withdraw.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee_and_withdraw_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee_and_withdraw_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_airdrop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_airdrop.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_claim.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_claim.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_claim_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_claim_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_get_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_get_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_get_non_fungible_local_ids.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_get_non_fungible_local_ids.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_instantiate.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_instantiate.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_instantiate_simple.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_instantiate_simple.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_recover.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_recover.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_recover_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_recover_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_store.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_store.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_remove_authorized_depositor.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_remove_authorized_depositor.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_remove_resource_preference.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_remove_resource_preference.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_securify.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_securify.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_set_default_deposit_rule.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_set_default_deposit_rule.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_set_resource_preference.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_set_resource_preference.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_entire_worktop_or_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_entire_worktop_or_abort.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_entire_worktop_or_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_entire_worktop_or_refund.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_withdraw.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_withdraw.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_withdraw_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_withdraw_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_create.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_create.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_create_advanced.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_create_advanced.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_securify.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_securify.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_get.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_get.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_lock.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_lock.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_remove.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_remove.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_set.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_contribute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_contribute.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_get_redemption_value.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_get_redemption_value.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_get_vault_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_get_vault_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_instantiate.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_instantiate.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_protected_deposit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_protected_deposit.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_protected_withdraw.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_protected_withdraw.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_redeem.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_redeem.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_contribute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_contribute.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_get_redemption_value.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_get_redemption_value.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_get_vault_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_get_vault_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_instantiate.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_instantiate.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_protected_deposit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_protected_deposit.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_protected_withdraw.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_protected_withdraw.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_redeem.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_redeem.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_claim_royalty.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_claim_royalty.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_publish.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_publish.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_publish_advanced.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_publish_advanced.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_get.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_get.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_lock_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_lock_owner.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_set.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_set_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_set_owner.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_claim.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_claim.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_lock.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_lock.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_set.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_contribute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_contribute.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_get_redemption_value.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_get_redemption_value.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_get_vault_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_get_vault_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_instantiate.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_instantiate.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_protected_deposit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_protected_deposit.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_protected_withdraw.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_protected_withdraw.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_redeem.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_redeem.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_accepts_delegated_stake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_accepts_delegated_stake.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_claim_xrd.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_claim_xrd.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_finish_unlock_owner_stake_units.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_finish_unlock_owner_stake_units.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_get_protocol_update_readiness.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_get_protocol_update_readiness.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_get_redemption_value.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_get_redemption_value.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_lock_owner_stake_units.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_lock_owner_stake_units.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_register.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_register.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_signal_protocol_update_readiness.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_signal_protocol_update_readiness.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_stake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_stake.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_stake_as_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_stake_as_owner.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_start_unlock_owner_stake_units.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_start_unlock_owner_stake_units.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_total_stake_unit_supply.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_total_stake_unit_supply.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_total_stake_xrd_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_total_stake_xrd_amount.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_unregister.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_unregister.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_unstake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_unstake.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_accept_delegated_stake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_accept_delegated_stake.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_fee.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors.restype = (
    ctypes.c_uint64
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length.restype = (
    ctypes.c_uint64
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length.restype = (
    ctypes.c_uint64
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length.restype = (
    ctypes.c_uint64
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_global_caller_badge.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_global_caller_badge.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_package_of_direct_caller_badge.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_package_of_direct_caller_badge.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_from_le_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_from_le_bytes.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mantissa.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mantissa.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal.restype = (
    ctypes.c_int8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_to_le_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_to_le_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_curve.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_curve.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw_hex.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilderintentsignaturesstep_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilderintentsignaturesstep_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id.restype = (
    ctypes.c_uint8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_decompile.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_compile.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_execution_summary.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_execution_summary.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate.restype = (
    None
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_summary.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_summary.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new.argtypes = (
    ctypes.c_uint8,
    ctypes.c_uint64,
    ctypes.c_uint16,
    ctypes.c_uint16,
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range.restype = (
    ctypes.c_uint64
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size.restype = (
    ctypes.c_uint64
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id.restype = (
    ctypes.c_uint8
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_global_caller_non_fungible_global_id_from_component_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_global_caller_non_fungible_global_id_from_component_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key.restype = (
    ctypes.c_void_p
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_build_information.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_build_information.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_hash.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_known_addresses.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_known_addresses.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_from_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_from_vec.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_to_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_to_vec.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation.restype = (
    _UniffiRustBuffer
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes.restype = (
    _UniffiRustBuffer
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_free.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve.restype = (
    _UniffiRustBuffer
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_continuation_callback_set.argtypes = (
    _UNIFFI_FUTURE_CONTINUATION_T,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_continuation_callback_set.restype = (
    None
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u8.restype = (
    ctypes.c_uint8
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i8.restype = (
    ctypes.c_int8
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u16.restype = (
    ctypes.c_uint16
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i16.restype = (
    ctypes.c_int16
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u32.restype = (
    ctypes.c_uint32
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i32.restype = (
    ctypes.c_int32
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_u64.restype = (
    ctypes.c_uint64
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_i64.restype = (
    ctypes.c_int64
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_f32.restype = (
    ctypes.c_float
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_f64.restype = (
    ctypes.c_double
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_pointer.restype = (
    ctypes.c_void_p
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_rust_buffer.restype = (
    _UniffiRustBuffer
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_free_void.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_global_caller_non_fungible_global_id_from_component_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_global_caller_non_fungible_global_id_from_component_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_build_information.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_build_information.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_known_addresses.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_get_known_addresses.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_from_vec.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_from_vec.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_to_vec.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_public_key_fingerprint_to_vec.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mantissa.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mantissa.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_to_le_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_to_le_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_primary_role_badge_withdraw_attempt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_primary_role_badge_withdraw_attempt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_primary_role_recovery_proposal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_primary_role_recovery_proposal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_recovery_role_badge_withdraw_attempt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_recovery_role_badge_withdraw_attempt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_recovery_role_recovery_proposal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_cancel_recovery_role_recovery_proposal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create_proof.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create_proof.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create_with_security_structure.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_create_with_security_structure.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_primary.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_primary.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_recovery.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_recovery.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery_as_primary.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery_as_primary.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery_as_recovery.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery_as_recovery.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_lock_primary_role.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_lock_primary_role.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_mint_recovery_badges.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_mint_recovery_badges.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_new_from_public_keys.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_new_from_public_keys.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_primary_role_recovery_proposal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_primary_role_recovery_proposal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery_role_recovery_proposal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery_role_recovery_proposal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_stop_timed_recovery.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_stop_timed_recovery.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_timed_confirm_recovery.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_timed_confirm_recovery.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_unlock_primary_role.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_unlock_primary_role.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_add_authorized_depositor.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_add_authorized_depositor.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_burn.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_burn.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_burn_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_burn_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_advanced.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_advanced.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_proof_of_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_proof_of_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_proof_of_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_create_proof_of_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_entire_worktop.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_entire_worktop.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_contingent_fee.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_contingent_fee.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee_and_withdraw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee_and_withdraw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee_and_withdraw_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_lock_fee_and_withdraw_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_airdrop.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_airdrop.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_claim.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_claim.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_claim_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_claim_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_get_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_get_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_get_non_fungible_local_ids.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_get_non_fungible_local_ids.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_instantiate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_instantiate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_instantiate_simple.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_instantiate_simple.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_recover.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_recover.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_recover_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_recover_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_store.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_locker_store.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_remove_authorized_depositor.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_remove_authorized_depositor.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_remove_resource_preference.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_remove_resource_preference.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_securify.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_securify.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_set_default_deposit_rule.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_set_default_deposit_rule.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_set_resource_preference.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_set_resource_preference.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_entire_worktop_or_abort.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_entire_worktop_or_abort.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_entire_worktop_or_refund.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_entire_worktop_or_refund.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_withdraw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_withdraw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_withdraw_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_withdraw_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_create.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_create.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_create_advanced.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_create_advanced.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_securify.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_identity_securify.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_get.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_get.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_lock.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_lock.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_remove.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_remove.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_set.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_metadata_set.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_contribute.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_contribute.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_get_redemption_value.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_get_redemption_value.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_get_vault_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_get_vault_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_instantiate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_instantiate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_protected_deposit.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_protected_deposit.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_protected_withdraw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_protected_withdraw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_redeem.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_multi_resource_pool_redeem.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_contribute.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_contribute.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_get_redemption_value.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_get_redemption_value.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_get_vault_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_get_vault_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_instantiate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_instantiate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_protected_deposit.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_protected_deposit.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_protected_withdraw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_protected_withdraw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_redeem.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_one_resource_pool_redeem.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_claim_royalty.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_claim_royalty.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_publish.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_publish.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_publish_advanced.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_package_publish_advanced.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_get.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_get.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_lock_owner.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_lock_owner.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_set.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_set.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_set_owner.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_role_assignment_set_owner.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_claim.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_claim.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_lock.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_lock.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_set.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_royalty_set.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_contribute.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_contribute.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_get_redemption_value.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_get_redemption_value.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_get_vault_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_get_vault_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_instantiate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_instantiate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_protected_deposit.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_protected_deposit.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_protected_withdraw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_protected_withdraw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_redeem.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_two_resource_pool_redeem.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_accepts_delegated_stake.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_accepts_delegated_stake.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_claim_xrd.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_claim_xrd.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_finish_unlock_owner_stake_units.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_finish_unlock_owner_stake_units.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_get_protocol_update_readiness.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_get_protocol_update_readiness.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_get_redemption_value.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_get_redemption_value.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_lock_owner_stake_units.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_lock_owner_stake_units.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_register.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_register.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_signal_protocol_update_readiness.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_signal_protocol_update_readiness.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_stake.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_stake.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_stake_as_owner.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_stake_as_owner.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_start_unlock_owner_stake_units.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_start_unlock_owner_stake_units.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_total_stake_unit_supply.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_total_stake_unit_supply.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_total_stake_xrd_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_total_stake_xrd_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_unregister.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_unregister.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_unstake.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_unstake.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_accept_delegated_stake.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_accept_delegated_stake.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_fee.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_fee.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_validator_update_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mantissa.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mantissa.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_to_le_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_to_le_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_curve.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_curve.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw_hex.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_raw_hex.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_compile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_compile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_execution_summary.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_execution_summary.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_summary.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_summary.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_from_le_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_from_le_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_sbor_decode.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_sbor_decode.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_global_caller_badge.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_global_caller_badge.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_package_of_direct_caller_badge.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_package_of_direct_caller_badge.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_from_le_bytes.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_from_le_bytes.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilderintentsignaturesstep_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilderintentsignaturesstep_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_decompile.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_decompile.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key.argtypes = ()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key.restype = (
    ctypes.c_uint16
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version.argtypes = ()
_UniffiLib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version.restype = (
    ctypes.c_uint32
)
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u8(value)


class _UniffiConverterInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i8"
    VALUE_MIN = -(2**7)
    VALUE_MAX = 2**7

    @staticmethod
    def read(buf):
        return buf.read_i8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i8(value)


class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u16(value)


class _UniffiConverterInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i16"
    VALUE_MIN = -(2**15)
    VALUE_MAX = 2**15

    @staticmethod
    def read(buf):
        return buf.read_i16()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i16(value)


class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u32(value)


class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -(2**31)
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i32(value)


class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u64(value)


class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -(2**63)
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i64(value)


class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0


class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()


class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def write(value, buf):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError(
                "a bytes-like object is required, not {!r}".format(type(value).__name__)
            )
        buf.write_i32(len(value))
        buf.write(value)


class AccessRule:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def allow_all(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def deny_all(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def require(cls, resource_or_non_fungible: "ResourceOrNonFungible"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require,
            _UniffiConverterTypeResourceOrNonFungible.lower(resource_or_non_fungible),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def require_all_of(cls, resources: "typing.List[ResourceOrNonFungible]"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of,
            _UniffiConverterSequenceTypeResourceOrNonFungible.lower(resources),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def require_amount(cls, amount: "Decimal", resource: "Address"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount,
            _UniffiConverterTypeDecimal.lower(amount),
            _UniffiConverterTypeAddress.lower(resource),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def require_any_of(cls, resources: "typing.List[ResourceOrNonFungible]"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of,
            _UniffiConverterSequenceTypeResourceOrNonFungible.lower(resources),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def require_count_of(
        cls, count: "int", resources: "typing.List[ResourceOrNonFungible]"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of,
            _UniffiConverterUInt8.lower(count),
            _UniffiConverterSequenceTypeResourceOrNonFungible.lower(resources),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def require_virtual_signature(cls, public_key: "PublicKey"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature,
            _UniffiConverterTypePublicKey.lower(public_key),
        )
        return cls._make_instance_(pointer)

    def _and(self, other: "AccessRule") -> "AccessRule":

        return _UniffiConverterTypeAccessRule.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and,
                self._pointer,
                _UniffiConverterTypeAccessRule.lower(other),
            )
        )

    def _or(self, other: "AccessRule") -> "AccessRule":

        return _UniffiConverterTypeAccessRule.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or,
                self._pointer,
                _UniffiConverterTypeAccessRule.lower(other),
            )
        )


class _UniffiConverterTypeAccessRule:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AccessRule):
            raise TypeError(
                "Expected AccessRule instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AccessRule._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class Address:
    _pointer: ctypes.c_void_p

    def __init__(self, address: "str"):

        self._pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new,
            _UniffiConverterString.lower(address),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_address, pointer
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_raw(cls, node_id_bytes: "bytes", network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw,
            _UniffiConverterBytes.lower(node_id_bytes),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def resource_address_from_olympia_resource_address(
        cls, olympia_resource_address: "OlympiaAddress", network_id: "int"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address,
            _UniffiConverterTypeOlympiaAddress.lower(olympia_resource_address),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def virtual_account_address_from_olympia_address(
        cls, olympia_account_address: "OlympiaAddress", network_id: "int"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address,
            _UniffiConverterTypeOlympiaAddress.lower(olympia_account_address),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def virtual_account_address_from_public_key(
        cls, public_key: "PublicKey", network_id: "int"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def virtual_identity_address_from_public_key(
        cls, public_key: "PublicKey", network_id: "int"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    def address_string(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string,
                self._pointer,
            )
        )

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str,
                self._pointer,
            )
        )

    def bytes(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes,
                self._pointer,
            )
        )

    def entity_type(
        self,
    ) -> "EntityType":
        return _UniffiConverterTypeEntityType.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type,
                self._pointer,
            )
        )

    def is_global(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global,
                self._pointer,
            )
        )

    def is_global_component(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component,
                self._pointer,
            )
        )

    def is_global_consensus_manager(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager,
                self._pointer,
            )
        )

    def is_global_fungible_resource_manager(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager,
                self._pointer,
            )
        )

    def is_global_non_fungible_resource_manager(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager,
                self._pointer,
            )
        )

    def is_global_package(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package,
                self._pointer,
            )
        )

    def is_global_resource_manager(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager,
                self._pointer,
            )
        )

    def is_global_virtual(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual,
                self._pointer,
            )
        )

    def is_internal(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal,
                self._pointer,
            )
        )

    def is_internal_fungible_vault(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault,
                self._pointer,
            )
        )

    def is_internal_kv_store(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store,
                self._pointer,
            )
        )

    def is_internal_non_fungible_vault(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault,
                self._pointer,
            )
        )

    def is_internal_vault(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault,
                self._pointer,
            )
        )

    def network_id(
        self,
    ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id,
                self._pointer,
            )
        )


class _UniffiConverterTypeAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Address):
            raise TypeError(
                "Expected Address instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Address._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class Decimal:
    _pointer: ctypes.c_void_p

    def __init__(self, value: "str"):

        self._pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new,
            _UniffiConverterString.lower(value),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal, pointer
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_le_bytes(cls, value: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_from_le_bytes,
            _UniffiConverterBytes.lower(value),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def max(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def min(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def one(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def zero(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero,
        )
        return cls._make_instance_(pointer)

    def abs(
        self,
    ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs,
                self._pointer,
            )
        )

    def add(self, other: "Decimal") -> "Decimal":

        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str,
                self._pointer,
            )
        )

    def cbrt(
        self,
    ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt,
                self._pointer,
            )
        )

    def ceiling(
        self,
    ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling,
                self._pointer,
            )
        )

    def div(self, other: "Decimal") -> "Decimal":

        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def equal(self, other: "Decimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def floor(
        self,
    ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor,
                self._pointer,
            )
        )

    def greater_than(self, other: "Decimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def greater_than_or_equal(self, other: "Decimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def is_negative(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative,
                self._pointer,
            )
        )

    def is_positive(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive,
                self._pointer,
            )
        )

    def is_zero(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero,
                self._pointer,
            )
        )

    def less_than(self, other: "Decimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def less_than_or_equal(self, other: "Decimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def mantissa(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mantissa,
                self._pointer,
            )
        )

    def mul(self, other: "Decimal") -> "Decimal":

        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def not_equal(self, other: "Decimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def nth_root(self, n: "int") -> "typing.Optional[Decimal]":

        return _UniffiConverterOptionalTypeDecimal.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root,
                self._pointer,
                _UniffiConverterUInt32.lower(n),
            )
        )

    def powi(self, exp: "int") -> "Decimal":

        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi,
                self._pointer,
                _UniffiConverterInt64.lower(exp),
            )
        )

    def round(self, decimal_places: "int", rounding_mode: "RoundingMode") -> "Decimal":

        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round,
                self._pointer,
                _UniffiConverterInt32.lower(decimal_places),
                _UniffiConverterTypeRoundingMode.lower(rounding_mode),
            )
        )

    def sqrt(
        self,
    ) -> "typing.Optional[Decimal]":
        return _UniffiConverterOptionalTypeDecimal.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt,
                self._pointer,
            )
        )

    def sub(self, other: "Decimal") -> "Decimal":

        return _UniffiConverterTypeDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(other),
            )
        )

    def to_le_bytes(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_to_le_bytes,
                self._pointer,
            )
        )


class _UniffiConverterTypeDecimal:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Decimal):
            raise TypeError(
                "Expected Decimal instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Decimal._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class Hash:
    _pointer: ctypes.c_void_p

    def __init__(self, hash: "bytes"):

        self._pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new,
            _UniffiConverterBytes.lower(hash),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_hash, pointer
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_hex_string(cls, hash: "str"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string,
            _UniffiConverterString.lower(hash),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def from_unhashed_bytes(cls, bytes: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes,
            _UniffiConverterBytes.lower(bytes),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def sbor_decode(cls, bytes: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_sbor_decode,
            _UniffiConverterBytes.lower(bytes),
        )
        return cls._make_instance_(pointer)

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str,
                self._pointer,
            )
        )

    def bytes(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes,
                self._pointer,
            )
        )


class _UniffiConverterTypeHash:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Hash):
            raise TypeError(
                "Expected Hash instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Hash._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class Instructions:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_instructions(
        cls, instructions: "typing.List[Instruction]", network_id: "int"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions,
            _UniffiConverterSequenceTypeInstruction.lower(instructions),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def from_string(cls, string: "str", network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string,
            _UniffiConverterString.lower(string),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str,
                self._pointer,
            )
        )

    def instructions_list(
        self,
    ) -> "typing.List[Instruction]":
        return _UniffiConverterSequenceTypeInstruction.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list,
                self._pointer,
            )
        )

    def network_id(
        self,
    ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id,
                self._pointer,
            )
        )


class _UniffiConverterTypeInstructions:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Instructions):
            raise TypeError(
                "Expected Instructions instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Instructions._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class Intent:
    _pointer: ctypes.c_void_p

    def __init__(
        self,
        header: "TransactionHeader",
        manifest: "TransactionManifest",
        message: "Message",
    ):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new,
            _UniffiConverterTypeTransactionHeader.lower(header),
            _UniffiConverterTypeTransactionManifest.lower(manifest),
            _UniffiConverterTypeMessage.lower(message),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_intent, pointer
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled_intent: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile,
            _UniffiConverterBytes.lower(compiled_intent),
        )
        return cls._make_instance_(pointer)

    def compile(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile,
                self._pointer,
            )
        )

    def hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash,
                self._pointer,
            )
        )

    def header(
        self,
    ) -> "TransactionHeader":
        return _UniffiConverterTypeTransactionHeader.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header,
                self._pointer,
            )
        )

    def intent_hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash,
                self._pointer,
            )
        )

    def manifest(
        self,
    ) -> "TransactionManifest":
        return _UniffiConverterTypeTransactionManifest.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest,
                self._pointer,
            )
        )

    def message(
        self,
    ) -> "Message":
        return _UniffiConverterTypeMessage.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message,
                self._pointer,
            )
        )

    def statically_validate(self, validation_config: "ValidationConfig"):

        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate,
            self._pointer,
            _UniffiConverterTypeValidationConfig.lower(validation_config),
        )


class _UniffiConverterTypeIntent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Intent):
            raise TypeError(
                "Expected Intent instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Intent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class ManifestBuilder:
    _pointer: ctypes.c_void_p

    def __init__(
        self,
    ):
        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new,
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def access_controller_cancel_primary_role_badge_withdraw_attempt(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_primary_role_badge_withdraw_attempt,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_cancel_primary_role_recovery_proposal(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_primary_role_recovery_proposal,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_cancel_recovery_role_badge_withdraw_attempt(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_recovery_role_badge_withdraw_attempt,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_cancel_recovery_role_recovery_proposal(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_cancel_recovery_role_recovery_proposal,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_create(
        self,
        controlled_asset: "ManifestBuilderBucket",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create,
                self._pointer,
                _UniffiConverterTypeManifestBuilderBucket.lower(controlled_asset),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def access_controller_create_proof(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create_proof,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_create_with_security_structure(
        self,
        controlled_asset: "ManifestBuilderBucket",
        primary_role: "SecurityStructureRole",
        recovery_role: "SecurityStructureRole",
        confirmation_role: "SecurityStructureRole",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_create_with_security_structure,
                self._pointer,
                _UniffiConverterTypeManifestBuilderBucket.lower(controlled_asset),
                _UniffiConverterTypeSecurityStructureRole.lower(primary_role),
                _UniffiConverterTypeSecurityStructureRole.lower(recovery_role),
                _UniffiConverterTypeSecurityStructureRole.lower(confirmation_role),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def access_controller_initiate_badge_withdraw_as_primary(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_primary,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_initiate_badge_withdraw_as_recovery(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_badge_withdraw_as_recovery,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_initiate_recovery_as_primary(
        self,
        address: "Address",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery_as_primary,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
            )
        )

    def access_controller_initiate_recovery_as_recovery(
        self,
        address: "Address",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery_as_recovery,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
            )
        )

    def access_controller_lock_primary_role(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_lock_primary_role,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_mint_recovery_badges(
        self,
        address: "Address",
        non_fungible_local_ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_mint_recovery_badges,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(
                    non_fungible_local_ids
                ),
            )
        )

    def access_controller_new_from_public_keys(
        self,
        controlled_asset: "ManifestBuilderBucket",
        primary_role: "PublicKey",
        recovery_role: "PublicKey",
        confirmation_role: "PublicKey",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_new_from_public_keys,
                self._pointer,
                _UniffiConverterTypeManifestBuilderBucket.lower(controlled_asset),
                _UniffiConverterTypePublicKey.lower(primary_role),
                _UniffiConverterTypePublicKey.lower(recovery_role),
                _UniffiConverterTypePublicKey.lower(confirmation_role),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def access_controller_quick_confirm_primary_role_badge_withdraw_attempt(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_primary_role_badge_withdraw_attempt,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_quick_confirm_primary_role_recovery_proposal(
        self,
        address: "Address",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_primary_role_recovery_proposal,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
            )
        )

    def access_controller_quick_confirm_recovery_role_badge_withdraw_attempt(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery_role_badge_withdraw_attempt,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def access_controller_quick_confirm_recovery_role_recovery_proposal(
        self,
        address: "Address",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery_role_recovery_proposal,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
            )
        )

    def access_controller_stop_timed_recovery(
        self,
        address: "Address",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_stop_timed_recovery,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
            )
        )

    def access_controller_timed_confirm_recovery(
        self,
        address: "Address",
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_timed_confirm_recovery,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeRuleSet.lower(rule_set),
                _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes),
            )
        )

    def access_controller_unlock_primary_role(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_unlock_primary_role,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def account_add_authorized_depositor(
        self, address: "Address", badge: "ResourceOrNonFungible"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_add_authorized_depositor,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeResourceOrNonFungible.lower(badge),
            )
        )

    def account_burn(
        self, address: "Address", resource_address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_burn,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_burn_non_fungibles(
        self,
        address: "Address",
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_burn_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def account_create(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create,
                self._pointer,
            )
        )

    def account_create_advanced(
        self,
        owner_role: "OwnerRole",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_advanced,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def account_create_proof_of_amount(
        self, address: "Address", resource_address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_proof_of_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_create_proof_of_non_fungibles(
        self,
        address: "Address",
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_create_proof_of_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def account_deposit(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def account_deposit_batch(
        self, address: "Address", buckets: "typing.List[ManifestBuilderBucket]"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
            )
        )

    def account_deposit_entire_worktop(
        self, account_address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_entire_worktop,
                self._pointer,
                _UniffiConverterTypeAddress.lower(account_address),
            )
        )

    def account_lock_contingent_fee(
        self, address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_contingent_fee,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_lock_fee(
        self, address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_lock_fee_and_withdraw(
        self,
        address: "Address",
        amount_to_lock: "Decimal",
        resource_address: "Address",
        amount: "Decimal",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee_and_withdraw,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount_to_lock),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_lock_fee_and_withdraw_non_fungibles(
        self,
        address: "Address",
        amount_to_lock: "Decimal",
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_lock_fee_and_withdraw_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount_to_lock),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def account_locker_airdrop(
        self,
        address: "Address",
        claimants: "dict",
        bucket: "ManifestBuilderBucket",
        try_direct_send: "bool",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_airdrop,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterMapStringTypeResourceSpecifier.lower(claimants),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterBool.lower(try_direct_send),
            )
        )

    def account_locker_claim(
        self,
        address: "Address",
        claimant: "Address",
        resource_address: "Address",
        amount: "Decimal",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_claim,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_locker_claim_non_fungibles(
        self,
        address: "Address",
        claimant: "Address",
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_claim_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def account_locker_get_amount(
        self, address: "Address", claimant: "Address", resource_address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_get_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeAddress.lower(resource_address),
            )
        )

    def account_locker_get_non_fungible_local_ids(
        self,
        address: "Address",
        claimant: "Address",
        resource_address: "Address",
        limit: "int",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_get_non_fungible_local_ids,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterUInt32.lower(limit),
            )
        )

    def account_locker_instantiate(
        self,
        owner_role: "OwnerRole",
        storer_role: "AccessRule",
        storer_updater_role: "AccessRule",
        recoverer_role: "AccessRule",
        recoverer_updater_role: "AccessRule",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_instantiate,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterTypeAccessRule.lower(storer_role),
                _UniffiConverterTypeAccessRule.lower(storer_updater_role),
                _UniffiConverterTypeAccessRule.lower(recoverer_role),
                _UniffiConverterTypeAccessRule.lower(recoverer_updater_role),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def account_locker_instantiate_simple(
        self, allow_recover: "bool"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_instantiate_simple,
                self._pointer,
                _UniffiConverterBool.lower(allow_recover),
            )
        )

    def account_locker_recover(
        self,
        address: "Address",
        claimant: "Address",
        resource_address: "Address",
        amount: "Decimal",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_recover,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_locker_recover_non_fungibles(
        self,
        address: "Address",
        claimant: "Address",
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_recover_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def account_locker_store(
        self,
        address: "Address",
        claimant: "Address",
        bucket: "ManifestBuilderBucket",
        try_direct_send: "bool",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_locker_store,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(claimant),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterBool.lower(try_direct_send),
            )
        )

    def account_remove_authorized_depositor(
        self, address: "Address", badge: "ResourceOrNonFungible"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_remove_authorized_depositor,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeResourceOrNonFungible.lower(badge),
            )
        )

    def account_remove_resource_preference(
        self, address: "Address", resource_address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_remove_resource_preference,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
            )
        )

    def account_securify(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_securify,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def account_set_default_deposit_rule(
        self, address: "Address", default_deposit_rule: "AccountDefaultDepositRule"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_set_default_deposit_rule,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAccountDefaultDepositRule.lower(
                    default_deposit_rule
                ),
            )
        )

    def account_set_resource_preference(
        self,
        address: "Address",
        resource_address: "Address",
        resource_preference: "ResourcePreference",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_set_resource_preference,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeResourcePreference.lower(resource_preference),
            )
        )

    def account_try_deposit_batch_or_abort(
        self,
        address: "Address",
        buckets: "typing.List[ManifestBuilderBucket]",
        authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
                _UniffiConverterOptionalTypeResourceOrNonFungible.lower(
                    authorized_depositor_badge
                ),
            )
        )

    def account_try_deposit_batch_or_refund(
        self,
        address: "Address",
        buckets: "typing.List[ManifestBuilderBucket]",
        authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
                _UniffiConverterOptionalTypeResourceOrNonFungible.lower(
                    authorized_depositor_badge
                ),
            )
        )

    def account_try_deposit_entire_worktop_or_abort(
        self,
        account_address: "Address",
        authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_entire_worktop_or_abort,
                self._pointer,
                _UniffiConverterTypeAddress.lower(account_address),
                _UniffiConverterOptionalTypeResourceOrNonFungible.lower(
                    authorized_depositor_badge
                ),
            )
        )

    def account_try_deposit_entire_worktop_or_refund(
        self,
        account_address: "Address",
        authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_entire_worktop_or_refund,
                self._pointer,
                _UniffiConverterTypeAddress.lower(account_address),
                _UniffiConverterOptionalTypeResourceOrNonFungible.lower(
                    authorized_depositor_badge
                ),
            )
        )

    def account_try_deposit_or_abort(
        self,
        address: "Address",
        bucket: "ManifestBuilderBucket",
        authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterOptionalTypeResourceOrNonFungible.lower(
                    authorized_depositor_badge
                ),
            )
        )

    def account_try_deposit_or_refund(
        self,
        address: "Address",
        bucket: "ManifestBuilderBucket",
        authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterOptionalTypeResourceOrNonFungible.lower(
                    authorized_depositor_badge
                ),
            )
        )

    def account_withdraw(
        self, address: "Address", resource_address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_withdraw,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def account_withdraw_non_fungibles(
        self,
        address: "Address",
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_withdraw_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def allocate_global_address(
        self,
        package_address: "Address",
        blueprint_name: "str",
        into_address_reservation: "ManifestBuilderAddressReservation",
        into_named_address: "ManifestBuilderNamedAddress",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address,
                self._pointer,
                _UniffiConverterTypeAddress.lower(package_address),
                _UniffiConverterString.lower(blueprint_name),
                _UniffiConverterTypeManifestBuilderAddressReservation.lower(
                    into_address_reservation
                ),
                _UniffiConverterTypeManifestBuilderNamedAddress.lower(
                    into_named_address
                ),
            )
        )

    def assert_worktop_contains(
        self, resource_address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def assert_worktop_contains_any(
        self, resource_address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
            )
        )

    def assert_worktop_contains_non_fungibles(
        self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
            )
        )

    def build(self, network_id: "int") -> "TransactionManifest":

        return _UniffiConverterTypeTransactionManifest.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build,
                self._pointer,
                _UniffiConverterUInt8.lower(network_id),
            )
        )

    def burn_resource(self, bucket: "ManifestBuilderBucket") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource,
                self._pointer,
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def call_access_rules_method(
        self,
        address: "ManifestBuilderAddress",
        method_name: "str",
        args: "typing.List[ManifestBuilderValue]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method,
                self._pointer,
                _UniffiConverterTypeManifestBuilderAddress.lower(address),
                _UniffiConverterString.lower(method_name),
                _UniffiConverterSequenceTypeManifestBuilderValue.lower(args),
            )
        )

    def call_direct_vault_method(
        self,
        address: "Address",
        method_name: "str",
        args: "typing.List[ManifestBuilderValue]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(method_name),
                _UniffiConverterSequenceTypeManifestBuilderValue.lower(args),
            )
        )

    def call_function(
        self,
        address: "ManifestBuilderAddress",
        blueprint_name: "str",
        function_name: "str",
        args: "typing.List[ManifestBuilderValue]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function,
                self._pointer,
                _UniffiConverterTypeManifestBuilderAddress.lower(address),
                _UniffiConverterString.lower(blueprint_name),
                _UniffiConverterString.lower(function_name),
                _UniffiConverterSequenceTypeManifestBuilderValue.lower(args),
            )
        )

    def call_metadata_method(
        self,
        address: "ManifestBuilderAddress",
        method_name: "str",
        args: "typing.List[ManifestBuilderValue]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method,
                self._pointer,
                _UniffiConverterTypeManifestBuilderAddress.lower(address),
                _UniffiConverterString.lower(method_name),
                _UniffiConverterSequenceTypeManifestBuilderValue.lower(args),
            )
        )

    def call_method(
        self,
        address: "ManifestBuilderAddress",
        method_name: "str",
        args: "typing.List[ManifestBuilderValue]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method,
                self._pointer,
                _UniffiConverterTypeManifestBuilderAddress.lower(address),
                _UniffiConverterString.lower(method_name),
                _UniffiConverterSequenceTypeManifestBuilderValue.lower(args),
            )
        )

    def call_royalty_method(
        self,
        address: "ManifestBuilderAddress",
        method_name: "str",
        args: "typing.List[ManifestBuilderValue]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method,
                self._pointer,
                _UniffiConverterTypeManifestBuilderAddress.lower(address),
                _UniffiConverterString.lower(method_name),
                _UniffiConverterSequenceTypeManifestBuilderValue.lower(args),
            )
        )

    def clone_proof(
        self, proof: "ManifestBuilderProof", into_proof: "ManifestBuilderProof"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof,
                self._pointer,
                _UniffiConverterTypeManifestBuilderProof.lower(proof),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def create_fungible_resource_manager(
        self,
        owner_role: "OwnerRole",
        track_total_supply: "bool",
        divisibility: "int",
        initial_supply: "typing.Optional[Decimal]",
        resource_roles: "FungibleResourceRoles",
        metadata: "MetadataModuleConfig",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterBool.lower(track_total_supply),
                _UniffiConverterUInt8.lower(divisibility),
                _UniffiConverterOptionalTypeDecimal.lower(initial_supply),
                _UniffiConverterTypeFungibleResourceRoles.lower(resource_roles),
                _UniffiConverterTypeMetadataModuleConfig.lower(metadata),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def create_proof_from_auth_zone_of_all(
        self, resource_address: "Address", into_proof: "ManifestBuilderProof"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def create_proof_from_auth_zone_of_amount(
        self,
        resource_address: "Address",
        amount: "Decimal",
        into_proof: "ManifestBuilderProof",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def create_proof_from_auth_zone_of_non_fungibles(
        self,
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
        into_proof: "ManifestBuilderProof",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def create_proof_from_bucket_of_all(
        self, bucket: "ManifestBuilderBucket", into_proof: "ManifestBuilderProof"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all,
                self._pointer,
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def create_proof_from_bucket_of_amount(
        self,
        amount: "Decimal",
        bucket: "ManifestBuilderBucket",
        into_proof: "ManifestBuilderProof",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount,
                self._pointer,
                _UniffiConverterTypeDecimal.lower(amount),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def create_proof_from_bucket_of_non_fungibles(
        self,
        ids: "typing.List[NonFungibleLocalId]",
        bucket: "ManifestBuilderBucket",
        into_proof: "ManifestBuilderProof",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles,
                self._pointer,
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def drop_all_proofs(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs,
                self._pointer,
            )
        )

    def drop_auth_zone_proofs(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs,
                self._pointer,
            )
        )

    def drop_auth_zone_signature_proofs(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs,
                self._pointer,
            )
        )

    def drop_proof(self, proof: "ManifestBuilderProof") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof,
                self._pointer,
                _UniffiConverterTypeManifestBuilderProof.lower(proof),
            )
        )

    def faucet_free_xrd(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd,
                self._pointer,
            )
        )

    def faucet_lock_fee(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee,
                self._pointer,
            )
        )

    def identity_create(
        self,
    ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_create,
                self._pointer,
            )
        )

    def identity_create_advanced(self, owner_role: "OwnerRole") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_create_advanced,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
            )
        )

    def identity_securify(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_identity_securify,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def metadata_get(self, address: "Address", key: "str") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_get,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(key),
            )
        )

    def metadata_lock(self, address: "Address", key: "str") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_lock,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(key),
            )
        )

    def metadata_remove(self, address: "Address", key: "str") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_remove,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(key),
            )
        )

    def metadata_set(
        self, address: "Address", key: "str", value: "MetadataValue"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_metadata_set,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(key),
                _UniffiConverterTypeMetadataValue.lower(value),
            )
        )

    def mint_fungible(
        self, resource_address: "Address", amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
            )
        )

    def multi_resource_pool_contribute(
        self, address: "Address", buckets: "typing.List[ManifestBuilderBucket]"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_contribute,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
            )
        )

    def multi_resource_pool_get_redemption_value(
        self, address: "Address", amount_of_pool_units: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_get_redemption_value,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount_of_pool_units),
            )
        )

    def multi_resource_pool_get_vault_amount(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_get_vault_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def multi_resource_pool_instantiate(
        self,
        owner_role: "OwnerRole",
        pool_manager_rule: "AccessRule",
        resource_addresses: "typing.List[Address]",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_instantiate,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterTypeAccessRule.lower(pool_manager_rule),
                _UniffiConverterSequenceTypeAddress.lower(resource_addresses),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def multi_resource_pool_protected_deposit(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_protected_deposit,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def multi_resource_pool_protected_withdraw(
        self,
        address: "Address",
        resource_address: "Address",
        amount: "Decimal",
        withdraw_strategy: "WithdrawStrategy",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_protected_withdraw,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
                _UniffiConverterTypeWithdrawStrategy.lower(withdraw_strategy),
            )
        )

    def multi_resource_pool_redeem(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_multi_resource_pool_redeem,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def one_resource_pool_contribute(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_contribute,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def one_resource_pool_get_redemption_value(
        self, address: "Address", amount_of_pool_units: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_get_redemption_value,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount_of_pool_units),
            )
        )

    def one_resource_pool_get_vault_amount(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_get_vault_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def one_resource_pool_instantiate(
        self,
        owner_role: "OwnerRole",
        pool_manager_rule: "AccessRule",
        resource_address: "Address",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_instantiate,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterTypeAccessRule.lower(pool_manager_rule),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def one_resource_pool_protected_deposit(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_protected_deposit,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def one_resource_pool_protected_withdraw(
        self,
        address: "Address",
        amount: "Decimal",
        withdraw_strategy: "WithdrawStrategy",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_protected_withdraw,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount),
                _UniffiConverterTypeWithdrawStrategy.lower(withdraw_strategy),
            )
        )

    def one_resource_pool_redeem(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_one_resource_pool_redeem,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def package_claim_royalty(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_claim_royalty,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def package_publish(
        self, code: "bytes", definition: "bytes", metadata: "dict"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_publish,
                self._pointer,
                _UniffiConverterBytes.lower(code),
                _UniffiConverterBytes.lower(definition),
                _UniffiConverterMapStringTypeMetadataInitEntry.lower(metadata),
            )
        )

    def package_publish_advanced(
        self,
        owner_role: "OwnerRole",
        code: "bytes",
        definition: "bytes",
        metadata: "dict",
        package_address: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_package_publish_advanced,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterBytes.lower(code),
                _UniffiConverterBytes.lower(definition),
                _UniffiConverterMapStringTypeMetadataInitEntry.lower(metadata),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    package_address
                ),
            )
        )

    def pop_from_auth_zone(
        self, into_proof: "ManifestBuilderProof"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone,
                self._pointer,
                _UniffiConverterTypeManifestBuilderProof.lower(into_proof),
            )
        )

    def push_to_auth_zone(self, proof: "ManifestBuilderProof") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone,
                self._pointer,
                _UniffiConverterTypeManifestBuilderProof.lower(proof),
            )
        )

    def return_to_worktop(self, bucket: "ManifestBuilderBucket") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop,
                self._pointer,
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def role_assignment_get(
        self, address: "Address", module: "ModuleId", role_key: "str"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_get,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeModuleId.lower(module),
                _UniffiConverterString.lower(role_key),
            )
        )

    def role_assignment_lock_owner(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_lock_owner,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def role_assignment_set(
        self,
        address: "Address",
        module: "ModuleId",
        role_key: "str",
        rule: "AccessRule",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_set,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeModuleId.lower(module),
                _UniffiConverterString.lower(role_key),
                _UniffiConverterTypeAccessRule.lower(rule),
            )
        )

    def role_assignment_set_owner(
        self, address: "Address", rule: "AccessRule"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_role_assignment_set_owner,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAccessRule.lower(rule),
            )
        )

    def royalty_claim(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_claim,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def royalty_lock(self, address: "Address", method: "str") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_lock,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(method),
            )
        )

    def royalty_set(
        self, address: "Address", method: "str", amount: "RoyaltyAmount"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_royalty_set,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(method),
                _UniffiConverterTypeRoyaltyAmount.lower(amount),
            )
        )

    def take_all_from_worktop(
        self, resource_address: "Address", into_bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeManifestBuilderBucket.lower(into_bucket),
            )
        )

    def take_from_worktop(
        self,
        resource_address: "Address",
        amount: "Decimal",
        into_bucket: "ManifestBuilderBucket",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
                _UniffiConverterTypeManifestBuilderBucket.lower(into_bucket),
            )
        )

    def take_non_fungibles_from_worktop(
        self,
        resource_address: "Address",
        ids: "typing.List[NonFungibleLocalId]",
        into_bucket: "ManifestBuilderBucket",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop,
                self._pointer,
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
                _UniffiConverterTypeManifestBuilderBucket.lower(into_bucket),
            )
        )

    def two_resource_pool_contribute(
        self, address: "Address", buckets: "typing.List[ManifestBuilderBucket]"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_contribute,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterSequenceTypeManifestBuilderBucket.lower(buckets),
            )
        )

    def two_resource_pool_get_redemption_value(
        self, address: "Address", amount_of_pool_units: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_get_redemption_value,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount_of_pool_units),
            )
        )

    def two_resource_pool_get_vault_amount(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_get_vault_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def two_resource_pool_instantiate(
        self,
        owner_role: "OwnerRole",
        pool_manager_rule: "AccessRule",
        resource_addresses: "typing.List[Address]",
        address_reservation: "typing.Optional[ManifestBuilderAddressReservation]",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_instantiate,
                self._pointer,
                _UniffiConverterTypeOwnerRole.lower(owner_role),
                _UniffiConverterTypeAccessRule.lower(pool_manager_rule),
                _UniffiConverterSequenceTypeAddress.lower(resource_addresses),
                _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(
                    address_reservation
                ),
            )
        )

    def two_resource_pool_protected_deposit(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_protected_deposit,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def two_resource_pool_protected_withdraw(
        self,
        address: "Address",
        resource_address: "Address",
        amount: "Decimal",
        withdraw_strategy: "WithdrawStrategy",
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_protected_withdraw,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeAddress.lower(resource_address),
                _UniffiConverterTypeDecimal.lower(amount),
                _UniffiConverterTypeWithdrawStrategy.lower(withdraw_strategy),
            )
        )

    def two_resource_pool_redeem(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_two_resource_pool_redeem,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def validator_accepts_delegated_stake(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_accepts_delegated_stake,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_claim_xrd(
        self, address: "Address", bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_claim_xrd,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
            )
        )

    def validator_finish_unlock_owner_stake_units(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_finish_unlock_owner_stake_units,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_get_protocol_update_readiness(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_get_protocol_update_readiness,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_get_redemption_value(
        self, address: "Address", amount_of_stake_units: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_get_redemption_value,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(amount_of_stake_units),
            )
        )

    def validator_lock_owner_stake_units(
        self, address: "Address", stake_unit_bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_lock_owner_stake_units,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(stake_unit_bucket),
            )
        )

    def validator_register(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_register,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_signal_protocol_update_readiness(
        self, address: "Address", vote: "str"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_signal_protocol_update_readiness,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterString.lower(vote),
            )
        )

    def validator_stake(
        self, address: "Address", stake: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_stake,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(stake),
            )
        )

    def validator_stake_as_owner(
        self, address: "Address", stake: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_stake_as_owner,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(stake),
            )
        )

    def validator_start_unlock_owner_stake_units(
        self, address: "Address", requested_stake_unit_amount: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_start_unlock_owner_stake_units,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(requested_stake_unit_amount),
            )
        )

    def validator_total_stake_unit_supply(
        self, address: "Address"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_total_stake_unit_supply,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_total_stake_xrd_amount(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_total_stake_xrd_amount,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_unregister(self, address: "Address") -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_unregister,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
            )
        )

    def validator_unstake(
        self, address: "Address", stake_unit_bucket: "ManifestBuilderBucket"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_unstake,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeManifestBuilderBucket.lower(stake_unit_bucket),
            )
        )

    def validator_update_accept_delegated_stake(
        self, address: "Address", accept_delegated_stake: "bool"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_accept_delegated_stake,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterBool.lower(accept_delegated_stake),
            )
        )

    def validator_update_fee(
        self, address: "Address", new_fee_factor: "Decimal"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_fee,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypeDecimal.lower(new_fee_factor),
            )
        )

    def validator_update_key(
        self, address: "Address", key: "PublicKey"
    ) -> "ManifestBuilder":

        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_validator_update_key,
                self._pointer,
                _UniffiConverterTypeAddress.lower(address),
                _UniffiConverterTypePublicKey.lower(key),
            )
        )


class _UniffiConverterTypeManifestBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ManifestBuilder):
            raise TypeError(
                "Expected ManifestBuilder instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ManifestBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class MessageValidationConfig:
    _pointer: ctypes.c_void_p

    def __init__(
        self,
        max_plaintext_message_length: "int",
        max_encrypted_message_length: "int",
        max_mime_type_length: "int",
        max_decryptors: "int",
    ):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new,
            _UniffiConverterUInt64.lower(max_plaintext_message_length),
            _UniffiConverterUInt64.lower(max_encrypted_message_length),
            _UniffiConverterUInt64.lower(max_mime_type_length),
            _UniffiConverterUInt64.lower(max_decryptors),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def default(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default,
        )
        return cls._make_instance_(pointer)

    def max_decryptors(
        self,
    ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors,
                self._pointer,
            )
        )

    def max_encrypted_message_length(
        self,
    ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length,
                self._pointer,
            )
        )

    def max_mime_type_length(
        self,
    ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length,
                self._pointer,
            )
        )

    def max_plaintext_message_length(
        self,
    ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length,
                self._pointer,
            )
        )


class _UniffiConverterTypeMessageValidationConfig:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, MessageValidationConfig):
            raise TypeError(
                "Expected MessageValidationConfig instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return MessageValidationConfig._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class NonFungibleGlobalId:
    _pointer: ctypes.c_void_p

    def __init__(self, non_fungible_global_id: "str"):

        self._pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new,
            _UniffiConverterString.lower(non_fungible_global_id),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_parts(
        cls, resource_address: "Address", non_fungible_local_id: "NonFungibleLocalId"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts,
            _UniffiConverterTypeAddress.lower(resource_address),
            _UniffiConverterTypeNonFungibleLocalId.lower(non_fungible_local_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def global_caller_badge(cls, component_address: "Address", network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_global_caller_badge,
            _UniffiConverterTypeAddress.lower(component_address),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def package_of_direct_caller_badge(
        cls, package_address: "Address", network_id: "int"
    ):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_package_of_direct_caller_badge,
            _UniffiConverterTypeAddress.lower(package_address),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def virtual_signature_badge(cls, public_key: "PublicKey", network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str,
                self._pointer,
            )
        )

    def local_id(
        self,
    ) -> "NonFungibleLocalId":
        return _UniffiConverterTypeNonFungibleLocalId.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id,
                self._pointer,
            )
        )

    def resource_address(
        self,
    ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address,
                self._pointer,
            )
        )


class _UniffiConverterTypeNonFungibleGlobalId:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NonFungibleGlobalId):
            raise TypeError(
                "Expected NonFungibleGlobalId instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NonFungibleGlobalId._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class NotarizedTransaction:
    _pointer: ctypes.c_void_p

    def __init__(self, signed_intent: "SignedIntent", notary_signature: "Signature"):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new,
            _UniffiConverterTypeSignedIntent.lower(signed_intent),
            _UniffiConverterTypeSignature.lower(notary_signature),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled_notarized_transaction: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile,
            _UniffiConverterBytes.lower(compiled_notarized_transaction),
        )
        return cls._make_instance_(pointer)

    def compile(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile,
                self._pointer,
            )
        )

    def hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash,
                self._pointer,
            )
        )

    def intent_hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash,
                self._pointer,
            )
        )

    def notarized_transaction_hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash,
                self._pointer,
            )
        )

    def notary_signature(
        self,
    ) -> "Signature":
        return _UniffiConverterTypeSignature.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature,
                self._pointer,
            )
        )

    def signed_intent(
        self,
    ) -> "SignedIntent":
        return _UniffiConverterTypeSignedIntent.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent,
                self._pointer,
            )
        )

    def signed_intent_hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash,
                self._pointer,
            )
        )

    def statically_validate(self, validation_config: "ValidationConfig"):

        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate,
            self._pointer,
            _UniffiConverterTypeValidationConfig.lower(validation_config),
        )


class _UniffiConverterTypeNotarizedTransaction:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NotarizedTransaction):
            raise TypeError(
                "Expected NotarizedTransaction instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NotarizedTransaction._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class OlympiaAddress:
    _pointer: ctypes.c_void_p

    def __init__(self, address: "str"):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new,
            _UniffiConverterString.lower(address),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str,
                self._pointer,
            )
        )

    def public_key(
        self,
    ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key,
                self._pointer,
            )
        )


class _UniffiConverterTypeOlympiaAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, OlympiaAddress):
            raise TypeError(
                "Expected OlympiaAddress instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return OlympiaAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class PreciseDecimal:
    _pointer: ctypes.c_void_p

    def __init__(self, value: "str"):

        self._pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new,
            _UniffiConverterString.lower(value),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_le_bytes(cls, value: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_from_le_bytes,
            _UniffiConverterBytes.lower(value),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def max(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def min(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def one(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one,
        )
        return cls._make_instance_(pointer)

    @classmethod
    def zero(
        cls,
    ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero,
        )
        return cls._make_instance_(pointer)

    def abs(
        self,
    ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs,
                self._pointer,
            )
        )

    def add(self, other: "PreciseDecimal") -> "PreciseDecimal":

        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str,
                self._pointer,
            )
        )

    def cbrt(
        self,
    ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt,
                self._pointer,
            )
        )

    def ceiling(
        self,
    ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling,
                self._pointer,
            )
        )

    def div(self, other: "PreciseDecimal") -> "PreciseDecimal":

        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def equal(self, other: "PreciseDecimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def floor(
        self,
    ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor,
                self._pointer,
            )
        )

    def greater_than(self, other: "PreciseDecimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def greater_than_or_equal(self, other: "PreciseDecimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def is_negative(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative,
                self._pointer,
            )
        )

    def is_positive(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive,
                self._pointer,
            )
        )

    def is_zero(
        self,
    ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero,
                self._pointer,
            )
        )

    def less_than(self, other: "PreciseDecimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def less_than_or_equal(self, other: "PreciseDecimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def mantissa(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mantissa,
                self._pointer,
            )
        )

    def mul(self, other: "PreciseDecimal") -> "PreciseDecimal":

        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def not_equal(self, other: "PreciseDecimal") -> "bool":

        return _UniffiConverterBool.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def nth_root(self, n: "int") -> "typing.Optional[PreciseDecimal]":

        return _UniffiConverterOptionalTypePreciseDecimal.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root,
                self._pointer,
                _UniffiConverterUInt32.lower(n),
            )
        )

    def powi(self, exp: "int") -> "PreciseDecimal":

        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi,
                self._pointer,
                _UniffiConverterInt64.lower(exp),
            )
        )

    def round(
        self, decimal_places: "int", rounding_mode: "RoundingMode"
    ) -> "PreciseDecimal":

        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round,
                self._pointer,
                _UniffiConverterInt32.lower(decimal_places),
                _UniffiConverterTypeRoundingMode.lower(rounding_mode),
            )
        )

    def sqrt(
        self,
    ) -> "typing.Optional[PreciseDecimal]":
        return _UniffiConverterOptionalTypePreciseDecimal.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt,
                self._pointer,
            )
        )

    def sub(self, other: "PreciseDecimal") -> "PreciseDecimal":

        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub,
                self._pointer,
                _UniffiConverterTypePreciseDecimal.lower(other),
            )
        )

    def to_le_bytes(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_to_le_bytes,
                self._pointer,
            )
        )


class _UniffiConverterTypePreciseDecimal:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PreciseDecimal):
            raise TypeError(
                "Expected PreciseDecimal instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PreciseDecimal._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class PrivateKey:
    _pointer: ctypes.c_void_p

    def __init__(self, bytes: "bytes", curve: "Curve"):

        self._pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new,
            _UniffiConverterBytes.lower(bytes),
            _UniffiConverterTypeCurve.lower(curve),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_ed25519(cls, bytes: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519,
            _UniffiConverterBytes.lower(bytes),
        )
        return cls._make_instance_(pointer)

    @classmethod
    def new_secp256k1(cls, bytes: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1,
            _UniffiConverterBytes.lower(bytes),
        )
        return cls._make_instance_(pointer)

    def curve(
        self,
    ) -> "Curve":
        return _UniffiConverterTypeCurve.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_curve,
                self._pointer,
            )
        )

    def public_key(
        self,
    ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key,
                self._pointer,
            )
        )

    def public_key_bytes(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key_bytes,
                self._pointer,
            )
        )

    def raw(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw,
                self._pointer,
            )
        )

    def raw_hex(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_raw_hex,
                self._pointer,
            )
        )

    def sign(self, hash: "Hash") -> "bytes":

        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign,
                self._pointer,
                _UniffiConverterTypeHash.lower(hash),
            )
        )

    def sign_to_signature(self, hash: "Hash") -> "Signature":

        return _UniffiConverterTypeSignature.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature,
                self._pointer,
                _UniffiConverterTypeHash.lower(hash),
            )
        )

    def sign_to_signature_with_public_key(
        self, hash: "Hash"
    ) -> "SignatureWithPublicKey":

        return _UniffiConverterTypeSignatureWithPublicKey.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key,
                self._pointer,
                _UniffiConverterTypeHash.lower(hash),
            )
        )


class _UniffiConverterTypePrivateKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PrivateKey):
            raise TypeError(
                "Expected PrivateKey instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PrivateKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class SignedIntent:
    _pointer: ctypes.c_void_p

    def __init__(
        self, intent: "Intent", intent_signatures: "typing.List[SignatureWithPublicKey]"
    ):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new,
            _UniffiConverterTypeIntent.lower(intent),
            _UniffiConverterSequenceTypeSignatureWithPublicKey.lower(intent_signatures),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled_signed_intent: "bytes"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile,
            _UniffiConverterBytes.lower(compiled_signed_intent),
        )
        return cls._make_instance_(pointer)

    def compile(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile,
                self._pointer,
            )
        )

    def hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash,
                self._pointer,
            )
        )

    def intent(
        self,
    ) -> "Intent":
        return _UniffiConverterTypeIntent.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent,
                self._pointer,
            )
        )

    def intent_hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash,
                self._pointer,
            )
        )

    def intent_signatures(
        self,
    ) -> "typing.List[SignatureWithPublicKey]":
        return _UniffiConverterSequenceTypeSignatureWithPublicKey.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures,
                self._pointer,
            )
        )

    def signed_intent_hash(
        self,
    ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash,
                self._pointer,
            )
        )

    def statically_validate(self, validation_config: "ValidationConfig"):

        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate,
            self._pointer,
            _UniffiConverterTypeValidationConfig.lower(validation_config),
        )


class _UniffiConverterTypeSignedIntent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SignedIntent):
            raise TypeError(
                "Expected SignedIntent instance, {} found".format(type(value).__name__)
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SignedIntent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class TransactionBuilder:
    _pointer: ctypes.c_void_p

    def __init__(
        self,
    ):
        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new,
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def header(self, header: "TransactionHeader") -> "TransactionBuilderHeaderStep":

        return _UniffiConverterTypeTransactionBuilderHeaderStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header,
                self._pointer,
                _UniffiConverterTypeTransactionHeader.lower(header),
            )
        )


class _UniffiConverterTypeTransactionBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilder):
            raise TypeError(
                "Expected TransactionBuilder instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class TransactionBuilderHeaderStep:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def manifest(
        self, manifest: "TransactionManifest"
    ) -> "TransactionBuilderMessageStep":

        return _UniffiConverterTypeTransactionBuilderMessageStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest,
                self._pointer,
                _UniffiConverterTypeTransactionManifest.lower(manifest),
            )
        )


class _UniffiConverterTypeTransactionBuilderHeaderStep:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilderHeaderStep):
            raise TypeError(
                "Expected TransactionBuilderHeaderStep instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilderHeaderStep._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class TransactionBuilderIntentSignaturesStep:
    _pointer: ctypes.c_void_p

    def __init__(self, message_step: "TransactionBuilderMessageStep"):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilderintentsignaturesstep_new,
            _UniffiConverterTypeTransactionBuilderMessageStep.lower(message_step),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def notarize_with_private_key(
        self, private_key: "PrivateKey"
    ) -> "NotarizedTransaction":

        return _UniffiConverterTypeNotarizedTransaction.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key,
                self._pointer,
                _UniffiConverterTypePrivateKey.lower(private_key),
            )
        )

    def notarize_with_signer(self, signer: "Signer") -> "NotarizedTransaction":

        return _UniffiConverterTypeNotarizedTransaction.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer,
                self._pointer,
                _UniffiConverterCallbackInterfaceSigner.lower(signer),
            )
        )

    def sign_with_private_key(
        self, private_key: "PrivateKey"
    ) -> "TransactionBuilderIntentSignaturesStep":

        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key,
                self._pointer,
                _UniffiConverterTypePrivateKey.lower(private_key),
            )
        )

    def sign_with_signer(
        self, signer: "Signer"
    ) -> "TransactionBuilderIntentSignaturesStep":

        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer,
                self._pointer,
                _UniffiConverterCallbackInterfaceSigner.lower(signer),
            )
        )


class _UniffiConverterTypeTransactionBuilderIntentSignaturesStep:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilderIntentSignaturesStep):
            raise TypeError(
                "Expected TransactionBuilderIntentSignaturesStep instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilderIntentSignaturesStep._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class TransactionBuilderMessageStep:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    def message(self, message: "Message") -> "TransactionBuilderIntentSignaturesStep":

        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message,
                self._pointer,
                _UniffiConverterTypeMessage.lower(message),
            )
        )

    def sign_with_private_key(
        self, private_key: "PrivateKey"
    ) -> "TransactionBuilderIntentSignaturesStep":

        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key,
                self._pointer,
                _UniffiConverterTypePrivateKey.lower(private_key),
            )
        )

    def sign_with_signer(
        self, signer: "Signer"
    ) -> "TransactionBuilderIntentSignaturesStep":

        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer,
                self._pointer,
                _UniffiConverterCallbackInterfaceSigner.lower(signer),
            )
        )


class _UniffiConverterTypeTransactionBuilderMessageStep:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilderMessageStep):
            raise TypeError(
                "Expected TransactionBuilderMessageStep instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilderMessageStep._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class TransactionHash:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_str(cls, string: "str", network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str,
            _UniffiConverterString.lower(string),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    def as_hash(
        self,
    ) -> "Hash":
        return _UniffiConverterTypeHash.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash,
                self._pointer,
            )
        )

    def as_str(
        self,
    ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str,
                self._pointer,
            )
        )

    def bytes(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes,
                self._pointer,
            )
        )

    def network_id(
        self,
    ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id,
                self._pointer,
            )
        )


class _UniffiConverterTypeTransactionHash:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionHash):
            raise TypeError(
                "Expected TransactionHash instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionHash._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class TransactionManifest:
    _pointer: ctypes.c_void_p

    def __init__(self, instructions: "Instructions", blobs: "typing.List[bytes]"):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new,
            _UniffiConverterTypeInstructions.lower(instructions),
            _UniffiConverterSequenceBytes.lower(blobs),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled: "bytes", network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_decompile,
            _UniffiConverterBytes.lower(compiled),
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    def blobs(
        self,
    ) -> "typing.List[bytes]":
        return _UniffiConverterSequenceBytes.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs,
                self._pointer,
            )
        )

    def compile(
        self,
    ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_compile,
                self._pointer,
            )
        )

    def execution_summary(
        self, network_id: "int", toolkit_receipt: "str"
    ) -> "ExecutionSummary":

        return _UniffiConverterTypeExecutionSummary.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_execution_summary,
                self._pointer,
                _UniffiConverterUInt8.lower(network_id),
                _UniffiConverterString.lower(toolkit_receipt),
            )
        )

    def extract_addresses(
        self,
    ) -> "dict":
        return _UniffiConverterMapTypeEntityTypeSequenceTypeAddress.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses,
                self._pointer,
            )
        )

    def instructions(
        self,
    ) -> "Instructions":
        return _UniffiConverterTypeInstructions.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions,
                self._pointer,
            )
        )

    def modify(
        self, modifications: "TransactionManifestModifications"
    ) -> "TransactionManifest":

        return _UniffiConverterTypeTransactionManifest.lift(
            _rust_call_with_error(
                _UniffiConverterTypeRadixEngineToolkitError,
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify,
                self._pointer,
                _UniffiConverterTypeTransactionManifestModifications.lower(
                    modifications
                ),
            )
        )

    def statically_validate(
        self,
    ):
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate,
            self._pointer,
        )

    def summary(self, network_id: "int") -> "ManifestSummary":

        return _UniffiConverterTypeManifestSummary.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_summary,
                self._pointer,
                _UniffiConverterUInt8.lower(network_id),
            )
        )


class _UniffiConverterTypeTransactionManifest:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionManifest):
            raise TypeError(
                "Expected TransactionManifest instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionManifest._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class ValidationConfig:
    _pointer: ctypes.c_void_p

    def __init__(
        self,
        network_id: "int",
        max_notarized_payload_size: "int",
        min_tip_percentage: "int",
        max_tip_percentage: "int",
        max_epoch_range: "int",
        message_validation: "MessageValidationConfig",
    ):

        self._pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new,
            _UniffiConverterUInt8.lower(network_id),
            _UniffiConverterUInt64.lower(max_notarized_payload_size),
            _UniffiConverterUInt16.lower(min_tip_percentage),
            _UniffiConverterUInt16.lower(max_tip_percentage),
            _UniffiConverterUInt64.lower(max_epoch_range),
            _UniffiConverterTypeMessageValidationConfig.lower(message_validation),
        )

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig,
                pointer,
            )

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def default(cls, network_id: "int"):

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default,
            _UniffiConverterUInt8.lower(network_id),
        )
        return cls._make_instance_(pointer)

    def max_epoch_range(
        self,
    ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range,
                self._pointer,
            )
        )

    def max_notarized_payload_size(
        self,
    ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size,
                self._pointer,
            )
        )

    def max_tip_percentage(
        self,
    ) -> "int":
        return _UniffiConverterUInt16.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage,
                self._pointer,
            )
        )

    def message_validation(
        self,
    ) -> "MessageValidationConfig":
        return _UniffiConverterTypeMessageValidationConfig.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation,
                self._pointer,
            )
        )

    def min_tip_percentage(
        self,
    ) -> "int":
        return _UniffiConverterUInt16.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage,
                self._pointer,
            )
        )

    def network_id(
        self,
    ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(
                _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id,
                self._pointer,
            )
        )


class _UniffiConverterTypeValidationConfig:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ValidationConfig):
            raise TypeError(
                "Expected ValidationConfig instance, {} found".format(
                    type(value).__name__
                )
            )
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ValidationConfig._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AccountAddAuthorizedDepositorEvent:
    authorized_depositor_badge: "ResourceOrNonFungible"

    @typing.no_type_check
    def __init__(self, authorized_depositor_badge: "ResourceOrNonFungible"):
        self.authorized_depositor_badge = authorized_depositor_badge

    def __str__(self):
        return (
            "AccountAddAuthorizedDepositorEvent(authorized_depositor_badge={})".format(
                self.authorized_depositor_badge
            )
        )

    def __eq__(self, other):
        if self.authorized_depositor_badge != other.authorized_depositor_badge:
            return False
        return True


class _UniffiConverterTypeAccountAddAuthorizedDepositorEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        return AccountAddAuthorizedDepositorEvent(
            authorized_depositor_badge=_UniffiConverterTypeResourceOrNonFungible.read(
                buf
            ),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeResourceOrNonFungible.write(
            value.authorized_depositor_badge, buf
        )


class AccountRemoveAuthorizedDepositorEvent:
    authorized_depositor_badge: "ResourceOrNonFungible"

    @typing.no_type_check
    def __init__(self, authorized_depositor_badge: "ResourceOrNonFungible"):
        self.authorized_depositor_badge = authorized_depositor_badge

    def __str__(self):
        return "AccountRemoveAuthorizedDepositorEvent(authorized_depositor_badge={})".format(
            self.authorized_depositor_badge
        )

    def __eq__(self, other):
        if self.authorized_depositor_badge != other.authorized_depositor_badge:
            return False
        return True


class _UniffiConverterTypeAccountRemoveAuthorizedDepositorEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        return AccountRemoveAuthorizedDepositorEvent(
            authorized_depositor_badge=_UniffiConverterTypeResourceOrNonFungible.read(
                buf
            ),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeResourceOrNonFungible.write(
            value.authorized_depositor_badge, buf
        )


class AccountRemoveResourcePreferenceEvent:
    resource_address: "Address"

    @typing.no_type_check
    def __init__(self, resource_address: "Address"):
        self.resource_address = resource_address

    def __str__(self):
        return "AccountRemoveResourcePreferenceEvent(resource_address={})".format(
            self.resource_address
        )

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        return True


class _UniffiConverterTypeAccountRemoveResourcePreferenceEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        return AccountRemoveResourcePreferenceEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)


class AccountSetDefaultDepositRuleEvent:
    default_deposit_rule: "AccountDefaultDepositRule"

    @typing.no_type_check
    def __init__(self, default_deposit_rule: "AccountDefaultDepositRule"):
        self.default_deposit_rule = default_deposit_rule

    def __str__(self):
        return "AccountSetDefaultDepositRuleEvent(default_deposit_rule={})".format(
            self.default_deposit_rule
        )

    def __eq__(self, other):
        if self.default_deposit_rule != other.default_deposit_rule:
            return False
        return True


class _UniffiConverterTypeAccountSetDefaultDepositRuleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountSetDefaultDepositRuleEvent(
            default_deposit_rule=_UniffiConverterTypeAccountDefaultDepositRule.read(
                buf
            ),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccountDefaultDepositRule.write(
            value.default_deposit_rule, buf
        )


class AccountSetResourcePreferenceEvent:
    resource_address: "Address"
    preference: "ResourcePreference"

    @typing.no_type_check
    def __init__(self, resource_address: "Address", preference: "ResourcePreference"):
        self.resource_address = resource_address
        self.preference = preference

    def __str__(self):
        return "AccountSetResourcePreferenceEvent(resource_address={}, preference={})".format(
            self.resource_address, self.preference
        )

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.preference != other.preference:
            return False
        return True


class _UniffiConverterTypeAccountSetResourcePreferenceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountSetResourcePreferenceEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            preference=_UniffiConverterTypeResourcePreference.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeResourcePreference.write(value.preference, buf)


class BadgeWithdrawEvent:
    proposer: "Proposer"

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "BadgeWithdrawEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True


class _UniffiConverterTypeBadgeWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BadgeWithdrawEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class BuildInformation:
    version: "str"
    scrypto_dependency: "DependencyInformation"

    @typing.no_type_check
    def __init__(self, version: "str", scrypto_dependency: "DependencyInformation"):
        self.version = version
        self.scrypto_dependency = scrypto_dependency

    def __str__(self):
        return "BuildInformation(version={}, scrypto_dependency={})".format(
            self.version, self.scrypto_dependency
        )

    def __eq__(self, other):
        if self.version != other.version:
            return False
        if self.scrypto_dependency != other.scrypto_dependency:
            return False
        return True


class _UniffiConverterTypeBuildInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuildInformation(
            version=_UniffiConverterString.read(buf),
            scrypto_dependency=_UniffiConverterTypeDependencyInformation.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.version, buf)
        _UniffiConverterTypeDependencyInformation.write(value.scrypto_dependency, buf)


class BurnFungibleResourceEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "BurnFungibleResourceEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeBurnFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BurnFungibleResourceEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class BurnNonFungibleResourceEvent:
    ids: "typing.List[NonFungibleLocalId]"

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "BurnNonFungibleResourceEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True


class _UniffiConverterTypeBurnNonFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BurnNonFungibleResourceEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class CancelBadgeWithdrawAttemptEvent:
    proposer: "Proposer"

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "CancelBadgeWithdrawAttemptEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True


class _UniffiConverterTypeCancelBadgeWithdrawAttemptEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CancelBadgeWithdrawAttemptEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class CancelRecoveryProposalEvent:
    proposer: "Proposer"

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "CancelRecoveryProposalEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True


class _UniffiConverterTypeCancelRecoveryProposalEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CancelRecoveryProposalEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class ClaimEvent:
    claimant: "Address"
    resource_address: "Address"
    resources: "ResourceSpecifier"

    @typing.no_type_check
    def __init__(
        self,
        claimant: "Address",
        resource_address: "Address",
        resources: "ResourceSpecifier",
    ):
        self.claimant = claimant
        self.resource_address = resource_address
        self.resources = resources

    def __str__(self):
        return "ClaimEvent(claimant={}, resource_address={}, resources={})".format(
            self.claimant, self.resource_address, self.resources
        )

    def __eq__(self, other):
        if self.claimant != other.claimant:
            return False
        if self.resource_address != other.resource_address:
            return False
        if self.resources != other.resources:
            return False
        return True


class _UniffiConverterTypeClaimEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimEvent(
            claimant=_UniffiConverterTypeAddress.read(buf),
            resource_address=_UniffiConverterTypeAddress.read(buf),
            resources=_UniffiConverterTypeResourceSpecifier.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.claimant, buf)
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeResourceSpecifier.write(value.resources, buf)


class ClaimXrdEvent:
    claimed_xrd: "Decimal"

    @typing.no_type_check
    def __init__(self, claimed_xrd: "Decimal"):
        self.claimed_xrd = claimed_xrd

    def __str__(self):
        return "ClaimXrdEvent(claimed_xrd={})".format(self.claimed_xrd)

    def __eq__(self, other):
        if self.claimed_xrd != other.claimed_xrd:
            return False
        return True


class _UniffiConverterTypeClaimXrdEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimXrdEvent(
            claimed_xrd=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.claimed_xrd, buf)


class ComponentAddresses:
    consensus_manager: "Address"
    genesis_helper: "Address"
    faucet: "Address"

    @typing.no_type_check
    def __init__(
        self, consensus_manager: "Address", genesis_helper: "Address", faucet: "Address"
    ):
        self.consensus_manager = consensus_manager
        self.genesis_helper = genesis_helper
        self.faucet = faucet

    def __str__(self):
        return "ComponentAddresses(consensus_manager={}, genesis_helper={}, faucet={})".format(
            self.consensus_manager, self.genesis_helper, self.faucet
        )

    def __eq__(self, other):
        if self.consensus_manager != other.consensus_manager:
            return False
        if self.genesis_helper != other.genesis_helper:
            return False
        if self.faucet != other.faucet:
            return False
        return True


class _UniffiConverterTypeComponentAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ComponentAddresses(
            consensus_manager=_UniffiConverterTypeAddress.read(buf),
            genesis_helper=_UniffiConverterTypeAddress.read(buf),
            faucet=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.consensus_manager, buf)
        _UniffiConverterTypeAddress.write(value.genesis_helper, buf)
        _UniffiConverterTypeAddress.write(value.faucet, buf)


class DepositRecoveryXrdEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "DepositRecoveryXrdEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeDepositRecoveryXrdEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DepositRecoveryXrdEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class Ed25519PublicKey:
    value: "bytes"

    @typing.no_type_check
    def __init__(self, value: "bytes"):
        self.value = value

    def __str__(self):
        return "Ed25519PublicKey(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeEd25519PublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Ed25519PublicKey(
            value=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.value, buf)


class EncryptedMessage:
    encrypted: "bytes"
    decryptors_by_curve: "dict"

    @typing.no_type_check
    def __init__(self, encrypted: "bytes", decryptors_by_curve: "dict"):
        self.encrypted = encrypted
        self.decryptors_by_curve = decryptors_by_curve

    def __str__(self):
        return "EncryptedMessage(encrypted={}, decryptors_by_curve={})".format(
            self.encrypted, self.decryptors_by_curve
        )

    def __eq__(self, other):
        if self.encrypted != other.encrypted:
            return False
        if self.decryptors_by_curve != other.decryptors_by_curve:
            return False
        return True


class _UniffiConverterTypeEncryptedMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedMessage(
            encrypted=_UniffiConverterBytes.read(buf),
            decryptors_by_curve=_UniffiConverterMapTypeCurveTypeTypeDecryptorsByCurve.read(
                buf
            ),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.encrypted, buf)
        _UniffiConverterMapTypeCurveTypeTypeDecryptorsByCurve.write(
            value.decryptors_by_curve, buf
        )


class EpochChangeEvent:
    epoch: "int"
    validator_set: "dict"

    @typing.no_type_check
    def __init__(self, epoch: "int", validator_set: "dict"):
        self.epoch = epoch
        self.validator_set = validator_set

    def __str__(self):
        return "EpochChangeEvent(epoch={}, validator_set={})".format(
            self.epoch, self.validator_set
        )

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.validator_set != other.validator_set:
            return False
        return True


class _UniffiConverterTypeEpochChangeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EpochChangeEvent(
            epoch=_UniffiConverterUInt64.read(buf),
            validator_set=_UniffiConverterMapStringTypeValidatorInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterMapStringTypeValidatorInfo.write(value.validator_set, buf)


class EventTypeIdentifier:
    emitter: "Emitter"
    event_name: "str"

    @typing.no_type_check
    def __init__(self, emitter: "Emitter", event_name: "str"):
        self.emitter = emitter
        self.event_name = event_name

    def __str__(self):
        return "EventTypeIdentifier(emitter={}, event_name={})".format(
            self.emitter, self.event_name
        )

    def __eq__(self, other):
        if self.emitter != other.emitter:
            return False
        if self.event_name != other.event_name:
            return False
        return True


class _UniffiConverterTypeEventTypeIdentifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EventTypeIdentifier(
            emitter=_UniffiConverterTypeEmitter.read(buf),
            event_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEmitter.write(value.emitter, buf)
        _UniffiConverterString.write(value.event_name, buf)


class ExecutionSummary:
    account_withdraws: "dict"
    account_deposits: "dict"
    presented_proofs: "dict"
    new_entities: "NewEntities"
    encountered_entities: "typing.List[Address]"
    accounts_requiring_auth: "typing.List[Address]"
    identities_requiring_auth: "typing.List[Address]"
    reserved_instructions: "typing.List[ReservedInstruction]"
    fee_locks: "FeeLocks"
    fee_summary: "FeeSummary"
    detailed_classification: "typing.List[DetailedManifestClass]"
    newly_created_non_fungibles: "typing.List[NonFungibleGlobalId]"

    @typing.no_type_check
    def __init__(
        self,
        account_withdraws: "dict",
        account_deposits: "dict",
        presented_proofs: "dict",
        new_entities: "NewEntities",
        encountered_entities: "typing.List[Address]",
        accounts_requiring_auth: "typing.List[Address]",
        identities_requiring_auth: "typing.List[Address]",
        reserved_instructions: "typing.List[ReservedInstruction]",
        fee_locks: "FeeLocks",
        fee_summary: "FeeSummary",
        detailed_classification: "typing.List[DetailedManifestClass]",
        newly_created_non_fungibles: "typing.List[NonFungibleGlobalId]",
    ):
        self.account_withdraws = account_withdraws
        self.account_deposits = account_deposits
        self.presented_proofs = presented_proofs
        self.new_entities = new_entities
        self.encountered_entities = encountered_entities
        self.accounts_requiring_auth = accounts_requiring_auth
        self.identities_requiring_auth = identities_requiring_auth
        self.reserved_instructions = reserved_instructions
        self.fee_locks = fee_locks
        self.fee_summary = fee_summary
        self.detailed_classification = detailed_classification
        self.newly_created_non_fungibles = newly_created_non_fungibles

    def __str__(self):
        return "ExecutionSummary(account_withdraws={}, account_deposits={}, presented_proofs={}, new_entities={}, encountered_entities={}, accounts_requiring_auth={}, identities_requiring_auth={}, reserved_instructions={}, fee_locks={}, fee_summary={}, detailed_classification={}, newly_created_non_fungibles={})".format(
            self.account_withdraws,
            self.account_deposits,
            self.presented_proofs,
            self.new_entities,
            self.encountered_entities,
            self.accounts_requiring_auth,
            self.identities_requiring_auth,
            self.reserved_instructions,
            self.fee_locks,
            self.fee_summary,
            self.detailed_classification,
            self.newly_created_non_fungibles,
        )

    def __eq__(self, other):
        if self.account_withdraws != other.account_withdraws:
            return False
        if self.account_deposits != other.account_deposits:
            return False
        if self.presented_proofs != other.presented_proofs:
            return False
        if self.new_entities != other.new_entities:
            return False
        if self.encountered_entities != other.encountered_entities:
            return False
        if self.accounts_requiring_auth != other.accounts_requiring_auth:
            return False
        if self.identities_requiring_auth != other.identities_requiring_auth:
            return False
        if self.reserved_instructions != other.reserved_instructions:
            return False
        if self.fee_locks != other.fee_locks:
            return False
        if self.fee_summary != other.fee_summary:
            return False
        if self.detailed_classification != other.detailed_classification:
            return False
        if self.newly_created_non_fungibles != other.newly_created_non_fungibles:
            return False
        return True


class _UniffiConverterTypeExecutionSummary(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExecutionSummary(
            account_withdraws=_UniffiConverterMapStringSequenceTypeResourceIndicator.read(
                buf
            ),
            account_deposits=_UniffiConverterMapStringSequenceTypeResourceIndicator.read(
                buf
            ),
            presented_proofs=_UniffiConverterMapStringSequenceTypeResourceSpecifier.read(
                buf
            ),
            new_entities=_UniffiConverterTypeNewEntities.read(buf),
            encountered_entities=_UniffiConverterSequenceTypeAddress.read(buf),
            accounts_requiring_auth=_UniffiConverterSequenceTypeAddress.read(buf),
            identities_requiring_auth=_UniffiConverterSequenceTypeAddress.read(buf),
            reserved_instructions=_UniffiConverterSequenceTypeReservedInstruction.read(
                buf
            ),
            fee_locks=_UniffiConverterTypeFeeLocks.read(buf),
            fee_summary=_UniffiConverterTypeFeeSummary.read(buf),
            detailed_classification=_UniffiConverterSequenceTypeDetailedManifestClass.read(
                buf
            ),
            newly_created_non_fungibles=_UniffiConverterSequenceTypeNonFungibleGlobalId.read(
                buf
            ),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringSequenceTypeResourceIndicator.write(
            value.account_withdraws, buf
        )
        _UniffiConverterMapStringSequenceTypeResourceIndicator.write(
            value.account_deposits, buf
        )
        _UniffiConverterMapStringSequenceTypeResourceSpecifier.write(
            value.presented_proofs, buf
        )
        _UniffiConverterTypeNewEntities.write(value.new_entities, buf)
        _UniffiConverterSequenceTypeAddress.write(value.encountered_entities, buf)
        _UniffiConverterSequenceTypeAddress.write(value.accounts_requiring_auth, buf)
        _UniffiConverterSequenceTypeAddress.write(value.identities_requiring_auth, buf)
        _UniffiConverterSequenceTypeReservedInstruction.write(
            value.reserved_instructions, buf
        )
        _UniffiConverterTypeFeeLocks.write(value.fee_locks, buf)
        _UniffiConverterTypeFeeSummary.write(value.fee_summary, buf)
        _UniffiConverterSequenceTypeDetailedManifestClass.write(
            value.detailed_classification, buf
        )
        _UniffiConverterSequenceTypeNonFungibleGlobalId.write(
            value.newly_created_non_fungibles, buf
        )


class FeeLocks:
    lock: "Decimal"
    contingent_lock: "Decimal"

    @typing.no_type_check
    def __init__(self, lock: "Decimal", contingent_lock: "Decimal"):
        self.lock = lock
        self.contingent_lock = contingent_lock

    def __str__(self):
        return "FeeLocks(lock={}, contingent_lock={})".format(
            self.lock, self.contingent_lock
        )

    def __eq__(self, other):
        if self.lock != other.lock:
            return False
        if self.contingent_lock != other.contingent_lock:
            return False
        return True


class _UniffiConverterTypeFeeLocks(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeLocks(
            lock=_UniffiConverterTypeDecimal.read(buf),
            contingent_lock=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.lock, buf)
        _UniffiConverterTypeDecimal.write(value.contingent_lock, buf)


class FeeSummary:
    execution_cost: "Decimal"
    finalization_cost: "Decimal"
    storage_expansion_cost: "Decimal"
    royalty_cost: "Decimal"

    @typing.no_type_check
    def __init__(
        self,
        execution_cost: "Decimal",
        finalization_cost: "Decimal",
        storage_expansion_cost: "Decimal",
        royalty_cost: "Decimal",
    ):
        self.execution_cost = execution_cost
        self.finalization_cost = finalization_cost
        self.storage_expansion_cost = storage_expansion_cost
        self.royalty_cost = royalty_cost

    def __str__(self):
        return "FeeSummary(execution_cost={}, finalization_cost={}, storage_expansion_cost={}, royalty_cost={})".format(
            self.execution_cost,
            self.finalization_cost,
            self.storage_expansion_cost,
            self.royalty_cost,
        )

    def __eq__(self, other):
        if self.execution_cost != other.execution_cost:
            return False
        if self.finalization_cost != other.finalization_cost:
            return False
        if self.storage_expansion_cost != other.storage_expansion_cost:
            return False
        if self.royalty_cost != other.royalty_cost:
            return False
        return True


class _UniffiConverterTypeFeeSummary(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeSummary(
            execution_cost=_UniffiConverterTypeDecimal.read(buf),
            finalization_cost=_UniffiConverterTypeDecimal.read(buf),
            storage_expansion_cost=_UniffiConverterTypeDecimal.read(buf),
            royalty_cost=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.execution_cost, buf)
        _UniffiConverterTypeDecimal.write(value.finalization_cost, buf)
        _UniffiConverterTypeDecimal.write(value.storage_expansion_cost, buf)
        _UniffiConverterTypeDecimal.write(value.royalty_cost, buf)


class FungibleResourceRoles:
    mint_roles: "typing.Optional[ResourceManagerRole]"
    burn_roles: "typing.Optional[ResourceManagerRole]"
    freeze_roles: "typing.Optional[ResourceManagerRole]"
    recall_roles: "typing.Optional[ResourceManagerRole]"
    withdraw_roles: "typing.Optional[ResourceManagerRole]"
    deposit_roles: "typing.Optional[ResourceManagerRole]"

    @typing.no_type_check
    def __init__(
        self,
        mint_roles: "typing.Optional[ResourceManagerRole]",
        burn_roles: "typing.Optional[ResourceManagerRole]",
        freeze_roles: "typing.Optional[ResourceManagerRole]",
        recall_roles: "typing.Optional[ResourceManagerRole]",
        withdraw_roles: "typing.Optional[ResourceManagerRole]",
        deposit_roles: "typing.Optional[ResourceManagerRole]",
    ):
        self.mint_roles = mint_roles
        self.burn_roles = burn_roles
        self.freeze_roles = freeze_roles
        self.recall_roles = recall_roles
        self.withdraw_roles = withdraw_roles
        self.deposit_roles = deposit_roles

    def __str__(self):
        return "FungibleResourceRoles(mint_roles={}, burn_roles={}, freeze_roles={}, recall_roles={}, withdraw_roles={}, deposit_roles={})".format(
            self.mint_roles,
            self.burn_roles,
            self.freeze_roles,
            self.recall_roles,
            self.withdraw_roles,
            self.deposit_roles,
        )

    def __eq__(self, other):
        if self.mint_roles != other.mint_roles:
            return False
        if self.burn_roles != other.burn_roles:
            return False
        if self.freeze_roles != other.freeze_roles:
            return False
        if self.recall_roles != other.recall_roles:
            return False
        if self.withdraw_roles != other.withdraw_roles:
            return False
        if self.deposit_roles != other.deposit_roles:
            return False
        return True


class _UniffiConverterTypeFungibleResourceRoles(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleResourceRoles(
            mint_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            burn_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            freeze_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            recall_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            withdraw_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            deposit_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.mint_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.burn_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.freeze_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.recall_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.withdraw_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.deposit_roles, buf)


class FungibleVaultDepositEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "FungibleVaultDepositEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeFungibleVaultDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleVaultDepositEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class FungibleVaultLockFeeEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "FungibleVaultLockFeeEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeFungibleVaultLockFeeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleVaultLockFeeEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class FungibleVaultPayFeeEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "FungibleVaultPayFeeEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeFungibleVaultPayFeeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleVaultPayFeeEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class FungibleVaultRecallEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "FungibleVaultRecallEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeFungibleVaultRecallEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleVaultRecallEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class FungibleVaultWithdrawEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "FungibleVaultWithdrawEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeFungibleVaultWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleVaultWithdrawEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class IndexedAssertion:
    index: "int"
    assertion: "Assertion"

    @typing.no_type_check
    def __init__(self, index: "int", assertion: "Assertion"):
        self.index = index
        self.assertion = assertion

    def __str__(self):
        return "IndexedAssertion(index={}, assertion={})".format(
            self.index, self.assertion
        )

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.assertion != other.assertion:
            return False
        return True


class _UniffiConverterTypeIndexedAssertion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IndexedAssertion(
            index=_UniffiConverterUInt64.read(buf),
            assertion=_UniffiConverterTypeAssertion.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.index, buf)
        _UniffiConverterTypeAssertion.write(value.assertion, buf)


class InitiateBadgeWithdrawAttemptEvent:
    proposer: "Proposer"

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "InitiateBadgeWithdrawAttemptEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True


class _UniffiConverterTypeInitiateBadgeWithdrawAttemptEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InitiateBadgeWithdrawAttemptEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class InitiateRecoveryEvent:
    proposer: "Proposer"
    proposal: "RecoveryProposal"

    @typing.no_type_check
    def __init__(self, proposer: "Proposer", proposal: "RecoveryProposal"):
        self.proposer = proposer
        self.proposal = proposal

    def __str__(self):
        return "InitiateRecoveryEvent(proposer={}, proposal={})".format(
            self.proposer, self.proposal
        )

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        if self.proposal != other.proposal:
            return False
        return True


class _UniffiConverterTypeInitiateRecoveryEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InitiateRecoveryEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
            proposal=_UniffiConverterTypeRecoveryProposal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)
        _UniffiConverterTypeRecoveryProposal.write(value.proposal, buf)


class KnownAddresses:
    resource_addresses: "ResourceAddresses"
    package_addresses: "PackageAddresses"
    component_addresses: "ComponentAddresses"

    @typing.no_type_check
    def __init__(
        self,
        resource_addresses: "ResourceAddresses",
        package_addresses: "PackageAddresses",
        component_addresses: "ComponentAddresses",
    ):
        self.resource_addresses = resource_addresses
        self.package_addresses = package_addresses
        self.component_addresses = component_addresses

    def __str__(self):
        return "KnownAddresses(resource_addresses={}, package_addresses={}, component_addresses={})".format(
            self.resource_addresses, self.package_addresses, self.component_addresses
        )

    def __eq__(self, other):
        if self.resource_addresses != other.resource_addresses:
            return False
        if self.package_addresses != other.package_addresses:
            return False
        if self.component_addresses != other.component_addresses:
            return False
        return True


class _UniffiConverterTypeKnownAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KnownAddresses(
            resource_addresses=_UniffiConverterTypeResourceAddresses.read(buf),
            package_addresses=_UniffiConverterTypePackageAddresses.read(buf),
            component_addresses=_UniffiConverterTypeComponentAddresses.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeResourceAddresses.write(value.resource_addresses, buf)
        _UniffiConverterTypePackageAddresses.write(value.package_addresses, buf)
        _UniffiConverterTypeComponentAddresses.write(value.component_addresses, buf)


class LockFeeModification:
    account_address: "Address"
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, account_address: "Address", amount: "Decimal"):
        self.account_address = account_address
        self.amount = amount

    def __str__(self):
        return "LockFeeModification(account_address={}, amount={})".format(
            self.account_address, self.amount
        )

    def __eq__(self, other):
        if self.account_address != other.account_address:
            return False
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeLockFeeModification(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockFeeModification(
            account_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.account_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class LockOwnerRoleEvent:
    placeholder_field: "bool"

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "LockOwnerRoleEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True


class _UniffiConverterTypeLockOwnerRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockOwnerRoleEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class LockPrimaryRoleEvent:
    placeholder_field: "bool"

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "LockPrimaryRoleEvent(placeholder_field={})".format(
            self.placeholder_field
        )

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True


class _UniffiConverterTypeLockPrimaryRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockPrimaryRoleEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class LockRoleEvent:
    role_key: "str"

    @typing.no_type_check
    def __init__(self, role_key: "str"):
        self.role_key = role_key

    def __str__(self):
        return "LockRoleEvent(role_key={})".format(self.role_key)

    def __eq__(self, other):
        if self.role_key != other.role_key:
            return False
        return True


class _UniffiConverterTypeLockRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockRoleEvent(
            role_key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.role_key, buf)


class ManifestAddressReservation:
    value: "int"

    @typing.no_type_check
    def __init__(self, value: "int"):
        self.value = value

    def __str__(self):
        return "ManifestAddressReservation(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeManifestAddressReservation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestAddressReservation(
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)


class ManifestBlobRef:
    value: "Hash"

    @typing.no_type_check
    def __init__(self, value: "Hash"):
        self.value = value

    def __str__(self):
        return "ManifestBlobRef(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeManifestBlobRef(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBlobRef(
            value=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.value, buf)


class ManifestBucket:
    value: "int"

    @typing.no_type_check
    def __init__(self, value: "int"):
        self.value = value

    def __str__(self):
        return "ManifestBucket(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeManifestBucket(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBucket(
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)


class ManifestBuilderAddressReservation:
    name: "str"

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderAddressReservation(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True


class _UniffiConverterTypeManifestBuilderAddressReservation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderAddressReservation(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestBuilderBucket:
    name: "str"

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderBucket(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True


class _UniffiConverterTypeManifestBuilderBucket(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderBucket(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestBuilderMapEntry:
    key: "ManifestBuilderValue"
    value: "ManifestBuilderValue"

    @typing.no_type_check
    def __init__(self, key: "ManifestBuilderValue", value: "ManifestBuilderValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "ManifestBuilderMapEntry(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeManifestBuilderMapEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderMapEntry(
            key=_UniffiConverterTypeManifestBuilderValue.read(buf),
            value=_UniffiConverterTypeManifestBuilderValue.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeManifestBuilderValue.write(value.key, buf)
        _UniffiConverterTypeManifestBuilderValue.write(value.value, buf)


class ManifestBuilderNamedAddress:
    name: "str"

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderNamedAddress(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True


class _UniffiConverterTypeManifestBuilderNamedAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderNamedAddress(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestBuilderProof:
    name: "str"

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderProof(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True


class _UniffiConverterTypeManifestBuilderProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderProof(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestProof:
    value: "int"

    @typing.no_type_check
    def __init__(self, value: "int"):
        self.value = value

    def __str__(self):
        return "ManifestProof(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeManifestProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestProof(
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)


class ManifestSummary:
    presented_proofs: "dict"
    accounts_withdrawn_from: "typing.List[Address]"
    accounts_deposited_into: "typing.List[Address]"
    encountered_entities: "typing.List[Address]"
    accounts_requiring_auth: "typing.List[Address]"
    identities_requiring_auth: "typing.List[Address]"
    reserved_instructions: "typing.List[ReservedInstruction]"
    classification: "typing.List[ManifestClass]"

    @typing.no_type_check
    def __init__(
        self,
        presented_proofs: "dict",
        accounts_withdrawn_from: "typing.List[Address]",
        accounts_deposited_into: "typing.List[Address]",
        encountered_entities: "typing.List[Address]",
        accounts_requiring_auth: "typing.List[Address]",
        identities_requiring_auth: "typing.List[Address]",
        reserved_instructions: "typing.List[ReservedInstruction]",
        classification: "typing.List[ManifestClass]",
    ):
        self.presented_proofs = presented_proofs
        self.accounts_withdrawn_from = accounts_withdrawn_from
        self.accounts_deposited_into = accounts_deposited_into
        self.encountered_entities = encountered_entities
        self.accounts_requiring_auth = accounts_requiring_auth
        self.identities_requiring_auth = identities_requiring_auth
        self.reserved_instructions = reserved_instructions
        self.classification = classification

    def __str__(self):
        return "ManifestSummary(presented_proofs={}, accounts_withdrawn_from={}, accounts_deposited_into={}, encountered_entities={}, accounts_requiring_auth={}, identities_requiring_auth={}, reserved_instructions={}, classification={})".format(
            self.presented_proofs,
            self.accounts_withdrawn_from,
            self.accounts_deposited_into,
            self.encountered_entities,
            self.accounts_requiring_auth,
            self.identities_requiring_auth,
            self.reserved_instructions,
            self.classification,
        )

    def __eq__(self, other):
        if self.presented_proofs != other.presented_proofs:
            return False
        if self.accounts_withdrawn_from != other.accounts_withdrawn_from:
            return False
        if self.accounts_deposited_into != other.accounts_deposited_into:
            return False
        if self.encountered_entities != other.encountered_entities:
            return False
        if self.accounts_requiring_auth != other.accounts_requiring_auth:
            return False
        if self.identities_requiring_auth != other.identities_requiring_auth:
            return False
        if self.reserved_instructions != other.reserved_instructions:
            return False
        if self.classification != other.classification:
            return False
        return True


class _UniffiConverterTypeManifestSummary(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestSummary(
            presented_proofs=_UniffiConverterMapStringSequenceTypeResourceSpecifier.read(
                buf
            ),
            accounts_withdrawn_from=_UniffiConverterSequenceTypeAddress.read(buf),
            accounts_deposited_into=_UniffiConverterSequenceTypeAddress.read(buf),
            encountered_entities=_UniffiConverterSequenceTypeAddress.read(buf),
            accounts_requiring_auth=_UniffiConverterSequenceTypeAddress.read(buf),
            identities_requiring_auth=_UniffiConverterSequenceTypeAddress.read(buf),
            reserved_instructions=_UniffiConverterSequenceTypeReservedInstruction.read(
                buf
            ),
            classification=_UniffiConverterSequenceTypeManifestClass.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringSequenceTypeResourceSpecifier.write(
            value.presented_proofs, buf
        )
        _UniffiConverterSequenceTypeAddress.write(value.accounts_withdrawn_from, buf)
        _UniffiConverterSequenceTypeAddress.write(value.accounts_deposited_into, buf)
        _UniffiConverterSequenceTypeAddress.write(value.encountered_entities, buf)
        _UniffiConverterSequenceTypeAddress.write(value.accounts_requiring_auth, buf)
        _UniffiConverterSequenceTypeAddress.write(value.identities_requiring_auth, buf)
        _UniffiConverterSequenceTypeReservedInstruction.write(
            value.reserved_instructions, buf
        )
        _UniffiConverterSequenceTypeManifestClass.write(value.classification, buf)


class MapEntry:
    key: "ManifestValue"
    value: "ManifestValue"

    @typing.no_type_check
    def __init__(self, key: "ManifestValue", value: "ManifestValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "MapEntry(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeMapEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MapEntry(
            key=_UniffiConverterTypeManifestValue.read(buf),
            value=_UniffiConverterTypeManifestValue.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeManifestValue.write(value.key, buf)
        _UniffiConverterTypeManifestValue.write(value.value, buf)


class MetadataInitEntry:
    value: "typing.Optional[MetadataValue]"
    lock: "bool"

    @typing.no_type_check
    def __init__(self, value: "typing.Optional[MetadataValue]", lock: "bool"):
        self.value = value
        self.lock = lock

    def __str__(self):
        return "MetadataInitEntry(value={}, lock={})".format(self.value, self.lock)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.lock != other.lock:
            return False
        return True


class _UniffiConverterTypeMetadataInitEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataInitEntry(
            value=_UniffiConverterOptionalTypeMetadataValue.read(buf),
            lock=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeMetadataValue.write(value.value, buf)
        _UniffiConverterBool.write(value.lock, buf)


class MetadataModuleConfig:
    init: "dict"
    roles: "dict"

    @typing.no_type_check
    def __init__(self, init: "dict", roles: "dict"):
        self.init = init
        self.roles = roles

    def __str__(self):
        return "MetadataModuleConfig(init={}, roles={})".format(self.init, self.roles)

    def __eq__(self, other):
        if self.init != other.init:
            return False
        if self.roles != other.roles:
            return False
        return True


class _UniffiConverterTypeMetadataModuleConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataModuleConfig(
            init=_UniffiConverterMapStringTypeMetadataInitEntry.read(buf),
            roles=_UniffiConverterMapStringOptionalTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringTypeMetadataInitEntry.write(value.init, buf)
        _UniffiConverterMapStringOptionalTypeAccessRule.write(value.roles, buf)


class MintFungibleResourceEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "MintFungibleResourceEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeMintFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MintFungibleResourceEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class MintNonFungibleResourceEvent:
    ids: "typing.List[NonFungibleLocalId]"

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "MintNonFungibleResourceEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True


class _UniffiConverterTypeMintNonFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MintNonFungibleResourceEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class MultiResourcePoolContributionEvent:
    contributed_resources: "dict"
    pool_units_minted: "Decimal"

    @typing.no_type_check
    def __init__(self, contributed_resources: "dict", pool_units_minted: "Decimal"):
        self.contributed_resources = contributed_resources
        self.pool_units_minted = pool_units_minted

    def __str__(self):
        return "MultiResourcePoolContributionEvent(contributed_resources={}, pool_units_minted={})".format(
            self.contributed_resources, self.pool_units_minted
        )

    def __eq__(self, other):
        if self.contributed_resources != other.contributed_resources:
            return False
        if self.pool_units_minted != other.pool_units_minted:
            return False
        return True


class _UniffiConverterTypeMultiResourcePoolContributionEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        return MultiResourcePoolContributionEvent(
            contributed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
            pool_units_minted=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringTypeDecimal.write(value.contributed_resources, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_minted, buf)


class MultiResourcePoolDepositEvent:
    resource_address: "Address"
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "MultiResourcePoolDepositEvent(resource_address={}, amount={})".format(
            self.resource_address, self.amount
        )

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeMultiResourcePoolDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolDepositEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class MultiResourcePoolRedemptionEvent:
    pool_unit_tokens_redeemed: "Decimal"
    redeemed_resources: "dict"

    @typing.no_type_check
    def __init__(
        self, pool_unit_tokens_redeemed: "Decimal", redeemed_resources: "dict"
    ):
        self.pool_unit_tokens_redeemed = pool_unit_tokens_redeemed
        self.redeemed_resources = redeemed_resources

    def __str__(self):
        return "MultiResourcePoolRedemptionEvent(pool_unit_tokens_redeemed={}, redeemed_resources={})".format(
            self.pool_unit_tokens_redeemed, self.redeemed_resources
        )

    def __eq__(self, other):
        if self.pool_unit_tokens_redeemed != other.pool_unit_tokens_redeemed:
            return False
        if self.redeemed_resources != other.redeemed_resources:
            return False
        return True


class _UniffiConverterTypeMultiResourcePoolRedemptionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolRedemptionEvent(
            pool_unit_tokens_redeemed=_UniffiConverterTypeDecimal.read(buf),
            redeemed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.pool_unit_tokens_redeemed, buf)
        _UniffiConverterMapStringTypeDecimal.write(value.redeemed_resources, buf)


class MultiResourcePoolWithdrawEvent:
    resource_address: "Address"
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "MultiResourcePoolWithdrawEvent(resource_address={}, amount={})".format(
            self.resource_address, self.amount
        )

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeMultiResourcePoolWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolWithdrawEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class NewEntities:
    component_addresses: "typing.List[Address]"
    resource_addresses: "typing.List[Address]"
    package_addresses: "typing.List[Address]"
    metadata: "dict"

    @typing.no_type_check
    def __init__(
        self,
        component_addresses: "typing.List[Address]",
        resource_addresses: "typing.List[Address]",
        package_addresses: "typing.List[Address]",
        metadata: "dict",
    ):
        self.component_addresses = component_addresses
        self.resource_addresses = resource_addresses
        self.package_addresses = package_addresses
        self.metadata = metadata

    def __str__(self):
        return "NewEntities(component_addresses={}, resource_addresses={}, package_addresses={}, metadata={})".format(
            self.component_addresses,
            self.resource_addresses,
            self.package_addresses,
            self.metadata,
        )

    def __eq__(self, other):
        if self.component_addresses != other.component_addresses:
            return False
        if self.resource_addresses != other.resource_addresses:
            return False
        if self.package_addresses != other.package_addresses:
            return False
        if self.metadata != other.metadata:
            return False
        return True


class _UniffiConverterTypeNewEntities(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NewEntities(
            component_addresses=_UniffiConverterSequenceTypeAddress.read(buf),
            resource_addresses=_UniffiConverterSequenceTypeAddress.read(buf),
            package_addresses=_UniffiConverterSequenceTypeAddress.read(buf),
            metadata=_UniffiConverterMapStringMapStringOptionalTypeMetadataValue.read(
                buf
            ),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeAddress.write(value.component_addresses, buf)
        _UniffiConverterSequenceTypeAddress.write(value.resource_addresses, buf)
        _UniffiConverterSequenceTypeAddress.write(value.package_addresses, buf)
        _UniffiConverterMapStringMapStringOptionalTypeMetadataValue.write(
            value.metadata, buf
        )


class NonFungibleVaultDepositEvent:
    ids: "typing.List[NonFungibleLocalId]"

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "NonFungibleVaultDepositEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True


class _UniffiConverterTypeNonFungibleVaultDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NonFungibleVaultDepositEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class NonFungibleVaultRecallEvent:
    ids: "typing.List[NonFungibleLocalId]"

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "NonFungibleVaultRecallEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True


class _UniffiConverterTypeNonFungibleVaultRecallEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NonFungibleVaultRecallEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class NonFungibleVaultWithdrawEvent:
    ids: "typing.List[NonFungibleLocalId]"

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "NonFungibleVaultWithdrawEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True


class _UniffiConverterTypeNonFungibleVaultWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NonFungibleVaultWithdrawEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class OneResourcePoolContributionEvent:
    amount_of_resources_contributed: "Decimal"
    pool_units_minted: "Decimal"

    @typing.no_type_check
    def __init__(
        self, amount_of_resources_contributed: "Decimal", pool_units_minted: "Decimal"
    ):
        self.amount_of_resources_contributed = amount_of_resources_contributed
        self.pool_units_minted = pool_units_minted

    def __str__(self):
        return "OneResourcePoolContributionEvent(amount_of_resources_contributed={}, pool_units_minted={})".format(
            self.amount_of_resources_contributed, self.pool_units_minted
        )

    def __eq__(self, other):
        if (
            self.amount_of_resources_contributed
            != other.amount_of_resources_contributed
        ):
            return False
        if self.pool_units_minted != other.pool_units_minted:
            return False
        return True


class _UniffiConverterTypeOneResourcePoolContributionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolContributionEvent(
            amount_of_resources_contributed=_UniffiConverterTypeDecimal.read(buf),
            pool_units_minted=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount_of_resources_contributed, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_minted, buf)


class OneResourcePoolDepositEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "OneResourcePoolDepositEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeOneResourcePoolDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolDepositEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class OneResourcePoolRedemptionEvent:
    pool_unit_tokens_redeemed: "Decimal"
    redeemed_amount: "Decimal"

    @typing.no_type_check
    def __init__(
        self, pool_unit_tokens_redeemed: "Decimal", redeemed_amount: "Decimal"
    ):
        self.pool_unit_tokens_redeemed = pool_unit_tokens_redeemed
        self.redeemed_amount = redeemed_amount

    def __str__(self):
        return "OneResourcePoolRedemptionEvent(pool_unit_tokens_redeemed={}, redeemed_amount={})".format(
            self.pool_unit_tokens_redeemed, self.redeemed_amount
        )

    def __eq__(self, other):
        if self.pool_unit_tokens_redeemed != other.pool_unit_tokens_redeemed:
            return False
        if self.redeemed_amount != other.redeemed_amount:
            return False
        return True


class _UniffiConverterTypeOneResourcePoolRedemptionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolRedemptionEvent(
            pool_unit_tokens_redeemed=_UniffiConverterTypeDecimal.read(buf),
            redeemed_amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.pool_unit_tokens_redeemed, buf)
        _UniffiConverterTypeDecimal.write(value.redeemed_amount, buf)


class OneResourcePoolWithdrawEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "OneResourcePoolWithdrawEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeOneResourcePoolWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolWithdrawEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class PackageAddresses:
    package_package: "Address"
    resource_package: "Address"
    account_package: "Address"
    identity_package: "Address"
    consensus_manager_package: "Address"
    access_controller_package: "Address"
    pool_package: "Address"
    transaction_processor_package: "Address"
    metadata_module_package: "Address"
    royalty_module_package: "Address"
    role_assignment_module_package: "Address"
    genesis_helper_package: "Address"
    faucet_package: "Address"

    @typing.no_type_check
    def __init__(
        self,
        package_package: "Address",
        resource_package: "Address",
        account_package: "Address",
        identity_package: "Address",
        consensus_manager_package: "Address",
        access_controller_package: "Address",
        pool_package: "Address",
        transaction_processor_package: "Address",
        metadata_module_package: "Address",
        royalty_module_package: "Address",
        role_assignment_module_package: "Address",
        genesis_helper_package: "Address",
        faucet_package: "Address",
    ):
        self.package_package = package_package
        self.resource_package = resource_package
        self.account_package = account_package
        self.identity_package = identity_package
        self.consensus_manager_package = consensus_manager_package
        self.access_controller_package = access_controller_package
        self.pool_package = pool_package
        self.transaction_processor_package = transaction_processor_package
        self.metadata_module_package = metadata_module_package
        self.royalty_module_package = royalty_module_package
        self.role_assignment_module_package = role_assignment_module_package
        self.genesis_helper_package = genesis_helper_package
        self.faucet_package = faucet_package

    def __str__(self):
        return "PackageAddresses(package_package={}, resource_package={}, account_package={}, identity_package={}, consensus_manager_package={}, access_controller_package={}, pool_package={}, transaction_processor_package={}, metadata_module_package={}, royalty_module_package={}, role_assignment_module_package={}, genesis_helper_package={}, faucet_package={})".format(
            self.package_package,
            self.resource_package,
            self.account_package,
            self.identity_package,
            self.consensus_manager_package,
            self.access_controller_package,
            self.pool_package,
            self.transaction_processor_package,
            self.metadata_module_package,
            self.royalty_module_package,
            self.role_assignment_module_package,
            self.genesis_helper_package,
            self.faucet_package,
        )

    def __eq__(self, other):
        if self.package_package != other.package_package:
            return False
        if self.resource_package != other.resource_package:
            return False
        if self.account_package != other.account_package:
            return False
        if self.identity_package != other.identity_package:
            return False
        if self.consensus_manager_package != other.consensus_manager_package:
            return False
        if self.access_controller_package != other.access_controller_package:
            return False
        if self.pool_package != other.pool_package:
            return False
        if self.transaction_processor_package != other.transaction_processor_package:
            return False
        if self.metadata_module_package != other.metadata_module_package:
            return False
        if self.royalty_module_package != other.royalty_module_package:
            return False
        if self.role_assignment_module_package != other.role_assignment_module_package:
            return False
        if self.genesis_helper_package != other.genesis_helper_package:
            return False
        if self.faucet_package != other.faucet_package:
            return False
        return True


class _UniffiConverterTypePackageAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PackageAddresses(
            package_package=_UniffiConverterTypeAddress.read(buf),
            resource_package=_UniffiConverterTypeAddress.read(buf),
            account_package=_UniffiConverterTypeAddress.read(buf),
            identity_package=_UniffiConverterTypeAddress.read(buf),
            consensus_manager_package=_UniffiConverterTypeAddress.read(buf),
            access_controller_package=_UniffiConverterTypeAddress.read(buf),
            pool_package=_UniffiConverterTypeAddress.read(buf),
            transaction_processor_package=_UniffiConverterTypeAddress.read(buf),
            metadata_module_package=_UniffiConverterTypeAddress.read(buf),
            royalty_module_package=_UniffiConverterTypeAddress.read(buf),
            role_assignment_module_package=_UniffiConverterTypeAddress.read(buf),
            genesis_helper_package=_UniffiConverterTypeAddress.read(buf),
            faucet_package=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.package_package, buf)
        _UniffiConverterTypeAddress.write(value.resource_package, buf)
        _UniffiConverterTypeAddress.write(value.account_package, buf)
        _UniffiConverterTypeAddress.write(value.identity_package, buf)
        _UniffiConverterTypeAddress.write(value.consensus_manager_package, buf)
        _UniffiConverterTypeAddress.write(value.access_controller_package, buf)
        _UniffiConverterTypeAddress.write(value.pool_package, buf)
        _UniffiConverterTypeAddress.write(value.transaction_processor_package, buf)
        _UniffiConverterTypeAddress.write(value.metadata_module_package, buf)
        _UniffiConverterTypeAddress.write(value.royalty_module_package, buf)
        _UniffiConverterTypeAddress.write(value.role_assignment_module_package, buf)
        _UniffiConverterTypeAddress.write(value.genesis_helper_package, buf)
        _UniffiConverterTypeAddress.write(value.faucet_package, buf)


class PlainTextMessage:
    mime_type: "str"
    message: "MessageContent"

    @typing.no_type_check
    def __init__(self, mime_type: "str", message: "MessageContent"):
        self.mime_type = mime_type
        self.message = message

    def __str__(self):
        return "PlainTextMessage(mime_type={}, message={})".format(
            self.mime_type, self.message
        )

    def __eq__(self, other):
        if self.mime_type != other.mime_type:
            return False
        if self.message != other.message:
            return False
        return True


class _UniffiConverterTypePlainTextMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlainTextMessage(
            mime_type=_UniffiConverterString.read(buf),
            message=_UniffiConverterTypeMessageContent.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.mime_type, buf)
        _UniffiConverterTypeMessageContent.write(value.message, buf)


class PredictedDecimal:
    value: "Decimal"
    instruction_index: "int"

    @typing.no_type_check
    def __init__(self, value: "Decimal", instruction_index: "int"):
        self.value = value
        self.instruction_index = instruction_index

    def __str__(self):
        return "PredictedDecimal(value={}, instruction_index={})".format(
            self.value, self.instruction_index
        )

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.instruction_index != other.instruction_index:
            return False
        return True


class _UniffiConverterTypePredictedDecimal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PredictedDecimal(
            value=_UniffiConverterTypeDecimal.read(buf),
            instruction_index=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.value, buf)
        _UniffiConverterUInt64.write(value.instruction_index, buf)


class PredictedNonFungibleIds:
    value: "typing.List[NonFungibleLocalId]"
    instruction_index: "int"

    @typing.no_type_check
    def __init__(
        self, value: "typing.List[NonFungibleLocalId]", instruction_index: "int"
    ):
        self.value = value
        self.instruction_index = instruction_index

    def __str__(self):
        return "PredictedNonFungibleIds(value={}, instruction_index={})".format(
            self.value, self.instruction_index
        )

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.instruction_index != other.instruction_index:
            return False
        return True


class _UniffiConverterTypePredictedNonFungibleIds(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PredictedNonFungibleIds(
            value=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            instruction_index=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)
        _UniffiConverterUInt64.write(value.instruction_index, buf)


class ProtocolUpdateReadinessSignalEvent:
    protocol_version_name: "str"

    @typing.no_type_check
    def __init__(self, protocol_version_name: "str"):
        self.protocol_version_name = protocol_version_name

    def __str__(self):
        return "ProtocolUpdateReadinessSignalEvent(protocol_version_name={})".format(
            self.protocol_version_name
        )

    def __eq__(self, other):
        if self.protocol_version_name != other.protocol_version_name:
            return False
        return True


class _UniffiConverterTypeProtocolUpdateReadinessSignalEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        return ProtocolUpdateReadinessSignalEvent(
            protocol_version_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.protocol_version_name, buf)


class PublicKeyFingerprint:
    bytes: "HashableBytes"

    @typing.no_type_check
    def __init__(self, bytes: "HashableBytes"):
        self.bytes = bytes

    def __str__(self):
        return "PublicKeyFingerprint(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True


class _UniffiConverterTypePublicKeyFingerprint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PublicKeyFingerprint(
            bytes=_UniffiConverterTypeHashableBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHashableBytes.write(value.bytes, buf)


class RecoverEvent:
    claimant: "Address"
    resource_address: "Address"
    resources: "ResourceSpecifier"

    @typing.no_type_check
    def __init__(
        self,
        claimant: "Address",
        resource_address: "Address",
        resources: "ResourceSpecifier",
    ):
        self.claimant = claimant
        self.resource_address = resource_address
        self.resources = resources

    def __str__(self):
        return "RecoverEvent(claimant={}, resource_address={}, resources={})".format(
            self.claimant, self.resource_address, self.resources
        )

    def __eq__(self, other):
        if self.claimant != other.claimant:
            return False
        if self.resource_address != other.resource_address:
            return False
        if self.resources != other.resources:
            return False
        return True


class _UniffiConverterTypeRecoverEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecoverEvent(
            claimant=_UniffiConverterTypeAddress.read(buf),
            resource_address=_UniffiConverterTypeAddress.read(buf),
            resources=_UniffiConverterTypeResourceSpecifier.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.claimant, buf)
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeResourceSpecifier.write(value.resources, buf)


class RecoveryProposal:
    rule_set: "RuleSet"
    timed_recovery_delay_in_minutes: "typing.Optional[int]"

    @typing.no_type_check
    def __init__(
        self,
        rule_set: "RuleSet",
        timed_recovery_delay_in_minutes: "typing.Optional[int]",
    ):
        self.rule_set = rule_set
        self.timed_recovery_delay_in_minutes = timed_recovery_delay_in_minutes

    def __str__(self):
        return (
            "RecoveryProposal(rule_set={}, timed_recovery_delay_in_minutes={})".format(
                self.rule_set, self.timed_recovery_delay_in_minutes
            )
        )

    def __eq__(self, other):
        if self.rule_set != other.rule_set:
            return False
        if (
            self.timed_recovery_delay_in_minutes
            != other.timed_recovery_delay_in_minutes
        ):
            return False
        return True


class _UniffiConverterTypeRecoveryProposal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecoveryProposal(
            rule_set=_UniffiConverterTypeRuleSet.read(buf),
            timed_recovery_delay_in_minutes=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRuleSet.write(value.rule_set, buf)
        _UniffiConverterOptionalUInt32.write(value.timed_recovery_delay_in_minutes, buf)


class RegisterValidatorEvent:
    placeholder_field: "bool"

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "RegisterValidatorEvent(placeholder_field={})".format(
            self.placeholder_field
        )

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True


class _UniffiConverterTypeRegisterValidatorEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RegisterValidatorEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class RemoveMetadataEvent:
    key: "str"

    @typing.no_type_check
    def __init__(self, key: "str"):
        self.key = key

    def __str__(self):
        return "RemoveMetadataEvent(key={})".format(self.key)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        return True


class _UniffiConverterTypeRemoveMetadataEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RemoveMetadataEvent(
            key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)


class ResourceAddresses:
    xrd: "Address"
    secp256k1_signature_virtual_badge: "Address"
    ed25519_signature_virtual_badge: "Address"
    package_of_direct_caller_virtual_badge: "Address"
    global_caller_virtual_badge: "Address"
    system_transaction_badge: "Address"
    package_owner_badge: "Address"
    validator_owner_badge: "Address"
    account_owner_badge: "Address"
    identity_owner_badge: "Address"

    @typing.no_type_check
    def __init__(
        self,
        xrd: "Address",
        secp256k1_signature_virtual_badge: "Address",
        ed25519_signature_virtual_badge: "Address",
        package_of_direct_caller_virtual_badge: "Address",
        global_caller_virtual_badge: "Address",
        system_transaction_badge: "Address",
        package_owner_badge: "Address",
        validator_owner_badge: "Address",
        account_owner_badge: "Address",
        identity_owner_badge: "Address",
    ):
        self.xrd = xrd
        self.secp256k1_signature_virtual_badge = secp256k1_signature_virtual_badge
        self.ed25519_signature_virtual_badge = ed25519_signature_virtual_badge
        self.package_of_direct_caller_virtual_badge = (
            package_of_direct_caller_virtual_badge
        )
        self.global_caller_virtual_badge = global_caller_virtual_badge
        self.system_transaction_badge = system_transaction_badge
        self.package_owner_badge = package_owner_badge
        self.validator_owner_badge = validator_owner_badge
        self.account_owner_badge = account_owner_badge
        self.identity_owner_badge = identity_owner_badge

    def __str__(self):
        return "ResourceAddresses(xrd={}, secp256k1_signature_virtual_badge={}, ed25519_signature_virtual_badge={}, package_of_direct_caller_virtual_badge={}, global_caller_virtual_badge={}, system_transaction_badge={}, package_owner_badge={}, validator_owner_badge={}, account_owner_badge={}, identity_owner_badge={})".format(
            self.xrd,
            self.secp256k1_signature_virtual_badge,
            self.ed25519_signature_virtual_badge,
            self.package_of_direct_caller_virtual_badge,
            self.global_caller_virtual_badge,
            self.system_transaction_badge,
            self.package_owner_badge,
            self.validator_owner_badge,
            self.account_owner_badge,
            self.identity_owner_badge,
        )

    def __eq__(self, other):
        if self.xrd != other.xrd:
            return False
        if (
            self.secp256k1_signature_virtual_badge
            != other.secp256k1_signature_virtual_badge
        ):
            return False
        if (
            self.ed25519_signature_virtual_badge
            != other.ed25519_signature_virtual_badge
        ):
            return False
        if (
            self.package_of_direct_caller_virtual_badge
            != other.package_of_direct_caller_virtual_badge
        ):
            return False
        if self.global_caller_virtual_badge != other.global_caller_virtual_badge:
            return False
        if self.system_transaction_badge != other.system_transaction_badge:
            return False
        if self.package_owner_badge != other.package_owner_badge:
            return False
        if self.validator_owner_badge != other.validator_owner_badge:
            return False
        if self.account_owner_badge != other.account_owner_badge:
            return False
        if self.identity_owner_badge != other.identity_owner_badge:
            return False
        return True


class _UniffiConverterTypeResourceAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ResourceAddresses(
            xrd=_UniffiConverterTypeAddress.read(buf),
            secp256k1_signature_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            ed25519_signature_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            package_of_direct_caller_virtual_badge=_UniffiConverterTypeAddress.read(
                buf
            ),
            global_caller_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            system_transaction_badge=_UniffiConverterTypeAddress.read(buf),
            package_owner_badge=_UniffiConverterTypeAddress.read(buf),
            validator_owner_badge=_UniffiConverterTypeAddress.read(buf),
            account_owner_badge=_UniffiConverterTypeAddress.read(buf),
            identity_owner_badge=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.xrd, buf)
        _UniffiConverterTypeAddress.write(value.secp256k1_signature_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(value.ed25519_signature_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(
            value.package_of_direct_caller_virtual_badge, buf
        )
        _UniffiConverterTypeAddress.write(value.global_caller_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(value.system_transaction_badge, buf)
        _UniffiConverterTypeAddress.write(value.package_owner_badge, buf)
        _UniffiConverterTypeAddress.write(value.validator_owner_badge, buf)
        _UniffiConverterTypeAddress.write(value.account_owner_badge, buf)
        _UniffiConverterTypeAddress.write(value.identity_owner_badge, buf)


class ResourceManagerRole:
    role: "typing.Optional[AccessRule]"
    role_updater: "typing.Optional[AccessRule]"

    @typing.no_type_check
    def __init__(
        self,
        role: "typing.Optional[AccessRule]",
        role_updater: "typing.Optional[AccessRule]",
    ):
        self.role = role
        self.role_updater = role_updater

    def __str__(self):
        return "ResourceManagerRole(role={}, role_updater={})".format(
            self.role, self.role_updater
        )

    def __eq__(self, other):
        if self.role != other.role:
            return False
        if self.role_updater != other.role_updater:
            return False
        return True


class _UniffiConverterTypeResourceManagerRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ResourceManagerRole(
            role=_UniffiConverterOptionalTypeAccessRule.read(buf),
            role_updater=_UniffiConverterOptionalTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeAccessRule.write(value.role, buf)
        _UniffiConverterOptionalTypeAccessRule.write(value.role_updater, buf)


class RoundChangeEvent:
    round: "int"

    @typing.no_type_check
    def __init__(self, round: "int"):
        self.round = round

    def __str__(self):
        return "RoundChangeEvent(round={})".format(self.round)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        return True


class _UniffiConverterTypeRoundChangeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RoundChangeEvent(
            round=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)


class RuleSet:
    primary_role: "AccessRule"
    recovery_role: "AccessRule"
    confirmation_role: "AccessRule"

    @typing.no_type_check
    def __init__(
        self,
        primary_role: "AccessRule",
        recovery_role: "AccessRule",
        confirmation_role: "AccessRule",
    ):
        self.primary_role = primary_role
        self.recovery_role = recovery_role
        self.confirmation_role = confirmation_role

    def __str__(self):
        return (
            "RuleSet(primary_role={}, recovery_role={}, confirmation_role={})".format(
                self.primary_role, self.recovery_role, self.confirmation_role
            )
        )

    def __eq__(self, other):
        if self.primary_role != other.primary_role:
            return False
        if self.recovery_role != other.recovery_role:
            return False
        if self.confirmation_role != other.confirmation_role:
            return False
        return True


class _UniffiConverterTypeRuleSet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RuleSet(
            primary_role=_UniffiConverterTypeAccessRule.read(buf),
            recovery_role=_UniffiConverterTypeAccessRule.read(buf),
            confirmation_role=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessRule.write(value.primary_role, buf)
        _UniffiConverterTypeAccessRule.write(value.recovery_role, buf)
        _UniffiConverterTypeAccessRule.write(value.confirmation_role, buf)


class RuleSetUpdateEvent:
    proposer: "Proposer"
    proposal: "RecoveryProposal"

    @typing.no_type_check
    def __init__(self, proposer: "Proposer", proposal: "RecoveryProposal"):
        self.proposer = proposer
        self.proposal = proposal

    def __str__(self):
        return "RuleSetUpdateEvent(proposer={}, proposal={})".format(
            self.proposer, self.proposal
        )

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        if self.proposal != other.proposal:
            return False
        return True


class _UniffiConverterTypeRuleSetUpdateEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RuleSetUpdateEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
            proposal=_UniffiConverterTypeRecoveryProposal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)
        _UniffiConverterTypeRecoveryProposal.write(value.proposal, buf)


class Schema:
    local_type_id: "LocalTypeId"
    schema: "bytes"

    @typing.no_type_check
    def __init__(self, local_type_id: "LocalTypeId", schema: "bytes"):
        self.local_type_id = local_type_id
        self.schema = schema

    def __str__(self):
        return "Schema(local_type_id={}, schema={})".format(
            self.local_type_id, self.schema
        )

    def __eq__(self, other):
        if self.local_type_id != other.local_type_id:
            return False
        if self.schema != other.schema:
            return False
        return True


class _UniffiConverterTypeSchema(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Schema(
            local_type_id=_UniffiConverterTypeLocalTypeId.read(buf),
            schema=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLocalTypeId.write(value.local_type_id, buf)
        _UniffiConverterBytes.write(value.schema, buf)


class Secp256k1PublicKey:
    value: "bytes"

    @typing.no_type_check
    def __init__(self, value: "bytes"):
        self.value = value

    def __str__(self):
        return "Secp256k1PublicKey(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeSecp256k1PublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Secp256k1PublicKey(
            value=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.value, buf)


class SecurityStructureRole:
    super_admin_factors: "typing.List[PublicKey]"
    threshold_factors: "typing.List[PublicKey]"
    threshold: "int"

    @typing.no_type_check
    def __init__(
        self,
        super_admin_factors: "typing.List[PublicKey]",
        threshold_factors: "typing.List[PublicKey]",
        threshold: "int",
    ):
        self.super_admin_factors = super_admin_factors
        self.threshold_factors = threshold_factors
        self.threshold = threshold

    def __str__(self):
        return "SecurityStructureRole(super_admin_factors={}, threshold_factors={}, threshold={})".format(
            self.super_admin_factors, self.threshold_factors, self.threshold
        )

    def __eq__(self, other):
        if self.super_admin_factors != other.super_admin_factors:
            return False
        if self.threshold_factors != other.threshold_factors:
            return False
        if self.threshold != other.threshold:
            return False
        return True


class _UniffiConverterTypeSecurityStructureRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SecurityStructureRole(
            super_admin_factors=_UniffiConverterSequenceTypePublicKey.read(buf),
            threshold_factors=_UniffiConverterSequenceTypePublicKey.read(buf),
            threshold=_UniffiConverterUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePublicKey.write(value.super_admin_factors, buf)
        _UniffiConverterSequenceTypePublicKey.write(value.threshold_factors, buf)
        _UniffiConverterUInt8.write(value.threshold, buf)


class SetAndLockRoleEvent:
    role_key: "str"
    rule: "AccessRule"

    @typing.no_type_check
    def __init__(self, role_key: "str", rule: "AccessRule"):
        self.role_key = role_key
        self.rule = rule

    def __str__(self):
        return "SetAndLockRoleEvent(role_key={}, rule={})".format(
            self.role_key, self.rule
        )

    def __eq__(self, other):
        if self.role_key != other.role_key:
            return False
        if self.rule != other.rule:
            return False
        return True


class _UniffiConverterTypeSetAndLockRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetAndLockRoleEvent(
            role_key=_UniffiConverterString.read(buf),
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.role_key, buf)
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class SetMetadataEvent:
    key: "str"
    value: "MetadataValue"

    @typing.no_type_check
    def __init__(self, key: "str", value: "MetadataValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "SetMetadataEvent(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True


class _UniffiConverterTypeSetMetadataEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetMetadataEvent(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterTypeMetadataValue.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterTypeMetadataValue.write(value.value, buf)


class SetOwnerRoleEvent:
    rule: "AccessRule"

    @typing.no_type_check
    def __init__(self, rule: "AccessRule"):
        self.rule = rule

    def __str__(self):
        return "SetOwnerRoleEvent(rule={})".format(self.rule)

    def __eq__(self, other):
        if self.rule != other.rule:
            return False
        return True


class _UniffiConverterTypeSetOwnerRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetOwnerRoleEvent(
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class SetRoleEvent:
    role_key: "str"
    rule: "AccessRule"

    @typing.no_type_check
    def __init__(self, role_key: "str", rule: "AccessRule"):
        self.role_key = role_key
        self.rule = rule

    def __str__(self):
        return "SetRoleEvent(role_key={}, rule={})".format(self.role_key, self.rule)

    def __eq__(self, other):
        if self.role_key != other.role_key:
            return False
        if self.rule != other.rule:
            return False
        return True


class _UniffiConverterTypeSetRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetRoleEvent(
            role_key=_UniffiConverterString.read(buf),
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.role_key, buf)
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class StakeEvent:
    xrd_staked: "Decimal"

    @typing.no_type_check
    def __init__(self, xrd_staked: "Decimal"):
        self.xrd_staked = xrd_staked

    def __str__(self):
        return "StakeEvent(xrd_staked={})".format(self.xrd_staked)

    def __eq__(self, other):
        if self.xrd_staked != other.xrd_staked:
            return False
        return True


class _UniffiConverterTypeStakeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StakeEvent(
            xrd_staked=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.xrd_staked, buf)


class StopTimedRecoveryEvent:
    placeholder_field: "bool"

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "StopTimedRecoveryEvent(placeholder_field={})".format(
            self.placeholder_field
        )

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True


class _UniffiConverterTypeStopTimedRecoveryEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StopTimedRecoveryEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class StoreEvent:
    claimant: "Address"
    resource_address: "Address"
    resources: "ResourceSpecifier"

    @typing.no_type_check
    def __init__(
        self,
        claimant: "Address",
        resource_address: "Address",
        resources: "ResourceSpecifier",
    ):
        self.claimant = claimant
        self.resource_address = resource_address
        self.resources = resources

    def __str__(self):
        return "StoreEvent(claimant={}, resource_address={}, resources={})".format(
            self.claimant, self.resource_address, self.resources
        )

    def __eq__(self, other):
        if self.claimant != other.claimant:
            return False
        if self.resource_address != other.resource_address:
            return False
        if self.resources != other.resources:
            return False
        return True


class _UniffiConverterTypeStoreEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StoreEvent(
            claimant=_UniffiConverterTypeAddress.read(buf),
            resource_address=_UniffiConverterTypeAddress.read(buf),
            resources=_UniffiConverterTypeResourceSpecifier.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.claimant, buf)
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeResourceSpecifier.write(value.resources, buf)


class TrackedPoolContribution:
    pool_address: "Address"
    contributed_resources: "dict"
    pool_units_resource_address: "Address"
    pool_units_amount: "Decimal"

    @typing.no_type_check
    def __init__(
        self,
        pool_address: "Address",
        contributed_resources: "dict",
        pool_units_resource_address: "Address",
        pool_units_amount: "Decimal",
    ):
        self.pool_address = pool_address
        self.contributed_resources = contributed_resources
        self.pool_units_resource_address = pool_units_resource_address
        self.pool_units_amount = pool_units_amount

    def __str__(self):
        return "TrackedPoolContribution(pool_address={}, contributed_resources={}, pool_units_resource_address={}, pool_units_amount={})".format(
            self.pool_address,
            self.contributed_resources,
            self.pool_units_resource_address,
            self.pool_units_amount,
        )

    def __eq__(self, other):
        if self.pool_address != other.pool_address:
            return False
        if self.contributed_resources != other.contributed_resources:
            return False
        if self.pool_units_resource_address != other.pool_units_resource_address:
            return False
        if self.pool_units_amount != other.pool_units_amount:
            return False
        return True


class _UniffiConverterTypeTrackedPoolContribution(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TrackedPoolContribution(
            pool_address=_UniffiConverterTypeAddress.read(buf),
            contributed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
            pool_units_resource_address=_UniffiConverterTypeAddress.read(buf),
            pool_units_amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.pool_address, buf)
        _UniffiConverterMapStringTypeDecimal.write(value.contributed_resources, buf)
        _UniffiConverterTypeAddress.write(value.pool_units_resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_amount, buf)


class TrackedPoolRedemption:
    pool_address: "Address"
    pool_units_resource_address: "Address"
    pool_units_amount: "Decimal"
    redeemed_resources: "dict"

    @typing.no_type_check
    def __init__(
        self,
        pool_address: "Address",
        pool_units_resource_address: "Address",
        pool_units_amount: "Decimal",
        redeemed_resources: "dict",
    ):
        self.pool_address = pool_address
        self.pool_units_resource_address = pool_units_resource_address
        self.pool_units_amount = pool_units_amount
        self.redeemed_resources = redeemed_resources

    def __str__(self):
        return "TrackedPoolRedemption(pool_address={}, pool_units_resource_address={}, pool_units_amount={}, redeemed_resources={})".format(
            self.pool_address,
            self.pool_units_resource_address,
            self.pool_units_amount,
            self.redeemed_resources,
        )

    def __eq__(self, other):
        if self.pool_address != other.pool_address:
            return False
        if self.pool_units_resource_address != other.pool_units_resource_address:
            return False
        if self.pool_units_amount != other.pool_units_amount:
            return False
        if self.redeemed_resources != other.redeemed_resources:
            return False
        return True


class _UniffiConverterTypeTrackedPoolRedemption(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TrackedPoolRedemption(
            pool_address=_UniffiConverterTypeAddress.read(buf),
            pool_units_resource_address=_UniffiConverterTypeAddress.read(buf),
            pool_units_amount=_UniffiConverterTypeDecimal.read(buf),
            redeemed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.pool_address, buf)
        _UniffiConverterTypeAddress.write(value.pool_units_resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_amount, buf)
        _UniffiConverterMapStringTypeDecimal.write(value.redeemed_resources, buf)


class TrackedValidatorClaim:
    validator_address: "Address"
    claim_nft_address: "Address"
    claim_nft_ids: "typing.List[NonFungibleLocalId]"
    xrd_amount: "Decimal"

    @typing.no_type_check
    def __init__(
        self,
        validator_address: "Address",
        claim_nft_address: "Address",
        claim_nft_ids: "typing.List[NonFungibleLocalId]",
        xrd_amount: "Decimal",
    ):
        self.validator_address = validator_address
        self.claim_nft_address = claim_nft_address
        self.claim_nft_ids = claim_nft_ids
        self.xrd_amount = xrd_amount

    def __str__(self):
        return "TrackedValidatorClaim(validator_address={}, claim_nft_address={}, claim_nft_ids={}, xrd_amount={})".format(
            self.validator_address,
            self.claim_nft_address,
            self.claim_nft_ids,
            self.xrd_amount,
        )

    def __eq__(self, other):
        if self.validator_address != other.validator_address:
            return False
        if self.claim_nft_address != other.claim_nft_address:
            return False
        if self.claim_nft_ids != other.claim_nft_ids:
            return False
        if self.xrd_amount != other.xrd_amount:
            return False
        return True


class _UniffiConverterTypeTrackedValidatorClaim(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TrackedValidatorClaim(
            validator_address=_UniffiConverterTypeAddress.read(buf),
            claim_nft_address=_UniffiConverterTypeAddress.read(buf),
            claim_nft_ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            xrd_amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.validator_address, buf)
        _UniffiConverterTypeAddress.write(value.claim_nft_address, buf)
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.claim_nft_ids, buf)
        _UniffiConverterTypeDecimal.write(value.xrd_amount, buf)


class TrackedValidatorStake:
    validator_address: "Address"
    xrd_amount: "Decimal"
    liquid_stake_unit_address: "Address"
    liquid_stake_unit_amount: "Decimal"

    @typing.no_type_check
    def __init__(
        self,
        validator_address: "Address",
        xrd_amount: "Decimal",
        liquid_stake_unit_address: "Address",
        liquid_stake_unit_amount: "Decimal",
    ):
        self.validator_address = validator_address
        self.xrd_amount = xrd_amount
        self.liquid_stake_unit_address = liquid_stake_unit_address
        self.liquid_stake_unit_amount = liquid_stake_unit_amount

    def __str__(self):
        return "TrackedValidatorStake(validator_address={}, xrd_amount={}, liquid_stake_unit_address={}, liquid_stake_unit_amount={})".format(
            self.validator_address,
            self.xrd_amount,
            self.liquid_stake_unit_address,
            self.liquid_stake_unit_amount,
        )

    def __eq__(self, other):
        if self.validator_address != other.validator_address:
            return False
        if self.xrd_amount != other.xrd_amount:
            return False
        if self.liquid_stake_unit_address != other.liquid_stake_unit_address:
            return False
        if self.liquid_stake_unit_amount != other.liquid_stake_unit_amount:
            return False
        return True


class _UniffiConverterTypeTrackedValidatorStake(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TrackedValidatorStake(
            validator_address=_UniffiConverterTypeAddress.read(buf),
            xrd_amount=_UniffiConverterTypeDecimal.read(buf),
            liquid_stake_unit_address=_UniffiConverterTypeAddress.read(buf),
            liquid_stake_unit_amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.validator_address, buf)
        _UniffiConverterTypeDecimal.write(value.xrd_amount, buf)
        _UniffiConverterTypeAddress.write(value.liquid_stake_unit_address, buf)
        _UniffiConverterTypeDecimal.write(value.liquid_stake_unit_amount, buf)


class TrackedValidatorUnstake:
    validator_address: "Address"
    liquid_stake_unit_address: "Address"
    liquid_stake_unit_amount: "Decimal"
    claim_nft_address: "Address"
    claim_nft_ids: "typing.List[NonFungibleLocalId]"

    @typing.no_type_check
    def __init__(
        self,
        validator_address: "Address",
        liquid_stake_unit_address: "Address",
        liquid_stake_unit_amount: "Decimal",
        claim_nft_address: "Address",
        claim_nft_ids: "typing.List[NonFungibleLocalId]",
    ):
        self.validator_address = validator_address
        self.liquid_stake_unit_address = liquid_stake_unit_address
        self.liquid_stake_unit_amount = liquid_stake_unit_amount
        self.claim_nft_address = claim_nft_address
        self.claim_nft_ids = claim_nft_ids

    def __str__(self):
        return "TrackedValidatorUnstake(validator_address={}, liquid_stake_unit_address={}, liquid_stake_unit_amount={}, claim_nft_address={}, claim_nft_ids={})".format(
            self.validator_address,
            self.liquid_stake_unit_address,
            self.liquid_stake_unit_amount,
            self.claim_nft_address,
            self.claim_nft_ids,
        )

    def __eq__(self, other):
        if self.validator_address != other.validator_address:
            return False
        if self.liquid_stake_unit_address != other.liquid_stake_unit_address:
            return False
        if self.liquid_stake_unit_amount != other.liquid_stake_unit_amount:
            return False
        if self.claim_nft_address != other.claim_nft_address:
            return False
        if self.claim_nft_ids != other.claim_nft_ids:
            return False
        return True


class _UniffiConverterTypeTrackedValidatorUnstake(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TrackedValidatorUnstake(
            validator_address=_UniffiConverterTypeAddress.read(buf),
            liquid_stake_unit_address=_UniffiConverterTypeAddress.read(buf),
            liquid_stake_unit_amount=_UniffiConverterTypeDecimal.read(buf),
            claim_nft_address=_UniffiConverterTypeAddress.read(buf),
            claim_nft_ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.validator_address, buf)
        _UniffiConverterTypeAddress.write(value.liquid_stake_unit_address, buf)
        _UniffiConverterTypeDecimal.write(value.liquid_stake_unit_amount, buf)
        _UniffiConverterTypeAddress.write(value.claim_nft_address, buf)
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.claim_nft_ids, buf)


class TransactionHeader:
    network_id: "int"
    start_epoch_inclusive: "int"
    end_epoch_exclusive: "int"
    nonce: "int"
    notary_public_key: "PublicKey"
    notary_is_signatory: "bool"
    tip_percentage: "int"

    @typing.no_type_check
    def __init__(
        self,
        network_id: "int",
        start_epoch_inclusive: "int",
        end_epoch_exclusive: "int",
        nonce: "int",
        notary_public_key: "PublicKey",
        notary_is_signatory: "bool",
        tip_percentage: "int",
    ):
        self.network_id = network_id
        self.start_epoch_inclusive = start_epoch_inclusive
        self.end_epoch_exclusive = end_epoch_exclusive
        self.nonce = nonce
        self.notary_public_key = notary_public_key
        self.notary_is_signatory = notary_is_signatory
        self.tip_percentage = tip_percentage

    def __str__(self):
        return "TransactionHeader(network_id={}, start_epoch_inclusive={}, end_epoch_exclusive={}, nonce={}, notary_public_key={}, notary_is_signatory={}, tip_percentage={})".format(
            self.network_id,
            self.start_epoch_inclusive,
            self.end_epoch_exclusive,
            self.nonce,
            self.notary_public_key,
            self.notary_is_signatory,
            self.tip_percentage,
        )

    def __eq__(self, other):
        if self.network_id != other.network_id:
            return False
        if self.start_epoch_inclusive != other.start_epoch_inclusive:
            return False
        if self.end_epoch_exclusive != other.end_epoch_exclusive:
            return False
        if self.nonce != other.nonce:
            return False
        if self.notary_public_key != other.notary_public_key:
            return False
        if self.notary_is_signatory != other.notary_is_signatory:
            return False
        if self.tip_percentage != other.tip_percentage:
            return False
        return True


class _UniffiConverterTypeTransactionHeader(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionHeader(
            network_id=_UniffiConverterUInt8.read(buf),
            start_epoch_inclusive=_UniffiConverterUInt64.read(buf),
            end_epoch_exclusive=_UniffiConverterUInt64.read(buf),
            nonce=_UniffiConverterUInt32.read(buf),
            notary_public_key=_UniffiConverterTypePublicKey.read(buf),
            notary_is_signatory=_UniffiConverterBool.read(buf),
            tip_percentage=_UniffiConverterUInt16.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.network_id, buf)
        _UniffiConverterUInt64.write(value.start_epoch_inclusive, buf)
        _UniffiConverterUInt64.write(value.end_epoch_exclusive, buf)
        _UniffiConverterUInt32.write(value.nonce, buf)
        _UniffiConverterTypePublicKey.write(value.notary_public_key, buf)
        _UniffiConverterBool.write(value.notary_is_signatory, buf)
        _UniffiConverterUInt16.write(value.tip_percentage, buf)


class TransactionManifestModifications:
    add_access_controller_proofs: "typing.List[Address]"
    add_lock_fee: "typing.Optional[LockFeeModification]"
    add_assertions: "typing.List[IndexedAssertion]"

    @typing.no_type_check
    def __init__(
        self,
        add_access_controller_proofs: "typing.List[Address]",
        add_lock_fee: "typing.Optional[LockFeeModification]",
        add_assertions: "typing.List[IndexedAssertion]",
    ):
        self.add_access_controller_proofs = add_access_controller_proofs
        self.add_lock_fee = add_lock_fee
        self.add_assertions = add_assertions

    def __str__(self):
        return "TransactionManifestModifications(add_access_controller_proofs={}, add_lock_fee={}, add_assertions={})".format(
            self.add_access_controller_proofs, self.add_lock_fee, self.add_assertions
        )

    def __eq__(self, other):
        if self.add_access_controller_proofs != other.add_access_controller_proofs:
            return False
        if self.add_lock_fee != other.add_lock_fee:
            return False
        if self.add_assertions != other.add_assertions:
            return False
        return True


class _UniffiConverterTypeTransactionManifestModifications(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionManifestModifications(
            add_access_controller_proofs=_UniffiConverterSequenceTypeAddress.read(buf),
            add_lock_fee=_UniffiConverterOptionalTypeLockFeeModification.read(buf),
            add_assertions=_UniffiConverterSequenceTypeIndexedAssertion.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeAddress.write(
            value.add_access_controller_proofs, buf
        )
        _UniffiConverterOptionalTypeLockFeeModification.write(value.add_lock_fee, buf)
        _UniffiConverterSequenceTypeIndexedAssertion.write(value.add_assertions, buf)


class TwoResourcePoolContributionEvent:
    contributed_resources: "dict"
    pool_units_minted: "Decimal"

    @typing.no_type_check
    def __init__(self, contributed_resources: "dict", pool_units_minted: "Decimal"):
        self.contributed_resources = contributed_resources
        self.pool_units_minted = pool_units_minted

    def __str__(self):
        return "TwoResourcePoolContributionEvent(contributed_resources={}, pool_units_minted={})".format(
            self.contributed_resources, self.pool_units_minted
        )

    def __eq__(self, other):
        if self.contributed_resources != other.contributed_resources:
            return False
        if self.pool_units_minted != other.pool_units_minted:
            return False
        return True


class _UniffiConverterTypeTwoResourcePoolContributionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolContributionEvent(
            contributed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
            pool_units_minted=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringTypeDecimal.write(value.contributed_resources, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_minted, buf)


class TwoResourcePoolDepositEvent:
    resource_address: "Address"
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "TwoResourcePoolDepositEvent(resource_address={}, amount={})".format(
            self.resource_address, self.amount
        )

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeTwoResourcePoolDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolDepositEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class TwoResourcePoolRedemptionEvent:
    pool_unit_tokens_redeemed: "Decimal"
    redeemed_resources: "dict"

    @typing.no_type_check
    def __init__(
        self, pool_unit_tokens_redeemed: "Decimal", redeemed_resources: "dict"
    ):
        self.pool_unit_tokens_redeemed = pool_unit_tokens_redeemed
        self.redeemed_resources = redeemed_resources

    def __str__(self):
        return "TwoResourcePoolRedemptionEvent(pool_unit_tokens_redeemed={}, redeemed_resources={})".format(
            self.pool_unit_tokens_redeemed, self.redeemed_resources
        )

    def __eq__(self, other):
        if self.pool_unit_tokens_redeemed != other.pool_unit_tokens_redeemed:
            return False
        if self.redeemed_resources != other.redeemed_resources:
            return False
        return True


class _UniffiConverterTypeTwoResourcePoolRedemptionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolRedemptionEvent(
            pool_unit_tokens_redeemed=_UniffiConverterTypeDecimal.read(buf),
            redeemed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.pool_unit_tokens_redeemed, buf)
        _UniffiConverterMapStringTypeDecimal.write(value.redeemed_resources, buf)


class TwoResourcePoolWithdrawEvent:
    resource_address: "Address"
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "TwoResourcePoolWithdrawEvent(resource_address={}, amount={})".format(
            self.resource_address, self.amount
        )

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeTwoResourcePoolWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolWithdrawEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class UnlockPrimaryRoleEvent:
    placeholder_field: "bool"

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "UnlockPrimaryRoleEvent(placeholder_field={})".format(
            self.placeholder_field
        )

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True


class _UniffiConverterTypeUnlockPrimaryRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnlockPrimaryRoleEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class UnregisterValidatorEvent:
    placeholder_field: "bool"

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "UnregisterValidatorEvent(placeholder_field={})".format(
            self.placeholder_field
        )

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True


class _UniffiConverterTypeUnregisterValidatorEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnregisterValidatorEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class UnstakeData:
    name: "str"
    claim_epoch: "int"
    claim_amount: "Decimal"

    @typing.no_type_check
    def __init__(self, name: "str", claim_epoch: "int", claim_amount: "Decimal"):
        self.name = name
        self.claim_epoch = claim_epoch
        self.claim_amount = claim_amount

    def __str__(self):
        return "UnstakeData(name={}, claim_epoch={}, claim_amount={})".format(
            self.name, self.claim_epoch, self.claim_amount
        )

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.claim_epoch != other.claim_epoch:
            return False
        if self.claim_amount != other.claim_amount:
            return False
        return True


class _UniffiConverterTypeUnstakeData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnstakeData(
            name=_UniffiConverterString.read(buf),
            claim_epoch=_UniffiConverterUInt64.read(buf),
            claim_amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt64.write(value.claim_epoch, buf)
        _UniffiConverterTypeDecimal.write(value.claim_amount, buf)


class UnstakeDataEntry:
    non_fungible_global_id: "NonFungibleGlobalId"
    data: "UnstakeData"

    @typing.no_type_check
    def __init__(
        self, non_fungible_global_id: "NonFungibleGlobalId", data: "UnstakeData"
    ):
        self.non_fungible_global_id = non_fungible_global_id
        self.data = data

    def __str__(self):
        return "UnstakeDataEntry(non_fungible_global_id={}, data={})".format(
            self.non_fungible_global_id, self.data
        )

    def __eq__(self, other):
        if self.non_fungible_global_id != other.non_fungible_global_id:
            return False
        if self.data != other.data:
            return False
        return True


class _UniffiConverterTypeUnstakeDataEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnstakeDataEntry(
            non_fungible_global_id=_UniffiConverterTypeNonFungibleGlobalId.read(buf),
            data=_UniffiConverterTypeUnstakeData.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeNonFungibleGlobalId.write(value.non_fungible_global_id, buf)
        _UniffiConverterTypeUnstakeData.write(value.data, buf)


class UnstakeEvent:
    stake_units: "Decimal"

    @typing.no_type_check
    def __init__(self, stake_units: "Decimal"):
        self.stake_units = stake_units

    def __str__(self):
        return "UnstakeEvent(stake_units={})".format(self.stake_units)

    def __eq__(self, other):
        if self.stake_units != other.stake_units:
            return False
        return True


class _UniffiConverterTypeUnstakeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnstakeEvent(
            stake_units=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.stake_units, buf)


class UpdateAcceptingStakeDelegationStateEvent:
    accepts_delegation: "bool"

    @typing.no_type_check
    def __init__(self, accepts_delegation: "bool"):
        self.accepts_delegation = accepts_delegation

    def __str__(self):
        return "UpdateAcceptingStakeDelegationStateEvent(accepts_delegation={})".format(
            self.accepts_delegation
        )

    def __eq__(self, other):
        if self.accepts_delegation != other.accepts_delegation:
            return False
        return True


class _UniffiConverterTypeUpdateAcceptingStakeDelegationStateEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        return UpdateAcceptingStakeDelegationStateEvent(
            accepts_delegation=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.accepts_delegation, buf)


class ValidatorEmissionAppliedEvent:
    epoch: "int"
    starting_stake_pool_xrd: "Decimal"
    stake_pool_added_xrd: "Decimal"
    total_stake_unit_supply: "Decimal"
    validator_fee_xrd: "Decimal"
    proposals_made: "int"
    proposals_missed: "int"

    @typing.no_type_check
    def __init__(
        self,
        epoch: "int",
        starting_stake_pool_xrd: "Decimal",
        stake_pool_added_xrd: "Decimal",
        total_stake_unit_supply: "Decimal",
        validator_fee_xrd: "Decimal",
        proposals_made: "int",
        proposals_missed: "int",
    ):
        self.epoch = epoch
        self.starting_stake_pool_xrd = starting_stake_pool_xrd
        self.stake_pool_added_xrd = stake_pool_added_xrd
        self.total_stake_unit_supply = total_stake_unit_supply
        self.validator_fee_xrd = validator_fee_xrd
        self.proposals_made = proposals_made
        self.proposals_missed = proposals_missed

    def __str__(self):
        return "ValidatorEmissionAppliedEvent(epoch={}, starting_stake_pool_xrd={}, stake_pool_added_xrd={}, total_stake_unit_supply={}, validator_fee_xrd={}, proposals_made={}, proposals_missed={})".format(
            self.epoch,
            self.starting_stake_pool_xrd,
            self.stake_pool_added_xrd,
            self.total_stake_unit_supply,
            self.validator_fee_xrd,
            self.proposals_made,
            self.proposals_missed,
        )

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.starting_stake_pool_xrd != other.starting_stake_pool_xrd:
            return False
        if self.stake_pool_added_xrd != other.stake_pool_added_xrd:
            return False
        if self.total_stake_unit_supply != other.total_stake_unit_supply:
            return False
        if self.validator_fee_xrd != other.validator_fee_xrd:
            return False
        if self.proposals_made != other.proposals_made:
            return False
        if self.proposals_missed != other.proposals_missed:
            return False
        return True


class _UniffiConverterTypeValidatorEmissionAppliedEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorEmissionAppliedEvent(
            epoch=_UniffiConverterUInt64.read(buf),
            starting_stake_pool_xrd=_UniffiConverterTypeDecimal.read(buf),
            stake_pool_added_xrd=_UniffiConverterTypeDecimal.read(buf),
            total_stake_unit_supply=_UniffiConverterTypeDecimal.read(buf),
            validator_fee_xrd=_UniffiConverterTypeDecimal.read(buf),
            proposals_made=_UniffiConverterUInt64.read(buf),
            proposals_missed=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterTypeDecimal.write(value.starting_stake_pool_xrd, buf)
        _UniffiConverterTypeDecimal.write(value.stake_pool_added_xrd, buf)
        _UniffiConverterTypeDecimal.write(value.total_stake_unit_supply, buf)
        _UniffiConverterTypeDecimal.write(value.validator_fee_xrd, buf)
        _UniffiConverterUInt64.write(value.proposals_made, buf)
        _UniffiConverterUInt64.write(value.proposals_missed, buf)


class ValidatorInfo:
    key: "Secp256k1PublicKey"
    stake: "Decimal"

    @typing.no_type_check
    def __init__(self, key: "Secp256k1PublicKey", stake: "Decimal"):
        self.key = key
        self.stake = stake

    def __str__(self):
        return "ValidatorInfo(key={}, stake={})".format(self.key, self.stake)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.stake != other.stake:
            return False
        return True


class _UniffiConverterTypeValidatorInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorInfo(
            key=_UniffiConverterTypeSecp256k1PublicKey.read(buf),
            stake=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSecp256k1PublicKey.write(value.key, buf)
        _UniffiConverterTypeDecimal.write(value.stake, buf)


class ValidatorRewardAppliedEvent:
    epoch: "int"
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, epoch: "int", amount: "Decimal"):
        self.epoch = epoch
        self.amount = amount

    def __str__(self):
        return "ValidatorRewardAppliedEvent(epoch={}, amount={})".format(
            self.epoch, self.amount
        )

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeValidatorRewardAppliedEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorRewardAppliedEvent(
            epoch=_UniffiConverterUInt64.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class VaultCreationEvent:
    vault_id: "Address"

    @typing.no_type_check
    def __init__(self, vault_id: "Address"):
        self.vault_id = vault_id

    def __str__(self):
        return "VaultCreationEvent(vault_id={})".format(self.vault_id)

    def __eq__(self, other):
        if self.vault_id != other.vault_id:
            return False
        return True


class _UniffiConverterTypeVaultCreationEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return VaultCreationEvent(
            vault_id=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.vault_id, buf)


class WithdrawRecoveryXrdEvent:
    amount: "Decimal"

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "WithdrawRecoveryXrdEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True


class _UniffiConverterTypeWithdrawRecoveryXrdEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WithdrawRecoveryXrdEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class AccountDefaultDepositRule(enum.Enum):
    ACCEPT = 1
    REJECT = 2
    ALLOW_EXISTING = 3


class _UniffiConverterTypeAccountDefaultDepositRule(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountDefaultDepositRule.ACCEPT
        if variant == 2:
            return AccountDefaultDepositRule.REJECT
        if variant == 3:
            return AccountDefaultDepositRule.ALLOW_EXISTING
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AccountDefaultDepositRule.ACCEPT:
            buf.write_i32(1)
        if value == AccountDefaultDepositRule.REJECT:
            buf.write_i32(2)
        if value == AccountDefaultDepositRule.ALLOW_EXISTING:
            buf.write_i32(3)


class AccountDepositEvent:
    def __init__(self):
        raise RuntimeError("AccountDepositEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return (
                "AccountDepositEvent.FUNGIBLE(resource_address={}, amount={})".format(
                    self.resource_address, self.amount
                )
            )

        def __eq__(self, other):
            if not other.is_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class NON_FUNGIBLE:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return (
                "AccountDepositEvent.NON_FUNGIBLE(resource_address={}, ids={})".format(
                    self.resource_address, self.ids
                )
            )

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible(self) -> bool:
        return isinstance(self, AccountDepositEvent.FUNGIBLE)

    def is_non_fungible(self) -> bool:
        return isinstance(self, AccountDepositEvent.NON_FUNGIBLE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AccountDepositEvent.FUNGIBLE = type(
    "AccountDepositEvent.FUNGIBLE",
    (
        AccountDepositEvent.FUNGIBLE,
        AccountDepositEvent,
    ),
    {},
)  # type: ignore
AccountDepositEvent.NON_FUNGIBLE = type(
    "AccountDepositEvent.NON_FUNGIBLE",
    (
        AccountDepositEvent.NON_FUNGIBLE,
        AccountDepositEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeAccountDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountDepositEvent.FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return AccountDepositEvent.NON_FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_non_fungible():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class AccountRejectedDepositEvent:
    def __init__(self):
        raise RuntimeError(
            "AccountRejectedDepositEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return "AccountRejectedDepositEvent.FUNGIBLE(resource_address={}, amount={})".format(
                self.resource_address, self.amount
            )

        def __eq__(self, other):
            if not other.is_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class NON_FUNGIBLE:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return "AccountRejectedDepositEvent.NON_FUNGIBLE(resource_address={}, ids={})".format(
                self.resource_address, self.ids
            )

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible(self) -> bool:
        return isinstance(self, AccountRejectedDepositEvent.FUNGIBLE)

    def is_non_fungible(self) -> bool:
        return isinstance(self, AccountRejectedDepositEvent.NON_FUNGIBLE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AccountRejectedDepositEvent.FUNGIBLE = type(
    "AccountRejectedDepositEvent.FUNGIBLE",
    (
        AccountRejectedDepositEvent.FUNGIBLE,
        AccountRejectedDepositEvent,
    ),
    {},
)  # type: ignore
AccountRejectedDepositEvent.NON_FUNGIBLE = type(
    "AccountRejectedDepositEvent.NON_FUNGIBLE",
    (
        AccountRejectedDepositEvent.NON_FUNGIBLE,
        AccountRejectedDepositEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeAccountRejectedDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountRejectedDepositEvent.FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return AccountRejectedDepositEvent.NON_FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_non_fungible():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class AccountWithdrawEvent:
    def __init__(self):
        raise RuntimeError("AccountWithdrawEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return (
                "AccountWithdrawEvent.FUNGIBLE(resource_address={}, amount={})".format(
                    self.resource_address, self.amount
                )
            )

        def __eq__(self, other):
            if not other.is_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class NON_FUNGIBLE:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return (
                "AccountWithdrawEvent.NON_FUNGIBLE(resource_address={}, ids={})".format(
                    self.resource_address, self.ids
                )
            )

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible(self) -> bool:
        return isinstance(self, AccountWithdrawEvent.FUNGIBLE)

    def is_non_fungible(self) -> bool:
        return isinstance(self, AccountWithdrawEvent.NON_FUNGIBLE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AccountWithdrawEvent.FUNGIBLE = type(
    "AccountWithdrawEvent.FUNGIBLE",
    (
        AccountWithdrawEvent.FUNGIBLE,
        AccountWithdrawEvent,
    ),
    {},
)  # type: ignore
AccountWithdrawEvent.NON_FUNGIBLE = type(
    "AccountWithdrawEvent.NON_FUNGIBLE",
    (
        AccountWithdrawEvent.NON_FUNGIBLE,
        AccountWithdrawEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeAccountWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountWithdrawEvent.FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return AccountWithdrawEvent.NON_FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_non_fungible():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class Assertion:
    def __init__(self):
        raise RuntimeError("Assertion cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return "Assertion.AMOUNT(resource_address={}, amount={})".format(
                self.resource_address, self.amount
            )

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class IDS:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return "Assertion.IDS(resource_address={}, ids={})".format(
                self.resource_address, self.ids
            )

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, Assertion.AMOUNT)

    def is_ids(self) -> bool:
        return isinstance(self, Assertion.IDS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Assertion.AMOUNT = type(
    "Assertion.AMOUNT",
    (
        Assertion.AMOUNT,
        Assertion,
    ),
    {},
)  # type: ignore
Assertion.IDS = type(
    "Assertion.IDS",
    (
        Assertion.IDS,
        Assertion,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeAssertion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Assertion.AMOUNT(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return Assertion.IDS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class Curve(enum.Enum):
    SECP256K1 = 1
    ED25519 = 2


class _UniffiConverterTypeCurve(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Curve.SECP256K1
        if variant == 2:
            return Curve.ED25519
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Curve.SECP256K1:
            buf.write_i32(1)
        if value == Curve.ED25519:
            buf.write_i32(2)


class CurveType(enum.Enum):
    ED25519 = 1
    SECP256K1 = 2


class _UniffiConverterTypeCurveType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CurveType.ED25519
        if variant == 2:
            return CurveType.SECP256K1
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == CurveType.ED25519:
            buf.write_i32(1)
        if value == CurveType.SECP256K1:
            buf.write_i32(2)


class DecryptorsByCurve:
    def __init__(self):
        raise RuntimeError("DecryptorsByCurve cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ED25519:
        dh_ephemeral_public_key: "Ed25519PublicKey"
        decryptors: "dict"

        @typing.no_type_check
        def __init__(
            self, dh_ephemeral_public_key: "Ed25519PublicKey", decryptors: "dict"
        ):

            self.dh_ephemeral_public_key = dh_ephemeral_public_key
            self.decryptors = decryptors

        def __str__(self):
            return "DecryptorsByCurve.ED25519(dh_ephemeral_public_key={}, decryptors={})".format(
                self.dh_ephemeral_public_key, self.decryptors
            )

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.dh_ephemeral_public_key != other.dh_ephemeral_public_key:
                return False
            if self.decryptors != other.decryptors:
                return False
            return True

    class SECP256K1:
        dh_ephemeral_public_key: "Secp256k1PublicKey"
        decryptors: "dict"

        @typing.no_type_check
        def __init__(
            self, dh_ephemeral_public_key: "Secp256k1PublicKey", decryptors: "dict"
        ):

            self.dh_ephemeral_public_key = dh_ephemeral_public_key
            self.decryptors = decryptors

        def __str__(self):
            return "DecryptorsByCurve.SECP256K1(dh_ephemeral_public_key={}, decryptors={})".format(
                self.dh_ephemeral_public_key, self.decryptors
            )

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.dh_ephemeral_public_key != other.dh_ephemeral_public_key:
                return False
            if self.decryptors != other.decryptors:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ed25519(self) -> bool:
        return isinstance(self, DecryptorsByCurve.ED25519)

    def is_secp256k1(self) -> bool:
        return isinstance(self, DecryptorsByCurve.SECP256K1)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DecryptorsByCurve.ED25519 = type(
    "DecryptorsByCurve.ED25519",
    (
        DecryptorsByCurve.ED25519,
        DecryptorsByCurve,
    ),
    {},
)  # type: ignore
DecryptorsByCurve.SECP256K1 = type(
    "DecryptorsByCurve.SECP256K1",
    (
        DecryptorsByCurve.SECP256K1,
        DecryptorsByCurve,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeDecryptorsByCurve(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DecryptorsByCurve.ED25519(
                _UniffiConverterTypeEd25519PublicKey.read(buf),
                _UniffiConverterMapTypePublicKeyFingerprintBytes.read(buf),
            )
        if variant == 2:
            return DecryptorsByCurve.SECP256K1(
                _UniffiConverterTypeSecp256k1PublicKey.read(buf),
                _UniffiConverterMapTypePublicKeyFingerprintBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ed25519():
            buf.write_i32(1)
            _UniffiConverterTypeEd25519PublicKey.write(
                value.dh_ephemeral_public_key, buf
            )
            _UniffiConverterMapTypePublicKeyFingerprintBytes.write(
                value.decryptors, buf
            )
        if value.is_secp256k1():
            buf.write_i32(2)
            _UniffiConverterTypeSecp256k1PublicKey.write(
                value.dh_ephemeral_public_key, buf
            )
            _UniffiConverterMapTypePublicKeyFingerprintBytes.write(
                value.decryptors, buf
            )


class DependencyInformation:
    def __init__(self):
        raise RuntimeError("DependencyInformation cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class VERSION:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "DependencyInformation.VERSION(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_version():
                return False
            if self.value != other.value:
                return False
            return True

    class TAG:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "DependencyInformation.TAG(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_tag():
                return False
            if self.value != other.value:
                return False
            return True

    class BRANCH:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "DependencyInformation.BRANCH(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_branch():
                return False
            if self.value != other.value:
                return False
            return True

    class REV:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "DependencyInformation.REV(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_rev():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_version(self) -> bool:
        return isinstance(self, DependencyInformation.VERSION)

    def is_tag(self) -> bool:
        return isinstance(self, DependencyInformation.TAG)

    def is_branch(self) -> bool:
        return isinstance(self, DependencyInformation.BRANCH)

    def is_rev(self) -> bool:
        return isinstance(self, DependencyInformation.REV)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DependencyInformation.VERSION = type(
    "DependencyInformation.VERSION",
    (
        DependencyInformation.VERSION,
        DependencyInformation,
    ),
    {},
)  # type: ignore
DependencyInformation.TAG = type(
    "DependencyInformation.TAG",
    (
        DependencyInformation.TAG,
        DependencyInformation,
    ),
    {},
)  # type: ignore
DependencyInformation.BRANCH = type(
    "DependencyInformation.BRANCH",
    (
        DependencyInformation.BRANCH,
        DependencyInformation,
    ),
    {},
)  # type: ignore
DependencyInformation.REV = type(
    "DependencyInformation.REV",
    (
        DependencyInformation.REV,
        DependencyInformation,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeDependencyInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DependencyInformation.VERSION(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return DependencyInformation.TAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return DependencyInformation.BRANCH(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return DependencyInformation.REV(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_version():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_tag():
            buf.write_i32(2)
            _UniffiConverterString.write(value.value, buf)
        if value.is_branch():
            buf.write_i32(3)
            _UniffiConverterString.write(value.value, buf)
        if value.is_rev():
            buf.write_i32(4)
            _UniffiConverterString.write(value.value, buf)


class DepositResourceEvent:
    def __init__(self):
        raise RuntimeError("DepositResourceEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "DepositResourceEvent.AMOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.value != other.value:
                return False
            return True

    class IDS:
        value: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[NonFungibleLocalId]"):

            self.value = value

        def __str__(self):
            return "DepositResourceEvent.IDS(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, DepositResourceEvent.AMOUNT)

    def is_ids(self) -> bool:
        return isinstance(self, DepositResourceEvent.IDS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DepositResourceEvent.AMOUNT = type(
    "DepositResourceEvent.AMOUNT",
    (
        DepositResourceEvent.AMOUNT,
        DepositResourceEvent,
    ),
    {},
)  # type: ignore
DepositResourceEvent.IDS = type(
    "DepositResourceEvent.IDS",
    (
        DepositResourceEvent.IDS,
        DepositResourceEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeDepositResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DepositResourceEvent.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return DepositResourceEvent.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)


class DetailedManifestClass:
    def __init__(self):
        raise RuntimeError("DetailedManifestClass cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GENERAL:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "DetailedManifestClass.GENERAL()".format()

        def __eq__(self, other):
            if not other.is_general():
                return False
            return True

    class TRANSFER:
        is_one_to_one: "bool"

        @typing.no_type_check
        def __init__(self, is_one_to_one: "bool"):

            self.is_one_to_one = is_one_to_one

        def __str__(self):
            return "DetailedManifestClass.TRANSFER(is_one_to_one={})".format(
                self.is_one_to_one
            )

        def __eq__(self, other):
            if not other.is_transfer():
                return False
            if self.is_one_to_one != other.is_one_to_one:
                return False
            return True

    class POOL_CONTRIBUTION:
        pool_addresses: "typing.List[Address]"
        pool_contributions: "typing.List[TrackedPoolContribution]"

        @typing.no_type_check
        def __init__(
            self,
            pool_addresses: "typing.List[Address]",
            pool_contributions: "typing.List[TrackedPoolContribution]",
        ):

            self.pool_addresses = pool_addresses
            self.pool_contributions = pool_contributions

        def __str__(self):
            return "DetailedManifestClass.POOL_CONTRIBUTION(pool_addresses={}, pool_contributions={})".format(
                self.pool_addresses, self.pool_contributions
            )

        def __eq__(self, other):
            if not other.is_pool_contribution():
                return False
            if self.pool_addresses != other.pool_addresses:
                return False
            if self.pool_contributions != other.pool_contributions:
                return False
            return True

    class POOL_REDEMPTION:
        pool_addresses: "typing.List[Address]"
        pool_redemptions: "typing.List[TrackedPoolRedemption]"

        @typing.no_type_check
        def __init__(
            self,
            pool_addresses: "typing.List[Address]",
            pool_redemptions: "typing.List[TrackedPoolRedemption]",
        ):

            self.pool_addresses = pool_addresses
            self.pool_redemptions = pool_redemptions

        def __str__(self):
            return "DetailedManifestClass.POOL_REDEMPTION(pool_addresses={}, pool_redemptions={})".format(
                self.pool_addresses, self.pool_redemptions
            )

        def __eq__(self, other):
            if not other.is_pool_redemption():
                return False
            if self.pool_addresses != other.pool_addresses:
                return False
            if self.pool_redemptions != other.pool_redemptions:
                return False
            return True

    class VALIDATOR_STAKE:
        validator_addresses: "typing.List[Address]"
        validator_stakes: "typing.List[TrackedValidatorStake]"

        @typing.no_type_check
        def __init__(
            self,
            validator_addresses: "typing.List[Address]",
            validator_stakes: "typing.List[TrackedValidatorStake]",
        ):

            self.validator_addresses = validator_addresses
            self.validator_stakes = validator_stakes

        def __str__(self):
            return "DetailedManifestClass.VALIDATOR_STAKE(validator_addresses={}, validator_stakes={})".format(
                self.validator_addresses, self.validator_stakes
            )

        def __eq__(self, other):
            if not other.is_validator_stake():
                return False
            if self.validator_addresses != other.validator_addresses:
                return False
            if self.validator_stakes != other.validator_stakes:
                return False
            return True

    class VALIDATOR_UNSTAKE:
        validator_addresses: "typing.List[Address]"
        validator_unstakes: "typing.List[TrackedValidatorUnstake]"
        claims_non_fungible_data: "typing.List[UnstakeDataEntry]"

        @typing.no_type_check
        def __init__(
            self,
            validator_addresses: "typing.List[Address]",
            validator_unstakes: "typing.List[TrackedValidatorUnstake]",
            claims_non_fungible_data: "typing.List[UnstakeDataEntry]",
        ):

            self.validator_addresses = validator_addresses
            self.validator_unstakes = validator_unstakes
            self.claims_non_fungible_data = claims_non_fungible_data

        def __str__(self):
            return "DetailedManifestClass.VALIDATOR_UNSTAKE(validator_addresses={}, validator_unstakes={}, claims_non_fungible_data={})".format(
                self.validator_addresses,
                self.validator_unstakes,
                self.claims_non_fungible_data,
            )

        def __eq__(self, other):
            if not other.is_validator_unstake():
                return False
            if self.validator_addresses != other.validator_addresses:
                return False
            if self.validator_unstakes != other.validator_unstakes:
                return False
            if self.claims_non_fungible_data != other.claims_non_fungible_data:
                return False
            return True

    class VALIDATOR_CLAIM:
        validator_addresses: "typing.List[Address]"
        validator_claims: "typing.List[TrackedValidatorClaim]"

        @typing.no_type_check
        def __init__(
            self,
            validator_addresses: "typing.List[Address]",
            validator_claims: "typing.List[TrackedValidatorClaim]",
        ):

            self.validator_addresses = validator_addresses
            self.validator_claims = validator_claims

        def __str__(self):
            return "DetailedManifestClass.VALIDATOR_CLAIM(validator_addresses={}, validator_claims={})".format(
                self.validator_addresses, self.validator_claims
            )

        def __eq__(self, other):
            if not other.is_validator_claim():
                return False
            if self.validator_addresses != other.validator_addresses:
                return False
            if self.validator_claims != other.validator_claims:
                return False
            return True

    class ACCOUNT_DEPOSIT_SETTINGS_UPDATE:
        resource_preferences_updates: "dict"
        deposit_mode_updates: "dict"
        authorized_depositors_added: "dict"
        authorized_depositors_removed: "dict"

        @typing.no_type_check
        def __init__(
            self,
            resource_preferences_updates: "dict",
            deposit_mode_updates: "dict",
            authorized_depositors_added: "dict",
            authorized_depositors_removed: "dict",
        ):

            self.resource_preferences_updates = resource_preferences_updates
            self.deposit_mode_updates = deposit_mode_updates
            self.authorized_depositors_added = authorized_depositors_added
            self.authorized_depositors_removed = authorized_depositors_removed

        def __str__(self):
            return "DetailedManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE(resource_preferences_updates={}, deposit_mode_updates={}, authorized_depositors_added={}, authorized_depositors_removed={})".format(
                self.resource_preferences_updates,
                self.deposit_mode_updates,
                self.authorized_depositors_added,
                self.authorized_depositors_removed,
            )

        def __eq__(self, other):
            if not other.is_account_deposit_settings_update():
                return False
            if self.resource_preferences_updates != other.resource_preferences_updates:
                return False
            if self.deposit_mode_updates != other.deposit_mode_updates:
                return False
            if self.authorized_depositors_added != other.authorized_depositors_added:
                return False
            if (
                self.authorized_depositors_removed
                != other.authorized_depositors_removed
            ):
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_general(self) -> bool:
        return isinstance(self, DetailedManifestClass.GENERAL)

    def is_transfer(self) -> bool:
        return isinstance(self, DetailedManifestClass.TRANSFER)

    def is_pool_contribution(self) -> bool:
        return isinstance(self, DetailedManifestClass.POOL_CONTRIBUTION)

    def is_pool_redemption(self) -> bool:
        return isinstance(self, DetailedManifestClass.POOL_REDEMPTION)

    def is_validator_stake(self) -> bool:
        return isinstance(self, DetailedManifestClass.VALIDATOR_STAKE)

    def is_validator_unstake(self) -> bool:
        return isinstance(self, DetailedManifestClass.VALIDATOR_UNSTAKE)

    def is_validator_claim(self) -> bool:
        return isinstance(self, DetailedManifestClass.VALIDATOR_CLAIM)

    def is_account_deposit_settings_update(self) -> bool:
        return isinstance(self, DetailedManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DetailedManifestClass.GENERAL = type(
    "DetailedManifestClass.GENERAL",
    (
        DetailedManifestClass.GENERAL,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.TRANSFER = type(
    "DetailedManifestClass.TRANSFER",
    (
        DetailedManifestClass.TRANSFER,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.POOL_CONTRIBUTION = type(
    "DetailedManifestClass.POOL_CONTRIBUTION",
    (
        DetailedManifestClass.POOL_CONTRIBUTION,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.POOL_REDEMPTION = type(
    "DetailedManifestClass.POOL_REDEMPTION",
    (
        DetailedManifestClass.POOL_REDEMPTION,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.VALIDATOR_STAKE = type(
    "DetailedManifestClass.VALIDATOR_STAKE",
    (
        DetailedManifestClass.VALIDATOR_STAKE,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.VALIDATOR_UNSTAKE = type(
    "DetailedManifestClass.VALIDATOR_UNSTAKE",
    (
        DetailedManifestClass.VALIDATOR_UNSTAKE,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.VALIDATOR_CLAIM = type(
    "DetailedManifestClass.VALIDATOR_CLAIM",
    (
        DetailedManifestClass.VALIDATOR_CLAIM,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore
DetailedManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE = type(
    "DetailedManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE",
    (
        DetailedManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE,
        DetailedManifestClass,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeDetailedManifestClass(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DetailedManifestClass.GENERAL()
        if variant == 2:
            return DetailedManifestClass.TRANSFER(
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return DetailedManifestClass.POOL_CONTRIBUTION(
                _UniffiConverterSequenceTypeAddress.read(buf),
                _UniffiConverterSequenceTypeTrackedPoolContribution.read(buf),
            )
        if variant == 4:
            return DetailedManifestClass.POOL_REDEMPTION(
                _UniffiConverterSequenceTypeAddress.read(buf),
                _UniffiConverterSequenceTypeTrackedPoolRedemption.read(buf),
            )
        if variant == 5:
            return DetailedManifestClass.VALIDATOR_STAKE(
                _UniffiConverterSequenceTypeAddress.read(buf),
                _UniffiConverterSequenceTypeTrackedValidatorStake.read(buf),
            )
        if variant == 6:
            return DetailedManifestClass.VALIDATOR_UNSTAKE(
                _UniffiConverterSequenceTypeAddress.read(buf),
                _UniffiConverterSequenceTypeTrackedValidatorUnstake.read(buf),
                _UniffiConverterSequenceTypeUnstakeDataEntry.read(buf),
            )
        if variant == 7:
            return DetailedManifestClass.VALIDATOR_CLAIM(
                _UniffiConverterSequenceTypeAddress.read(buf),
                _UniffiConverterSequenceTypeTrackedValidatorClaim.read(buf),
            )
        if variant == 8:
            return DetailedManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE(
                _UniffiConverterMapStringMapStringTypeResourcePreferenceUpdate.read(
                    buf
                ),
                _UniffiConverterMapStringTypeAccountDefaultDepositRule.read(buf),
                _UniffiConverterMapStringSequenceTypeResourceOrNonFungible.read(buf),
                _UniffiConverterMapStringSequenceTypeResourceOrNonFungible.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_general():
            buf.write_i32(1)
        if value.is_transfer():
            buf.write_i32(2)
            _UniffiConverterBool.write(value.is_one_to_one, buf)
        if value.is_pool_contribution():
            buf.write_i32(3)
            _UniffiConverterSequenceTypeAddress.write(value.pool_addresses, buf)
            _UniffiConverterSequenceTypeTrackedPoolContribution.write(
                value.pool_contributions, buf
            )
        if value.is_pool_redemption():
            buf.write_i32(4)
            _UniffiConverterSequenceTypeAddress.write(value.pool_addresses, buf)
            _UniffiConverterSequenceTypeTrackedPoolRedemption.write(
                value.pool_redemptions, buf
            )
        if value.is_validator_stake():
            buf.write_i32(5)
            _UniffiConverterSequenceTypeAddress.write(value.validator_addresses, buf)
            _UniffiConverterSequenceTypeTrackedValidatorStake.write(
                value.validator_stakes, buf
            )
        if value.is_validator_unstake():
            buf.write_i32(6)
            _UniffiConverterSequenceTypeAddress.write(value.validator_addresses, buf)
            _UniffiConverterSequenceTypeTrackedValidatorUnstake.write(
                value.validator_unstakes, buf
            )
            _UniffiConverterSequenceTypeUnstakeDataEntry.write(
                value.claims_non_fungible_data, buf
            )
        if value.is_validator_claim():
            buf.write_i32(7)
            _UniffiConverterSequenceTypeAddress.write(value.validator_addresses, buf)
            _UniffiConverterSequenceTypeTrackedValidatorClaim.write(
                value.validator_claims, buf
            )
        if value.is_account_deposit_settings_update():
            buf.write_i32(8)
            _UniffiConverterMapStringMapStringTypeResourcePreferenceUpdate.write(
                value.resource_preferences_updates, buf
            )
            _UniffiConverterMapStringTypeAccountDefaultDepositRule.write(
                value.deposit_mode_updates, buf
            )
            _UniffiConverterMapStringSequenceTypeResourceOrNonFungible.write(
                value.authorized_depositors_added, buf
            )
            _UniffiConverterMapStringSequenceTypeResourceOrNonFungible.write(
                value.authorized_depositors_removed, buf
            )


class Emitter:
    def __init__(self):
        raise RuntimeError("Emitter cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNCTION:
        address: "Address"
        blueprint_name: "str"

        @typing.no_type_check
        def __init__(self, address: "Address", blueprint_name: "str"):

            self.address = address
            self.blueprint_name = blueprint_name

        def __str__(self):
            return "Emitter.FUNCTION(address={}, blueprint_name={})".format(
                self.address, self.blueprint_name
            )

        def __eq__(self, other):
            if not other.is_function():
                return False
            if self.address != other.address:
                return False
            if self.blueprint_name != other.blueprint_name:
                return False
            return True

    class METHOD:
        address: "Address"
        object_module_id: "ModuleId"

        @typing.no_type_check
        def __init__(self, address: "Address", object_module_id: "ModuleId"):

            self.address = address
            self.object_module_id = object_module_id

        def __str__(self):
            return "Emitter.METHOD(address={}, object_module_id={})".format(
                self.address, self.object_module_id
            )

        def __eq__(self, other):
            if not other.is_method():
                return False
            if self.address != other.address:
                return False
            if self.object_module_id != other.object_module_id:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_function(self) -> bool:
        return isinstance(self, Emitter.FUNCTION)

    def is_method(self) -> bool:
        return isinstance(self, Emitter.METHOD)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Emitter.FUNCTION = type(
    "Emitter.FUNCTION",
    (
        Emitter.FUNCTION,
        Emitter,
    ),
    {},
)  # type: ignore
Emitter.METHOD = type(
    "Emitter.METHOD",
    (
        Emitter.METHOD,
        Emitter,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeEmitter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Emitter.FUNCTION(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return Emitter.METHOD(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeModuleId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_function():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterString.write(value.blueprint_name, buf)
        if value.is_method():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterTypeModuleId.write(value.object_module_id, buf)


class EntityType(enum.Enum):
    GLOBAL_PACKAGE = 1
    GLOBAL_FUNGIBLE_RESOURCE_MANAGER = 2
    GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER = 3
    GLOBAL_CONSENSUS_MANAGER = 4
    GLOBAL_VALIDATOR = 5
    GLOBAL_ACCESS_CONTROLLER = 6
    GLOBAL_ACCOUNT = 7
    GLOBAL_IDENTITY = 8
    GLOBAL_GENERIC_COMPONENT = 9
    GLOBAL_VIRTUAL_SECP256K1_ACCOUNT = 10
    GLOBAL_VIRTUAL_ED25519_ACCOUNT = 11
    GLOBAL_VIRTUAL_SECP256K1_IDENTITY = 12
    GLOBAL_VIRTUAL_ED25519_IDENTITY = 13
    GLOBAL_ONE_RESOURCE_POOL = 14
    GLOBAL_TWO_RESOURCE_POOL = 15
    GLOBAL_MULTI_RESOURCE_POOL = 16
    GLOBAL_ACCOUNT_LOCKER = 17
    GLOBAL_TRANSACTION_TRACKER = 18
    INTERNAL_FUNGIBLE_VAULT = 19
    INTERNAL_NON_FUNGIBLE_VAULT = 20
    INTERNAL_GENERIC_COMPONENT = 21
    INTERNAL_KEY_VALUE_STORE = 22


class _UniffiConverterTypeEntityType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EntityType.GLOBAL_PACKAGE
        if variant == 2:
            return EntityType.GLOBAL_FUNGIBLE_RESOURCE_MANAGER
        if variant == 3:
            return EntityType.GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER
        if variant == 4:
            return EntityType.GLOBAL_CONSENSUS_MANAGER
        if variant == 5:
            return EntityType.GLOBAL_VALIDATOR
        if variant == 6:
            return EntityType.GLOBAL_ACCESS_CONTROLLER
        if variant == 7:
            return EntityType.GLOBAL_ACCOUNT
        if variant == 8:
            return EntityType.GLOBAL_IDENTITY
        if variant == 9:
            return EntityType.GLOBAL_GENERIC_COMPONENT
        if variant == 10:
            return EntityType.GLOBAL_VIRTUAL_SECP256K1_ACCOUNT
        if variant == 11:
            return EntityType.GLOBAL_VIRTUAL_ED25519_ACCOUNT
        if variant == 12:
            return EntityType.GLOBAL_VIRTUAL_SECP256K1_IDENTITY
        if variant == 13:
            return EntityType.GLOBAL_VIRTUAL_ED25519_IDENTITY
        if variant == 14:
            return EntityType.GLOBAL_ONE_RESOURCE_POOL
        if variant == 15:
            return EntityType.GLOBAL_TWO_RESOURCE_POOL
        if variant == 16:
            return EntityType.GLOBAL_MULTI_RESOURCE_POOL
        if variant == 17:
            return EntityType.GLOBAL_ACCOUNT_LOCKER
        if variant == 18:
            return EntityType.GLOBAL_TRANSACTION_TRACKER
        if variant == 19:
            return EntityType.INTERNAL_FUNGIBLE_VAULT
        if variant == 20:
            return EntityType.INTERNAL_NON_FUNGIBLE_VAULT
        if variant == 21:
            return EntityType.INTERNAL_GENERIC_COMPONENT
        if variant == 22:
            return EntityType.INTERNAL_KEY_VALUE_STORE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == EntityType.GLOBAL_PACKAGE:
            buf.write_i32(1)
        if value == EntityType.GLOBAL_FUNGIBLE_RESOURCE_MANAGER:
            buf.write_i32(2)
        if value == EntityType.GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER:
            buf.write_i32(3)
        if value == EntityType.GLOBAL_CONSENSUS_MANAGER:
            buf.write_i32(4)
        if value == EntityType.GLOBAL_VALIDATOR:
            buf.write_i32(5)
        if value == EntityType.GLOBAL_ACCESS_CONTROLLER:
            buf.write_i32(6)
        if value == EntityType.GLOBAL_ACCOUNT:
            buf.write_i32(7)
        if value == EntityType.GLOBAL_IDENTITY:
            buf.write_i32(8)
        if value == EntityType.GLOBAL_GENERIC_COMPONENT:
            buf.write_i32(9)
        if value == EntityType.GLOBAL_VIRTUAL_SECP256K1_ACCOUNT:
            buf.write_i32(10)
        if value == EntityType.GLOBAL_VIRTUAL_ED25519_ACCOUNT:
            buf.write_i32(11)
        if value == EntityType.GLOBAL_VIRTUAL_SECP256K1_IDENTITY:
            buf.write_i32(12)
        if value == EntityType.GLOBAL_VIRTUAL_ED25519_IDENTITY:
            buf.write_i32(13)
        if value == EntityType.GLOBAL_ONE_RESOURCE_POOL:
            buf.write_i32(14)
        if value == EntityType.GLOBAL_TWO_RESOURCE_POOL:
            buf.write_i32(15)
        if value == EntityType.GLOBAL_MULTI_RESOURCE_POOL:
            buf.write_i32(16)
        if value == EntityType.GLOBAL_ACCOUNT_LOCKER:
            buf.write_i32(17)
        if value == EntityType.GLOBAL_TRANSACTION_TRACKER:
            buf.write_i32(18)
        if value == EntityType.INTERNAL_FUNGIBLE_VAULT:
            buf.write_i32(19)
        if value == EntityType.INTERNAL_NON_FUNGIBLE_VAULT:
            buf.write_i32(20)
        if value == EntityType.INTERNAL_GENERIC_COMPONENT:
            buf.write_i32(21)
        if value == EntityType.INTERNAL_KEY_VALUE_STORE:
            buf.write_i32(22)


class FungibleResourceIndicator:
    def __init__(self):
        raise RuntimeError("FungibleResourceIndicator cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GUARANTEED:
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, amount: "Decimal"):

            self.amount = amount

        def __str__(self):
            return "FungibleResourceIndicator.GUARANTEED(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_guaranteed():
                return False
            if self.amount != other.amount:
                return False
            return True

    class PREDICTED:
        predicted_amount: "PredictedDecimal"

        @typing.no_type_check
        def __init__(self, predicted_amount: "PredictedDecimal"):

            self.predicted_amount = predicted_amount

        def __str__(self):
            return "FungibleResourceIndicator.PREDICTED(predicted_amount={})".format(
                self.predicted_amount
            )

        def __eq__(self, other):
            if not other.is_predicted():
                return False
            if self.predicted_amount != other.predicted_amount:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_guaranteed(self) -> bool:
        return isinstance(self, FungibleResourceIndicator.GUARANTEED)

    def is_predicted(self) -> bool:
        return isinstance(self, FungibleResourceIndicator.PREDICTED)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FungibleResourceIndicator.GUARANTEED = type(
    "FungibleResourceIndicator.GUARANTEED",
    (
        FungibleResourceIndicator.GUARANTEED,
        FungibleResourceIndicator,
    ),
    {},
)  # type: ignore
FungibleResourceIndicator.PREDICTED = type(
    "FungibleResourceIndicator.PREDICTED",
    (
        FungibleResourceIndicator.PREDICTED,
        FungibleResourceIndicator,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeFungibleResourceIndicator(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FungibleResourceIndicator.GUARANTEED(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return FungibleResourceIndicator.PREDICTED(
                _UniffiConverterTypePredictedDecimal.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_guaranteed():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_predicted():
            buf.write_i32(2)
            _UniffiConverterTypePredictedDecimal.write(value.predicted_amount, buf)


class Instruction:
    def __init__(self):
        raise RuntimeError("Instruction cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TAKE_ALL_FROM_WORKTOP:
        resource_address: "Address"

        @typing.no_type_check
        def __init__(self, resource_address: "Address"):

            self.resource_address = resource_address

        def __str__(self):
            return "Instruction.TAKE_ALL_FROM_WORKTOP(resource_address={})".format(
                self.resource_address
            )

        def __eq__(self, other):
            if not other.is_take_all_from_worktop():
                return False
            if self.resource_address != other.resource_address:
                return False
            return True

    class TAKE_FROM_WORKTOP:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return (
                "Instruction.TAKE_FROM_WORKTOP(resource_address={}, amount={})".format(
                    self.resource_address, self.amount
                )
            )

        def __eq__(self, other):
            if not other.is_take_from_worktop():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class TAKE_NON_FUNGIBLES_FROM_WORKTOP:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return "Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP(resource_address={}, ids={})".format(
                self.resource_address, self.ids
            )

        def __eq__(self, other):
            if not other.is_take_non_fungibles_from_worktop():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    class RETURN_TO_WORKTOP:
        bucket_id: "ManifestBucket"

        @typing.no_type_check
        def __init__(self, bucket_id: "ManifestBucket"):

            self.bucket_id = bucket_id

        def __str__(self):
            return "Instruction.RETURN_TO_WORKTOP(bucket_id={})".format(self.bucket_id)

        def __eq__(self, other):
            if not other.is_return_to_worktop():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            return True

    class ASSERT_WORKTOP_CONTAINS:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return "Instruction.ASSERT_WORKTOP_CONTAINS(resource_address={}, amount={})".format(
                self.resource_address, self.amount
            )

        def __eq__(self, other):
            if not other.is_assert_worktop_contains():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class ASSERT_WORKTOP_CONTAINS_ANY:
        resource_address: "Address"

        @typing.no_type_check
        def __init__(self, resource_address: "Address"):

            self.resource_address = resource_address

        def __str__(self):
            return (
                "Instruction.ASSERT_WORKTOP_CONTAINS_ANY(resource_address={})".format(
                    self.resource_address
                )
            )

        def __eq__(self, other):
            if not other.is_assert_worktop_contains_any():
                return False
            if self.resource_address != other.resource_address:
                return False
            return True

    class ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return "Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES(resource_address={}, ids={})".format(
                self.resource_address, self.ids
            )

        def __eq__(self, other):
            if not other.is_assert_worktop_contains_non_fungibles():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    class POP_FROM_AUTH_ZONE:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Instruction.POP_FROM_AUTH_ZONE()".format()

        def __eq__(self, other):
            if not other.is_pop_from_auth_zone():
                return False
            return True

    class PUSH_TO_AUTH_ZONE:
        proof_id: "ManifestProof"

        @typing.no_type_check
        def __init__(self, proof_id: "ManifestProof"):

            self.proof_id = proof_id

        def __str__(self):
            return "Instruction.PUSH_TO_AUTH_ZONE(proof_id={})".format(self.proof_id)

        def __eq__(self, other):
            if not other.is_push_to_auth_zone():
                return False
            if self.proof_id != other.proof_id:
                return False
            return True

    class CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT(resource_address={}, amount={})".format(
                self.resource_address, self.amount
            )

        def __eq__(self, other):
            if not other.is_create_proof_from_auth_zone_of_amount():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES(resource_address={}, ids={})".format(
                self.resource_address, self.ids
            )

        def __eq__(self, other):
            if not other.is_create_proof_from_auth_zone_of_non_fungibles():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    class CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL:
        resource_address: "Address"

        @typing.no_type_check
        def __init__(self, resource_address: "Address"):

            self.resource_address = resource_address

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL(resource_address={})".format(
                self.resource_address
            )

        def __eq__(self, other):
            if not other.is_create_proof_from_auth_zone_of_all():
                return False
            if self.resource_address != other.resource_address:
                return False
            return True

    class DROP_ALL_PROOFS:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Instruction.DROP_ALL_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_all_proofs():
                return False
            return True

    class DROP_NAMED_PROOFS:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Instruction.DROP_NAMED_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_named_proofs():
                return False
            return True

    class DROP_AUTH_ZONE_PROOFS:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Instruction.DROP_AUTH_ZONE_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_auth_zone_proofs():
                return False
            return True

    class DROP_AUTH_ZONE_REGULAR_PROOFS:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_auth_zone_regular_proofs():
                return False
            return True

    class DROP_AUTH_ZONE_SIGNATURE_PROOFS:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_auth_zone_signature_proofs():
                return False
            return True

    class CREATE_PROOF_FROM_BUCKET_OF_AMOUNT:
        bucket_id: "ManifestBucket"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, bucket_id: "ManifestBucket", amount: "Decimal"):

            self.bucket_id = bucket_id
            self.amount = amount

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT(bucket_id={}, amount={})".format(
                self.bucket_id, self.amount
            )

        def __eq__(self, other):
            if not other.is_create_proof_from_bucket_of_amount():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            if self.amount != other.amount:
                return False
            return True

    class CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES:
        bucket_id: "ManifestBucket"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, bucket_id: "ManifestBucket", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.bucket_id = bucket_id
            self.ids = ids

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES(bucket_id={}, ids={})".format(
                self.bucket_id, self.ids
            )

        def __eq__(self, other):
            if not other.is_create_proof_from_bucket_of_non_fungibles():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            if self.ids != other.ids:
                return False
            return True

    class CREATE_PROOF_FROM_BUCKET_OF_ALL:
        bucket_id: "ManifestBucket"

        @typing.no_type_check
        def __init__(self, bucket_id: "ManifestBucket"):

            self.bucket_id = bucket_id

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL(bucket_id={})".format(
                self.bucket_id
            )

        def __eq__(self, other):
            if not other.is_create_proof_from_bucket_of_all():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            return True

    class BURN_RESOURCE:
        bucket_id: "ManifestBucket"

        @typing.no_type_check
        def __init__(self, bucket_id: "ManifestBucket"):

            self.bucket_id = bucket_id

        def __str__(self):
            return "Instruction.BURN_RESOURCE(bucket_id={})".format(self.bucket_id)

        def __eq__(self, other):
            if not other.is_burn_resource():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            return True

    class CLONE_PROOF:
        proof_id: "ManifestProof"

        @typing.no_type_check
        def __init__(self, proof_id: "ManifestProof"):

            self.proof_id = proof_id

        def __str__(self):
            return "Instruction.CLONE_PROOF(proof_id={})".format(self.proof_id)

        def __eq__(self, other):
            if not other.is_clone_proof():
                return False
            if self.proof_id != other.proof_id:
                return False
            return True

    class DROP_PROOF:
        proof_id: "ManifestProof"

        @typing.no_type_check
        def __init__(self, proof_id: "ManifestProof"):

            self.proof_id = proof_id

        def __str__(self):
            return "Instruction.DROP_PROOF(proof_id={})".format(self.proof_id)

        def __eq__(self, other):
            if not other.is_drop_proof():
                return False
            if self.proof_id != other.proof_id:
                return False
            return True

    class CALL_FUNCTION:
        package_address: "ManifestAddress"
        blueprint_name: "str"
        function_name: "str"
        args: "ManifestValue"

        @typing.no_type_check
        def __init__(
            self,
            package_address: "ManifestAddress",
            blueprint_name: "str",
            function_name: "str",
            args: "ManifestValue",
        ):

            self.package_address = package_address
            self.blueprint_name = blueprint_name
            self.function_name = function_name
            self.args = args

        def __str__(self):
            return "Instruction.CALL_FUNCTION(package_address={}, blueprint_name={}, function_name={}, args={})".format(
                self.package_address, self.blueprint_name, self.function_name, self.args
            )

        def __eq__(self, other):
            if not other.is_call_function():
                return False
            if self.package_address != other.package_address:
                return False
            if self.blueprint_name != other.blueprint_name:
                return False
            if self.function_name != other.function_name:
                return False
            if self.args != other.args:
                return False
            return True

    class CALL_METHOD:
        address: "ManifestAddress"
        method_name: "str"
        args: "ManifestValue"

        @typing.no_type_check
        def __init__(
            self, address: "ManifestAddress", method_name: "str", args: "ManifestValue"
        ):

            self.address = address
            self.method_name = method_name
            self.args = args

        def __str__(self):
            return (
                "Instruction.CALL_METHOD(address={}, method_name={}, args={})".format(
                    self.address, self.method_name, self.args
                )
            )

        def __eq__(self, other):
            if not other.is_call_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True

    class CALL_ROYALTY_METHOD:
        address: "ManifestAddress"
        method_name: "str"
        args: "ManifestValue"

        @typing.no_type_check
        def __init__(
            self, address: "ManifestAddress", method_name: "str", args: "ManifestValue"
        ):

            self.address = address
            self.method_name = method_name
            self.args = args

        def __str__(self):
            return "Instruction.CALL_ROYALTY_METHOD(address={}, method_name={}, args={})".format(
                self.address, self.method_name, self.args
            )

        def __eq__(self, other):
            if not other.is_call_royalty_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True

    class CALL_METADATA_METHOD:
        address: "ManifestAddress"
        method_name: "str"
        args: "ManifestValue"

        @typing.no_type_check
        def __init__(
            self, address: "ManifestAddress", method_name: "str", args: "ManifestValue"
        ):

            self.address = address
            self.method_name = method_name
            self.args = args

        def __str__(self):
            return "Instruction.CALL_METADATA_METHOD(address={}, method_name={}, args={})".format(
                self.address, self.method_name, self.args
            )

        def __eq__(self, other):
            if not other.is_call_metadata_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True

    class CALL_ROLE_ASSIGNMENT_METHOD:
        address: "ManifestAddress"
        method_name: "str"
        args: "ManifestValue"

        @typing.no_type_check
        def __init__(
            self, address: "ManifestAddress", method_name: "str", args: "ManifestValue"
        ):

            self.address = address
            self.method_name = method_name
            self.args = args

        def __str__(self):
            return "Instruction.CALL_ROLE_ASSIGNMENT_METHOD(address={}, method_name={}, args={})".format(
                self.address, self.method_name, self.args
            )

        def __eq__(self, other):
            if not other.is_call_role_assignment_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True

    class CALL_DIRECT_VAULT_METHOD:
        address: "Address"
        method_name: "str"
        args: "ManifestValue"

        @typing.no_type_check
        def __init__(
            self, address: "Address", method_name: "str", args: "ManifestValue"
        ):

            self.address = address
            self.method_name = method_name
            self.args = args

        def __str__(self):
            return "Instruction.CALL_DIRECT_VAULT_METHOD(address={}, method_name={}, args={})".format(
                self.address, self.method_name, self.args
            )

        def __eq__(self, other):
            if not other.is_call_direct_vault_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True

    class ALLOCATE_GLOBAL_ADDRESS:
        package_address: "Address"
        blueprint_name: "str"

        @typing.no_type_check
        def __init__(self, package_address: "Address", blueprint_name: "str"):

            self.package_address = package_address
            self.blueprint_name = blueprint_name

        def __str__(self):
            return "Instruction.ALLOCATE_GLOBAL_ADDRESS(package_address={}, blueprint_name={})".format(
                self.package_address, self.blueprint_name
            )

        def __eq__(self, other):
            if not other.is_allocate_global_address():
                return False
            if self.package_address != other.package_address:
                return False
            if self.blueprint_name != other.blueprint_name:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_take_all_from_worktop(self) -> bool:
        return isinstance(self, Instruction.TAKE_ALL_FROM_WORKTOP)

    def is_take_from_worktop(self) -> bool:
        return isinstance(self, Instruction.TAKE_FROM_WORKTOP)

    def is_take_non_fungibles_from_worktop(self) -> bool:
        return isinstance(self, Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP)

    def is_return_to_worktop(self) -> bool:
        return isinstance(self, Instruction.RETURN_TO_WORKTOP)

    def is_assert_worktop_contains(self) -> bool:
        return isinstance(self, Instruction.ASSERT_WORKTOP_CONTAINS)

    def is_assert_worktop_contains_any(self) -> bool:
        return isinstance(self, Instruction.ASSERT_WORKTOP_CONTAINS_ANY)

    def is_assert_worktop_contains_non_fungibles(self) -> bool:
        return isinstance(self, Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES)

    def is_pop_from_auth_zone(self) -> bool:
        return isinstance(self, Instruction.POP_FROM_AUTH_ZONE)

    def is_push_to_auth_zone(self) -> bool:
        return isinstance(self, Instruction.PUSH_TO_AUTH_ZONE)

    def is_create_proof_from_auth_zone_of_amount(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT)

    def is_create_proof_from_auth_zone_of_non_fungibles(self) -> bool:
        return isinstance(
            self, Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES
        )

    def is_create_proof_from_auth_zone_of_all(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL)

    def is_drop_all_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_ALL_PROOFS)

    def is_drop_named_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_NAMED_PROOFS)

    def is_drop_auth_zone_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_AUTH_ZONE_PROOFS)

    def is_drop_auth_zone_regular_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS)

    def is_drop_auth_zone_signature_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS)

    def is_create_proof_from_bucket_of_amount(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT)

    def is_create_proof_from_bucket_of_non_fungibles(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES)

    def is_create_proof_from_bucket_of_all(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL)

    def is_burn_resource(self) -> bool:
        return isinstance(self, Instruction.BURN_RESOURCE)

    def is_clone_proof(self) -> bool:
        return isinstance(self, Instruction.CLONE_PROOF)

    def is_drop_proof(self) -> bool:
        return isinstance(self, Instruction.DROP_PROOF)

    def is_call_function(self) -> bool:
        return isinstance(self, Instruction.CALL_FUNCTION)

    def is_call_method(self) -> bool:
        return isinstance(self, Instruction.CALL_METHOD)

    def is_call_royalty_method(self) -> bool:
        return isinstance(self, Instruction.CALL_ROYALTY_METHOD)

    def is_call_metadata_method(self) -> bool:
        return isinstance(self, Instruction.CALL_METADATA_METHOD)

    def is_call_role_assignment_method(self) -> bool:
        return isinstance(self, Instruction.CALL_ROLE_ASSIGNMENT_METHOD)

    def is_call_direct_vault_method(self) -> bool:
        return isinstance(self, Instruction.CALL_DIRECT_VAULT_METHOD)

    def is_allocate_global_address(self) -> bool:
        return isinstance(self, Instruction.ALLOCATE_GLOBAL_ADDRESS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Instruction.TAKE_ALL_FROM_WORKTOP = type(
    "Instruction.TAKE_ALL_FROM_WORKTOP",
    (
        Instruction.TAKE_ALL_FROM_WORKTOP,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.TAKE_FROM_WORKTOP = type(
    "Instruction.TAKE_FROM_WORKTOP",
    (
        Instruction.TAKE_FROM_WORKTOP,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP = type(
    "Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP",
    (
        Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.RETURN_TO_WORKTOP = type(
    "Instruction.RETURN_TO_WORKTOP",
    (
        Instruction.RETURN_TO_WORKTOP,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.ASSERT_WORKTOP_CONTAINS = type(
    "Instruction.ASSERT_WORKTOP_CONTAINS",
    (
        Instruction.ASSERT_WORKTOP_CONTAINS,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.ASSERT_WORKTOP_CONTAINS_ANY = type(
    "Instruction.ASSERT_WORKTOP_CONTAINS_ANY",
    (
        Instruction.ASSERT_WORKTOP_CONTAINS_ANY,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES = type(
    "Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES",
    (
        Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.POP_FROM_AUTH_ZONE = type(
    "Instruction.POP_FROM_AUTH_ZONE",
    (
        Instruction.POP_FROM_AUTH_ZONE,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.PUSH_TO_AUTH_ZONE = type(
    "Instruction.PUSH_TO_AUTH_ZONE",
    (
        Instruction.PUSH_TO_AUTH_ZONE,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT = type(
    "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT",
    (
        Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES = type(
    "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES",
    (
        Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL = type(
    "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL",
    (
        Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.DROP_ALL_PROOFS = type(
    "Instruction.DROP_ALL_PROOFS",
    (
        Instruction.DROP_ALL_PROOFS,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.DROP_NAMED_PROOFS = type(
    "Instruction.DROP_NAMED_PROOFS",
    (
        Instruction.DROP_NAMED_PROOFS,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.DROP_AUTH_ZONE_PROOFS = type(
    "Instruction.DROP_AUTH_ZONE_PROOFS",
    (
        Instruction.DROP_AUTH_ZONE_PROOFS,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS = type(
    "Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS",
    (
        Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS = type(
    "Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS",
    (
        Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT = type(
    "Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT",
    (
        Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES = type(
    "Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES",
    (
        Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL = type(
    "Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL",
    (
        Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.BURN_RESOURCE = type(
    "Instruction.BURN_RESOURCE",
    (
        Instruction.BURN_RESOURCE,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CLONE_PROOF = type(
    "Instruction.CLONE_PROOF",
    (
        Instruction.CLONE_PROOF,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.DROP_PROOF = type(
    "Instruction.DROP_PROOF",
    (
        Instruction.DROP_PROOF,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CALL_FUNCTION = type(
    "Instruction.CALL_FUNCTION",
    (
        Instruction.CALL_FUNCTION,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CALL_METHOD = type(
    "Instruction.CALL_METHOD",
    (
        Instruction.CALL_METHOD,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CALL_ROYALTY_METHOD = type(
    "Instruction.CALL_ROYALTY_METHOD",
    (
        Instruction.CALL_ROYALTY_METHOD,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CALL_METADATA_METHOD = type(
    "Instruction.CALL_METADATA_METHOD",
    (
        Instruction.CALL_METADATA_METHOD,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CALL_ROLE_ASSIGNMENT_METHOD = type(
    "Instruction.CALL_ROLE_ASSIGNMENT_METHOD",
    (
        Instruction.CALL_ROLE_ASSIGNMENT_METHOD,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.CALL_DIRECT_VAULT_METHOD = type(
    "Instruction.CALL_DIRECT_VAULT_METHOD",
    (
        Instruction.CALL_DIRECT_VAULT_METHOD,
        Instruction,
    ),
    {},
)  # type: ignore
Instruction.ALLOCATE_GLOBAL_ADDRESS = type(
    "Instruction.ALLOCATE_GLOBAL_ADDRESS",
    (
        Instruction.ALLOCATE_GLOBAL_ADDRESS,
        Instruction,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeInstruction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Instruction.TAKE_ALL_FROM_WORKTOP(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 2:
            return Instruction.TAKE_FROM_WORKTOP(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 3:
            return Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 4:
            return Instruction.RETURN_TO_WORKTOP(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 5:
            return Instruction.ASSERT_WORKTOP_CONTAINS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 6:
            return Instruction.ASSERT_WORKTOP_CONTAINS_ANY(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 7:
            return Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 8:
            return Instruction.POP_FROM_AUTH_ZONE()
        if variant == 9:
            return Instruction.PUSH_TO_AUTH_ZONE(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 10:
            return Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 11:
            return Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 12:
            return Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 13:
            return Instruction.DROP_ALL_PROOFS()
        if variant == 14:
            return Instruction.DROP_NAMED_PROOFS()
        if variant == 15:
            return Instruction.DROP_AUTH_ZONE_PROOFS()
        if variant == 16:
            return Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS()
        if variant == 17:
            return Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS()
        if variant == 18:
            return Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT(
                _UniffiConverterTypeManifestBucket.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 19:
            return Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES(
                _UniffiConverterTypeManifestBucket.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 20:
            return Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 21:
            return Instruction.BURN_RESOURCE(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 22:
            return Instruction.CLONE_PROOF(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 23:
            return Instruction.DROP_PROOF(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 24:
            return Instruction.CALL_FUNCTION(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 25:
            return Instruction.CALL_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 26:
            return Instruction.CALL_ROYALTY_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 27:
            return Instruction.CALL_METADATA_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 28:
            return Instruction.CALL_ROLE_ASSIGNMENT_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 29:
            return Instruction.CALL_DIRECT_VAULT_METHOD(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 30:
            return Instruction.ALLOCATE_GLOBAL_ADDRESS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_take_all_from_worktop():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
        if value.is_take_from_worktop():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_take_non_fungibles_from_worktop():
            buf.write_i32(3)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_return_to_worktop():
            buf.write_i32(4)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
        if value.is_assert_worktop_contains():
            buf.write_i32(5)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_assert_worktop_contains_any():
            buf.write_i32(6)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
        if value.is_assert_worktop_contains_non_fungibles():
            buf.write_i32(7)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_pop_from_auth_zone():
            buf.write_i32(8)
        if value.is_push_to_auth_zone():
            buf.write_i32(9)
            _UniffiConverterTypeManifestProof.write(value.proof_id, buf)
        if value.is_create_proof_from_auth_zone_of_amount():
            buf.write_i32(10)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_create_proof_from_auth_zone_of_non_fungibles():
            buf.write_i32(11)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_create_proof_from_auth_zone_of_all():
            buf.write_i32(12)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
        if value.is_drop_all_proofs():
            buf.write_i32(13)
        if value.is_drop_named_proofs():
            buf.write_i32(14)
        if value.is_drop_auth_zone_proofs():
            buf.write_i32(15)
        if value.is_drop_auth_zone_regular_proofs():
            buf.write_i32(16)
        if value.is_drop_auth_zone_signature_proofs():
            buf.write_i32(17)
        if value.is_create_proof_from_bucket_of_amount():
            buf.write_i32(18)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_create_proof_from_bucket_of_non_fungibles():
            buf.write_i32(19)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_create_proof_from_bucket_of_all():
            buf.write_i32(20)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
        if value.is_burn_resource():
            buf.write_i32(21)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
        if value.is_clone_proof():
            buf.write_i32(22)
            _UniffiConverterTypeManifestProof.write(value.proof_id, buf)
        if value.is_drop_proof():
            buf.write_i32(23)
            _UniffiConverterTypeManifestProof.write(value.proof_id, buf)
        if value.is_call_function():
            buf.write_i32(24)
            _UniffiConverterTypeManifestAddress.write(value.package_address, buf)
            _UniffiConverterString.write(value.blueprint_name, buf)
            _UniffiConverterString.write(value.function_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_method():
            buf.write_i32(25)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_royalty_method():
            buf.write_i32(26)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_metadata_method():
            buf.write_i32(27)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_role_assignment_method():
            buf.write_i32(28)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_direct_vault_method():
            buf.write_i32(29)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_allocate_global_address():
            buf.write_i32(30)
            _UniffiConverterTypeAddress.write(value.package_address, buf)
            _UniffiConverterString.write(value.blueprint_name, buf)


class LocalTypeId:
    def __init__(self):
        raise RuntimeError("LocalTypeId cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class WELL_KNOWN:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "LocalTypeId.WELL_KNOWN(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_well_known():
                return False
            if self.value != other.value:
                return False
            return True

    class SCHEMA_LOCAL_INDEX:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "LocalTypeId.SCHEMA_LOCAL_INDEX(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_schema_local_index():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_well_known(self) -> bool:
        return isinstance(self, LocalTypeId.WELL_KNOWN)

    def is_schema_local_index(self) -> bool:
        return isinstance(self, LocalTypeId.SCHEMA_LOCAL_INDEX)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LocalTypeId.WELL_KNOWN = type(
    "LocalTypeId.WELL_KNOWN",
    (
        LocalTypeId.WELL_KNOWN,
        LocalTypeId,
    ),
    {},
)  # type: ignore
LocalTypeId.SCHEMA_LOCAL_INDEX = type(
    "LocalTypeId.SCHEMA_LOCAL_INDEX",
    (
        LocalTypeId.SCHEMA_LOCAL_INDEX,
        LocalTypeId,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeLocalTypeId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LocalTypeId.WELL_KNOWN(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 2:
            return LocalTypeId.SCHEMA_LOCAL_INDEX(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_well_known():
            buf.write_i32(1)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_schema_local_index():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.value, buf)


class ManifestAddress:
    def __init__(self):
        raise RuntimeError("ManifestAddress cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NAMED:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestAddress.NAMED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_named():
                return False
            if self.value != other.value:
                return False
            return True

    class STATIC:
        value: "Address"

        @typing.no_type_check
        def __init__(self, value: "Address"):

            self.value = value

        def __str__(self):
            return "ManifestAddress.STATIC(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_static():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_named(self) -> bool:
        return isinstance(self, ManifestAddress.NAMED)

    def is_static(self) -> bool:
        return isinstance(self, ManifestAddress.STATIC)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestAddress.NAMED = type(
    "ManifestAddress.NAMED",
    (
        ManifestAddress.NAMED,
        ManifestAddress,
    ),
    {},
)  # type: ignore
ManifestAddress.STATIC = type(
    "ManifestAddress.STATIC",
    (
        ManifestAddress.STATIC,
        ManifestAddress,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeManifestAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestAddress.NAMED(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 2:
            return ManifestAddress.STATIC(
                _UniffiConverterTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_named():
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_static():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.value, buf)


class ManifestBuilderAddress:
    def __init__(self):
        raise RuntimeError("ManifestBuilderAddress cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NAMED:
        value: "ManifestBuilderNamedAddress"

        @typing.no_type_check
        def __init__(self, value: "ManifestBuilderNamedAddress"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderAddress.NAMED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_named():
                return False
            if self.value != other.value:
                return False
            return True

    class STATIC:
        value: "Address"

        @typing.no_type_check
        def __init__(self, value: "Address"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderAddress.STATIC(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_static():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_named(self) -> bool:
        return isinstance(self, ManifestBuilderAddress.NAMED)

    def is_static(self) -> bool:
        return isinstance(self, ManifestBuilderAddress.STATIC)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestBuilderAddress.NAMED = type(
    "ManifestBuilderAddress.NAMED",
    (
        ManifestBuilderAddress.NAMED,
        ManifestBuilderAddress,
    ),
    {},
)  # type: ignore
ManifestBuilderAddress.STATIC = type(
    "ManifestBuilderAddress.STATIC",
    (
        ManifestBuilderAddress.STATIC,
        ManifestBuilderAddress,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeManifestBuilderAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestBuilderAddress.NAMED(
                _UniffiConverterTypeManifestBuilderNamedAddress.read(buf),
            )
        if variant == 2:
            return ManifestBuilderAddress.STATIC(
                _UniffiConverterTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_named():
            buf.write_i32(1)
            _UniffiConverterTypeManifestBuilderNamedAddress.write(value.value, buf)
        if value.is_static():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.value, buf)


class ManifestBuilderValue:
    def __init__(self):
        raise RuntimeError("ManifestBuilderValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL_VALUE:
        value: "bool"

        @typing.no_type_check
        def __init__(self, value: "bool"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.BOOL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I8_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.I8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i8_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I16_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.I16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i16_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I32_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.I32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I64_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.I64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I128_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.I128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i128_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U8_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.U8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U16_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.U16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u16_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U32_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.U32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U64_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.U64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U128_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.U128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u128_value():
                return False
            if self.value != other.value:
                return False
            return True

    class STRING_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.STRING_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ENUM_VALUE:
        discriminator: "int"
        fields: "typing.List[ManifestBuilderValue]"

        @typing.no_type_check
        def __init__(
            self, discriminator: "int", fields: "typing.List[ManifestBuilderValue]"
        ):

            self.discriminator = discriminator
            self.fields = fields

        def __str__(self):
            return (
                "ManifestBuilderValue.ENUM_VALUE(discriminator={}, fields={})".format(
                    self.discriminator, self.fields
                )
            )

        def __eq__(self, other):
            if not other.is_enum_value():
                return False
            if self.discriminator != other.discriminator:
                return False
            if self.fields != other.fields:
                return False
            return True

    class ARRAY_VALUE:
        element_value_kind: "ManifestBuilderValueKind"
        elements: "typing.List[ManifestBuilderValue]"

        @typing.no_type_check
        def __init__(
            self,
            element_value_kind: "ManifestBuilderValueKind",
            elements: "typing.List[ManifestBuilderValue]",
        ):

            self.element_value_kind = element_value_kind
            self.elements = elements

        def __str__(self):
            return "ManifestBuilderValue.ARRAY_VALUE(element_value_kind={}, elements={})".format(
                self.element_value_kind, self.elements
            )

        def __eq__(self, other):
            if not other.is_array_value():
                return False
            if self.element_value_kind != other.element_value_kind:
                return False
            if self.elements != other.elements:
                return False
            return True

    class TUPLE_VALUE:
        fields: "typing.List[ManifestBuilderValue]"

        @typing.no_type_check
        def __init__(self, fields: "typing.List[ManifestBuilderValue]"):

            self.fields = fields

        def __str__(self):
            return "ManifestBuilderValue.TUPLE_VALUE(fields={})".format(self.fields)

        def __eq__(self, other):
            if not other.is_tuple_value():
                return False
            if self.fields != other.fields:
                return False
            return True

    class MAP_VALUE:
        key_value_kind: "ManifestBuilderValueKind"
        value_value_kind: "ManifestBuilderValueKind"
        entries: "typing.List[ManifestBuilderMapEntry]"

        @typing.no_type_check
        def __init__(
            self,
            key_value_kind: "ManifestBuilderValueKind",
            value_value_kind: "ManifestBuilderValueKind",
            entries: "typing.List[ManifestBuilderMapEntry]",
        ):

            self.key_value_kind = key_value_kind
            self.value_value_kind = value_value_kind
            self.entries = entries

        def __str__(self):
            return "ManifestBuilderValue.MAP_VALUE(key_value_kind={}, value_value_kind={}, entries={})".format(
                self.key_value_kind, self.value_value_kind, self.entries
            )

        def __eq__(self, other):
            if not other.is_map_value():
                return False
            if self.key_value_kind != other.key_value_kind:
                return False
            if self.value_value_kind != other.value_value_kind:
                return False
            if self.entries != other.entries:
                return False
            return True

    class ADDRESS_VALUE:
        value: "ManifestBuilderAddress"

        @typing.no_type_check
        def __init__(self, value: "ManifestBuilderAddress"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.ADDRESS_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_address_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BUCKET_VALUE:
        value: "ManifestBuilderBucket"

        @typing.no_type_check
        def __init__(self, value: "ManifestBuilderBucket"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.BUCKET_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bucket_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PROOF_VALUE:
        value: "ManifestBuilderProof"

        @typing.no_type_check
        def __init__(self, value: "ManifestBuilderProof"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.PROOF_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_proof_value():
                return False
            if self.value != other.value:
                return False
            return True

    class EXPRESSION_VALUE:
        value: "ManifestExpression"

        @typing.no_type_check
        def __init__(self, value: "ManifestExpression"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.EXPRESSION_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_expression_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BLOB_VALUE:
        value: "ManifestBlobRef"

        @typing.no_type_check
        def __init__(self, value: "ManifestBlobRef"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.BLOB_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_blob_value():
                return False
            if self.value != other.value:
                return False
            return True

    class DECIMAL_VALUE:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PRECISE_DECIMAL_VALUE:
        value: "PreciseDecimal"

        @typing.no_type_check
        def __init__(self, value: "PreciseDecimal"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.PRECISE_DECIMAL_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_precise_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_LOCAL_ID_VALUE:
        value: "NonFungibleLocalId"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleLocalId"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ADDRESS_RESERVATION_VALUE:
        value: "ManifestBuilderAddressReservation"

        @typing.no_type_check
        def __init__(self, value: "ManifestBuilderAddressReservation"):

            self.value = value

        def __str__(self):
            return "ManifestBuilderValue.ADDRESS_RESERVATION_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_address_reservation_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bool_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.BOOL_VALUE)

    def is_i8_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I8_VALUE)

    def is_i16_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I16_VALUE)

    def is_i32_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I32_VALUE)

    def is_i64_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I64_VALUE)

    def is_i128_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I128_VALUE)

    def is_u8_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U8_VALUE)

    def is_u16_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U16_VALUE)

    def is_u32_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U32_VALUE)

    def is_u64_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U64_VALUE)

    def is_u128_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U128_VALUE)

    def is_string_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.STRING_VALUE)

    def is_enum_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ENUM_VALUE)

    def is_array_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ARRAY_VALUE)

    def is_tuple_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.TUPLE_VALUE)

    def is_map_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.MAP_VALUE)

    def is_address_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ADDRESS_VALUE)

    def is_bucket_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.BUCKET_VALUE)

    def is_proof_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.PROOF_VALUE)

    def is_expression_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.EXPRESSION_VALUE)

    def is_blob_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.BLOB_VALUE)

    def is_decimal_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.DECIMAL_VALUE)

    def is_precise_decimal_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.PRECISE_DECIMAL_VALUE)

    def is_non_fungible_local_id_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE)

    def is_address_reservation_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ADDRESS_RESERVATION_VALUE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestBuilderValue.BOOL_VALUE = type(
    "ManifestBuilderValue.BOOL_VALUE",
    (
        ManifestBuilderValue.BOOL_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.I8_VALUE = type(
    "ManifestBuilderValue.I8_VALUE",
    (
        ManifestBuilderValue.I8_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.I16_VALUE = type(
    "ManifestBuilderValue.I16_VALUE",
    (
        ManifestBuilderValue.I16_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.I32_VALUE = type(
    "ManifestBuilderValue.I32_VALUE",
    (
        ManifestBuilderValue.I32_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.I64_VALUE = type(
    "ManifestBuilderValue.I64_VALUE",
    (
        ManifestBuilderValue.I64_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.I128_VALUE = type(
    "ManifestBuilderValue.I128_VALUE",
    (
        ManifestBuilderValue.I128_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.U8_VALUE = type(
    "ManifestBuilderValue.U8_VALUE",
    (
        ManifestBuilderValue.U8_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.U16_VALUE = type(
    "ManifestBuilderValue.U16_VALUE",
    (
        ManifestBuilderValue.U16_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.U32_VALUE = type(
    "ManifestBuilderValue.U32_VALUE",
    (
        ManifestBuilderValue.U32_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.U64_VALUE = type(
    "ManifestBuilderValue.U64_VALUE",
    (
        ManifestBuilderValue.U64_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.U128_VALUE = type(
    "ManifestBuilderValue.U128_VALUE",
    (
        ManifestBuilderValue.U128_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.STRING_VALUE = type(
    "ManifestBuilderValue.STRING_VALUE",
    (
        ManifestBuilderValue.STRING_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.ENUM_VALUE = type(
    "ManifestBuilderValue.ENUM_VALUE",
    (
        ManifestBuilderValue.ENUM_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.ARRAY_VALUE = type(
    "ManifestBuilderValue.ARRAY_VALUE",
    (
        ManifestBuilderValue.ARRAY_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.TUPLE_VALUE = type(
    "ManifestBuilderValue.TUPLE_VALUE",
    (
        ManifestBuilderValue.TUPLE_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.MAP_VALUE = type(
    "ManifestBuilderValue.MAP_VALUE",
    (
        ManifestBuilderValue.MAP_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.ADDRESS_VALUE = type(
    "ManifestBuilderValue.ADDRESS_VALUE",
    (
        ManifestBuilderValue.ADDRESS_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.BUCKET_VALUE = type(
    "ManifestBuilderValue.BUCKET_VALUE",
    (
        ManifestBuilderValue.BUCKET_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.PROOF_VALUE = type(
    "ManifestBuilderValue.PROOF_VALUE",
    (
        ManifestBuilderValue.PROOF_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.EXPRESSION_VALUE = type(
    "ManifestBuilderValue.EXPRESSION_VALUE",
    (
        ManifestBuilderValue.EXPRESSION_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.BLOB_VALUE = type(
    "ManifestBuilderValue.BLOB_VALUE",
    (
        ManifestBuilderValue.BLOB_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.DECIMAL_VALUE = type(
    "ManifestBuilderValue.DECIMAL_VALUE",
    (
        ManifestBuilderValue.DECIMAL_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.PRECISE_DECIMAL_VALUE = type(
    "ManifestBuilderValue.PRECISE_DECIMAL_VALUE",
    (
        ManifestBuilderValue.PRECISE_DECIMAL_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE = type(
    "ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE",
    (
        ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore
ManifestBuilderValue.ADDRESS_RESERVATION_VALUE = type(
    "ManifestBuilderValue.ADDRESS_RESERVATION_VALUE",
    (
        ManifestBuilderValue.ADDRESS_RESERVATION_VALUE,
        ManifestBuilderValue,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeManifestBuilderValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestBuilderValue.BOOL_VALUE(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return ManifestBuilderValue.I8_VALUE(
                _UniffiConverterInt8.read(buf),
            )
        if variant == 3:
            return ManifestBuilderValue.I16_VALUE(
                _UniffiConverterInt16.read(buf),
            )
        if variant == 4:
            return ManifestBuilderValue.I32_VALUE(
                _UniffiConverterInt32.read(buf),
            )
        if variant == 5:
            return ManifestBuilderValue.I64_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 6:
            return ManifestBuilderValue.I128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ManifestBuilderValue.U8_VALUE(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 8:
            return ManifestBuilderValue.U16_VALUE(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 9:
            return ManifestBuilderValue.U32_VALUE(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return ManifestBuilderValue.U64_VALUE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 11:
            return ManifestBuilderValue.U128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return ManifestBuilderValue.STRING_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return ManifestBuilderValue.ENUM_VALUE(
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterSequenceTypeManifestBuilderValue.read(buf),
            )
        if variant == 14:
            return ManifestBuilderValue.ARRAY_VALUE(
                _UniffiConverterTypeManifestBuilderValueKind.read(buf),
                _UniffiConverterSequenceTypeManifestBuilderValue.read(buf),
            )
        if variant == 15:
            return ManifestBuilderValue.TUPLE_VALUE(
                _UniffiConverterSequenceTypeManifestBuilderValue.read(buf),
            )
        if variant == 16:
            return ManifestBuilderValue.MAP_VALUE(
                _UniffiConverterTypeManifestBuilderValueKind.read(buf),
                _UniffiConverterTypeManifestBuilderValueKind.read(buf),
                _UniffiConverterSequenceTypeManifestBuilderMapEntry.read(buf),
            )
        if variant == 17:
            return ManifestBuilderValue.ADDRESS_VALUE(
                _UniffiConverterTypeManifestBuilderAddress.read(buf),
            )
        if variant == 18:
            return ManifestBuilderValue.BUCKET_VALUE(
                _UniffiConverterTypeManifestBuilderBucket.read(buf),
            )
        if variant == 19:
            return ManifestBuilderValue.PROOF_VALUE(
                _UniffiConverterTypeManifestBuilderProof.read(buf),
            )
        if variant == 20:
            return ManifestBuilderValue.EXPRESSION_VALUE(
                _UniffiConverterTypeManifestExpression.read(buf),
            )
        if variant == 21:
            return ManifestBuilderValue.BLOB_VALUE(
                _UniffiConverterTypeManifestBlobRef.read(buf),
            )
        if variant == 22:
            return ManifestBuilderValue.DECIMAL_VALUE(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 23:
            return ManifestBuilderValue.PRECISE_DECIMAL_VALUE(
                _UniffiConverterTypePreciseDecimal.read(buf),
            )
        if variant == 24:
            return ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleLocalId.read(buf),
            )
        if variant == 25:
            return ManifestBuilderValue.ADDRESS_RESERVATION_VALUE(
                _UniffiConverterTypeManifestBuilderAddressReservation.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bool_value():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.value, buf)
        if value.is_i8_value():
            buf.write_i32(2)
            _UniffiConverterInt8.write(value.value, buf)
        if value.is_i16_value():
            buf.write_i32(3)
            _UniffiConverterInt16.write(value.value, buf)
        if value.is_i32_value():
            buf.write_i32(4)
            _UniffiConverterInt32.write(value.value, buf)
        if value.is_i64_value():
            buf.write_i32(5)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_i128_value():
            buf.write_i32(6)
            _UniffiConverterString.write(value.value, buf)
        if value.is_u8_value():
            buf.write_i32(7)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_u16_value():
            buf.write_i32(8)
            _UniffiConverterUInt16.write(value.value, buf)
        if value.is_u32_value():
            buf.write_i32(9)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_u64_value():
            buf.write_i32(10)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_u128_value():
            buf.write_i32(11)
            _UniffiConverterString.write(value.value, buf)
        if value.is_string_value():
            buf.write_i32(12)
            _UniffiConverterString.write(value.value, buf)
        if value.is_enum_value():
            buf.write_i32(13)
            _UniffiConverterUInt8.write(value.discriminator, buf)
            _UniffiConverterSequenceTypeManifestBuilderValue.write(value.fields, buf)
        if value.is_array_value():
            buf.write_i32(14)
            _UniffiConverterTypeManifestBuilderValueKind.write(
                value.element_value_kind, buf
            )
            _UniffiConverterSequenceTypeManifestBuilderValue.write(value.elements, buf)
        if value.is_tuple_value():
            buf.write_i32(15)
            _UniffiConverterSequenceTypeManifestBuilderValue.write(value.fields, buf)
        if value.is_map_value():
            buf.write_i32(16)
            _UniffiConverterTypeManifestBuilderValueKind.write(
                value.key_value_kind, buf
            )
            _UniffiConverterTypeManifestBuilderValueKind.write(
                value.value_value_kind, buf
            )
            _UniffiConverterSequenceTypeManifestBuilderMapEntry.write(
                value.entries, buf
            )
        if value.is_address_value():
            buf.write_i32(17)
            _UniffiConverterTypeManifestBuilderAddress.write(value.value, buf)
        if value.is_bucket_value():
            buf.write_i32(18)
            _UniffiConverterTypeManifestBuilderBucket.write(value.value, buf)
        if value.is_proof_value():
            buf.write_i32(19)
            _UniffiConverterTypeManifestBuilderProof.write(value.value, buf)
        if value.is_expression_value():
            buf.write_i32(20)
            _UniffiConverterTypeManifestExpression.write(value.value, buf)
        if value.is_blob_value():
            buf.write_i32(21)
            _UniffiConverterTypeManifestBlobRef.write(value.value, buf)
        if value.is_decimal_value():
            buf.write_i32(22)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_precise_decimal_value():
            buf.write_i32(23)
            _UniffiConverterTypePreciseDecimal.write(value.value, buf)
        if value.is_non_fungible_local_id_value():
            buf.write_i32(24)
            _UniffiConverterTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_address_reservation_value():
            buf.write_i32(25)
            _UniffiConverterTypeManifestBuilderAddressReservation.write(
                value.value, buf
            )


class ManifestBuilderValueKind(enum.Enum):
    BOOL_VALUE = 1
    I8_VALUE = 2
    I16_VALUE = 3
    I32_VALUE = 4
    I64_VALUE = 5
    I128_VALUE = 6
    U8_VALUE = 7
    U16_VALUE = 8
    U32_VALUE = 9
    U64_VALUE = 10
    U128_VALUE = 11
    STRING_VALUE = 12
    ENUM_VALUE = 13
    ARRAY_VALUE = 14
    TUPLE_VALUE = 15
    MAP_VALUE = 16
    ADDRESS_VALUE = 17
    BUCKET_VALUE = 18
    PROOF_VALUE = 19
    EXPRESSION_VALUE = 20
    BLOB_VALUE = 21
    DECIMAL_VALUE = 22
    PRECISE_DECIMAL_VALUE = 23
    NON_FUNGIBLE_LOCAL_ID_VALUE = 24
    ADDRESS_RESERVATION_VALUE = 25


class _UniffiConverterTypeManifestBuilderValueKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestBuilderValueKind.BOOL_VALUE
        if variant == 2:
            return ManifestBuilderValueKind.I8_VALUE
        if variant == 3:
            return ManifestBuilderValueKind.I16_VALUE
        if variant == 4:
            return ManifestBuilderValueKind.I32_VALUE
        if variant == 5:
            return ManifestBuilderValueKind.I64_VALUE
        if variant == 6:
            return ManifestBuilderValueKind.I128_VALUE
        if variant == 7:
            return ManifestBuilderValueKind.U8_VALUE
        if variant == 8:
            return ManifestBuilderValueKind.U16_VALUE
        if variant == 9:
            return ManifestBuilderValueKind.U32_VALUE
        if variant == 10:
            return ManifestBuilderValueKind.U64_VALUE
        if variant == 11:
            return ManifestBuilderValueKind.U128_VALUE
        if variant == 12:
            return ManifestBuilderValueKind.STRING_VALUE
        if variant == 13:
            return ManifestBuilderValueKind.ENUM_VALUE
        if variant == 14:
            return ManifestBuilderValueKind.ARRAY_VALUE
        if variant == 15:
            return ManifestBuilderValueKind.TUPLE_VALUE
        if variant == 16:
            return ManifestBuilderValueKind.MAP_VALUE
        if variant == 17:
            return ManifestBuilderValueKind.ADDRESS_VALUE
        if variant == 18:
            return ManifestBuilderValueKind.BUCKET_VALUE
        if variant == 19:
            return ManifestBuilderValueKind.PROOF_VALUE
        if variant == 20:
            return ManifestBuilderValueKind.EXPRESSION_VALUE
        if variant == 21:
            return ManifestBuilderValueKind.BLOB_VALUE
        if variant == 22:
            return ManifestBuilderValueKind.DECIMAL_VALUE
        if variant == 23:
            return ManifestBuilderValueKind.PRECISE_DECIMAL_VALUE
        if variant == 24:
            return ManifestBuilderValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE
        if variant == 25:
            return ManifestBuilderValueKind.ADDRESS_RESERVATION_VALUE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestBuilderValueKind.BOOL_VALUE:
            buf.write_i32(1)
        if value == ManifestBuilderValueKind.I8_VALUE:
            buf.write_i32(2)
        if value == ManifestBuilderValueKind.I16_VALUE:
            buf.write_i32(3)
        if value == ManifestBuilderValueKind.I32_VALUE:
            buf.write_i32(4)
        if value == ManifestBuilderValueKind.I64_VALUE:
            buf.write_i32(5)
        if value == ManifestBuilderValueKind.I128_VALUE:
            buf.write_i32(6)
        if value == ManifestBuilderValueKind.U8_VALUE:
            buf.write_i32(7)
        if value == ManifestBuilderValueKind.U16_VALUE:
            buf.write_i32(8)
        if value == ManifestBuilderValueKind.U32_VALUE:
            buf.write_i32(9)
        if value == ManifestBuilderValueKind.U64_VALUE:
            buf.write_i32(10)
        if value == ManifestBuilderValueKind.U128_VALUE:
            buf.write_i32(11)
        if value == ManifestBuilderValueKind.STRING_VALUE:
            buf.write_i32(12)
        if value == ManifestBuilderValueKind.ENUM_VALUE:
            buf.write_i32(13)
        if value == ManifestBuilderValueKind.ARRAY_VALUE:
            buf.write_i32(14)
        if value == ManifestBuilderValueKind.TUPLE_VALUE:
            buf.write_i32(15)
        if value == ManifestBuilderValueKind.MAP_VALUE:
            buf.write_i32(16)
        if value == ManifestBuilderValueKind.ADDRESS_VALUE:
            buf.write_i32(17)
        if value == ManifestBuilderValueKind.BUCKET_VALUE:
            buf.write_i32(18)
        if value == ManifestBuilderValueKind.PROOF_VALUE:
            buf.write_i32(19)
        if value == ManifestBuilderValueKind.EXPRESSION_VALUE:
            buf.write_i32(20)
        if value == ManifestBuilderValueKind.BLOB_VALUE:
            buf.write_i32(21)
        if value == ManifestBuilderValueKind.DECIMAL_VALUE:
            buf.write_i32(22)
        if value == ManifestBuilderValueKind.PRECISE_DECIMAL_VALUE:
            buf.write_i32(23)
        if value == ManifestBuilderValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE:
            buf.write_i32(24)
        if value == ManifestBuilderValueKind.ADDRESS_RESERVATION_VALUE:
            buf.write_i32(25)


class ManifestClass(enum.Enum):
    GENERAL = 1
    TRANSFER = 2
    POOL_CONTRIBUTION = 3
    POOL_REDEMPTION = 4
    VALIDATOR_STAKE = 5
    VALIDATOR_UNSTAKE = 6
    VALIDATOR_CLAIM = 7
    ACCOUNT_DEPOSIT_SETTINGS_UPDATE = 8


class _UniffiConverterTypeManifestClass(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestClass.GENERAL
        if variant == 2:
            return ManifestClass.TRANSFER
        if variant == 3:
            return ManifestClass.POOL_CONTRIBUTION
        if variant == 4:
            return ManifestClass.POOL_REDEMPTION
        if variant == 5:
            return ManifestClass.VALIDATOR_STAKE
        if variant == 6:
            return ManifestClass.VALIDATOR_UNSTAKE
        if variant == 7:
            return ManifestClass.VALIDATOR_CLAIM
        if variant == 8:
            return ManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestClass.GENERAL:
            buf.write_i32(1)
        if value == ManifestClass.TRANSFER:
            buf.write_i32(2)
        if value == ManifestClass.POOL_CONTRIBUTION:
            buf.write_i32(3)
        if value == ManifestClass.POOL_REDEMPTION:
            buf.write_i32(4)
        if value == ManifestClass.VALIDATOR_STAKE:
            buf.write_i32(5)
        if value == ManifestClass.VALIDATOR_UNSTAKE:
            buf.write_i32(6)
        if value == ManifestClass.VALIDATOR_CLAIM:
            buf.write_i32(7)
        if value == ManifestClass.ACCOUNT_DEPOSIT_SETTINGS_UPDATE:
            buf.write_i32(8)


class ManifestExpression(enum.Enum):
    ENTIRE_WORKTOP = 1
    ENTIRE_AUTH_ZONE = 2


class _UniffiConverterTypeManifestExpression(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestExpression.ENTIRE_WORKTOP
        if variant == 2:
            return ManifestExpression.ENTIRE_AUTH_ZONE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestExpression.ENTIRE_WORKTOP:
            buf.write_i32(1)
        if value == ManifestExpression.ENTIRE_AUTH_ZONE:
            buf.write_i32(2)


class ManifestSborStringRepresentation:
    def __init__(self):
        raise RuntimeError(
            "ManifestSborStringRepresentation cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class MANIFEST_STRING:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "ManifestSborStringRepresentation.MANIFEST_STRING()".format()

        def __eq__(self, other):
            if not other.is_manifest_string():
                return False
            return True

    class JSON:
        value: "SerializationMode"

        @typing.no_type_check
        def __init__(self, value: "SerializationMode"):

            self.value = value

        def __str__(self):
            return "ManifestSborStringRepresentation.JSON(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_json():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_manifest_string(self) -> bool:
        return isinstance(self, ManifestSborStringRepresentation.MANIFEST_STRING)

    def is_json(self) -> bool:
        return isinstance(self, ManifestSborStringRepresentation.JSON)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestSborStringRepresentation.MANIFEST_STRING = type(
    "ManifestSborStringRepresentation.MANIFEST_STRING",
    (
        ManifestSborStringRepresentation.MANIFEST_STRING,
        ManifestSborStringRepresentation,
    ),
    {},
)  # type: ignore
ManifestSborStringRepresentation.JSON = type(
    "ManifestSborStringRepresentation.JSON",
    (
        ManifestSborStringRepresentation.JSON,
        ManifestSborStringRepresentation,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeManifestSborStringRepresentation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestSborStringRepresentation.MANIFEST_STRING()
        if variant == 2:
            return ManifestSborStringRepresentation.JSON(
                _UniffiConverterTypeSerializationMode.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_manifest_string():
            buf.write_i32(1)
        if value.is_json():
            buf.write_i32(2)
            _UniffiConverterTypeSerializationMode.write(value.value, buf)


class ManifestValue:
    def __init__(self):
        raise RuntimeError("ManifestValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL_VALUE:
        value: "bool"

        @typing.no_type_check
        def __init__(self, value: "bool"):

            self.value = value

        def __str__(self):
            return "ManifestValue.BOOL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I8_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.I8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i8_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I16_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.I16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i16_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I32_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.I32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I64_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.I64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I128_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ManifestValue.I128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i128_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U8_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.U8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U16_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.U16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u16_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U32_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.U32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U64_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "ManifestValue.U64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U128_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ManifestValue.U128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u128_value():
                return False
            if self.value != other.value:
                return False
            return True

    class STRING_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ManifestValue.STRING_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ENUM_VALUE:
        discriminator: "int"
        fields: "typing.List[ManifestValue]"

        @typing.no_type_check
        def __init__(self, discriminator: "int", fields: "typing.List[ManifestValue]"):

            self.discriminator = discriminator
            self.fields = fields

        def __str__(self):
            return "ManifestValue.ENUM_VALUE(discriminator={}, fields={})".format(
                self.discriminator, self.fields
            )

        def __eq__(self, other):
            if not other.is_enum_value():
                return False
            if self.discriminator != other.discriminator:
                return False
            if self.fields != other.fields:
                return False
            return True

    class ARRAY_VALUE:
        element_value_kind: "ManifestValueKind"
        elements: "typing.List[ManifestValue]"

        @typing.no_type_check
        def __init__(
            self,
            element_value_kind: "ManifestValueKind",
            elements: "typing.List[ManifestValue]",
        ):

            self.element_value_kind = element_value_kind
            self.elements = elements

        def __str__(self):
            return (
                "ManifestValue.ARRAY_VALUE(element_value_kind={}, elements={})".format(
                    self.element_value_kind, self.elements
                )
            )

        def __eq__(self, other):
            if not other.is_array_value():
                return False
            if self.element_value_kind != other.element_value_kind:
                return False
            if self.elements != other.elements:
                return False
            return True

    class TUPLE_VALUE:
        fields: "typing.List[ManifestValue]"

        @typing.no_type_check
        def __init__(self, fields: "typing.List[ManifestValue]"):

            self.fields = fields

        def __str__(self):
            return "ManifestValue.TUPLE_VALUE(fields={})".format(self.fields)

        def __eq__(self, other):
            if not other.is_tuple_value():
                return False
            if self.fields != other.fields:
                return False
            return True

    class MAP_VALUE:
        key_value_kind: "ManifestValueKind"
        value_value_kind: "ManifestValueKind"
        entries: "typing.List[MapEntry]"

        @typing.no_type_check
        def __init__(
            self,
            key_value_kind: "ManifestValueKind",
            value_value_kind: "ManifestValueKind",
            entries: "typing.List[MapEntry]",
        ):

            self.key_value_kind = key_value_kind
            self.value_value_kind = value_value_kind
            self.entries = entries

        def __str__(self):
            return "ManifestValue.MAP_VALUE(key_value_kind={}, value_value_kind={}, entries={})".format(
                self.key_value_kind, self.value_value_kind, self.entries
            )

        def __eq__(self, other):
            if not other.is_map_value():
                return False
            if self.key_value_kind != other.key_value_kind:
                return False
            if self.value_value_kind != other.value_value_kind:
                return False
            if self.entries != other.entries:
                return False
            return True

    class ADDRESS_VALUE:
        value: "ManifestAddress"

        @typing.no_type_check
        def __init__(self, value: "ManifestAddress"):

            self.value = value

        def __str__(self):
            return "ManifestValue.ADDRESS_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_address_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BUCKET_VALUE:
        value: "ManifestBucket"

        @typing.no_type_check
        def __init__(self, value: "ManifestBucket"):

            self.value = value

        def __str__(self):
            return "ManifestValue.BUCKET_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bucket_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PROOF_VALUE:
        value: "ManifestProof"

        @typing.no_type_check
        def __init__(self, value: "ManifestProof"):

            self.value = value

        def __str__(self):
            return "ManifestValue.PROOF_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_proof_value():
                return False
            if self.value != other.value:
                return False
            return True

    class EXPRESSION_VALUE:
        value: "ManifestExpression"

        @typing.no_type_check
        def __init__(self, value: "ManifestExpression"):

            self.value = value

        def __str__(self):
            return "ManifestValue.EXPRESSION_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_expression_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BLOB_VALUE:
        value: "ManifestBlobRef"

        @typing.no_type_check
        def __init__(self, value: "ManifestBlobRef"):

            self.value = value

        def __str__(self):
            return "ManifestValue.BLOB_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_blob_value():
                return False
            if self.value != other.value:
                return False
            return True

    class DECIMAL_VALUE:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "ManifestValue.DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PRECISE_DECIMAL_VALUE:
        value: "PreciseDecimal"

        @typing.no_type_check
        def __init__(self, value: "PreciseDecimal"):

            self.value = value

        def __str__(self):
            return "ManifestValue.PRECISE_DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_precise_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_LOCAL_ID_VALUE:
        value: "NonFungibleLocalId"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleLocalId"):

            self.value = value

        def __str__(self):
            return "ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ADDRESS_RESERVATION_VALUE:
        value: "ManifestAddressReservation"

        @typing.no_type_check
        def __init__(self, value: "ManifestAddressReservation"):

            self.value = value

        def __str__(self):
            return "ManifestValue.ADDRESS_RESERVATION_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_address_reservation_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bool_value(self) -> bool:
        return isinstance(self, ManifestValue.BOOL_VALUE)

    def is_i8_value(self) -> bool:
        return isinstance(self, ManifestValue.I8_VALUE)

    def is_i16_value(self) -> bool:
        return isinstance(self, ManifestValue.I16_VALUE)

    def is_i32_value(self) -> bool:
        return isinstance(self, ManifestValue.I32_VALUE)

    def is_i64_value(self) -> bool:
        return isinstance(self, ManifestValue.I64_VALUE)

    def is_i128_value(self) -> bool:
        return isinstance(self, ManifestValue.I128_VALUE)

    def is_u8_value(self) -> bool:
        return isinstance(self, ManifestValue.U8_VALUE)

    def is_u16_value(self) -> bool:
        return isinstance(self, ManifestValue.U16_VALUE)

    def is_u32_value(self) -> bool:
        return isinstance(self, ManifestValue.U32_VALUE)

    def is_u64_value(self) -> bool:
        return isinstance(self, ManifestValue.U64_VALUE)

    def is_u128_value(self) -> bool:
        return isinstance(self, ManifestValue.U128_VALUE)

    def is_string_value(self) -> bool:
        return isinstance(self, ManifestValue.STRING_VALUE)

    def is_enum_value(self) -> bool:
        return isinstance(self, ManifestValue.ENUM_VALUE)

    def is_array_value(self) -> bool:
        return isinstance(self, ManifestValue.ARRAY_VALUE)

    def is_tuple_value(self) -> bool:
        return isinstance(self, ManifestValue.TUPLE_VALUE)

    def is_map_value(self) -> bool:
        return isinstance(self, ManifestValue.MAP_VALUE)

    def is_address_value(self) -> bool:
        return isinstance(self, ManifestValue.ADDRESS_VALUE)

    def is_bucket_value(self) -> bool:
        return isinstance(self, ManifestValue.BUCKET_VALUE)

    def is_proof_value(self) -> bool:
        return isinstance(self, ManifestValue.PROOF_VALUE)

    def is_expression_value(self) -> bool:
        return isinstance(self, ManifestValue.EXPRESSION_VALUE)

    def is_blob_value(self) -> bool:
        return isinstance(self, ManifestValue.BLOB_VALUE)

    def is_decimal_value(self) -> bool:
        return isinstance(self, ManifestValue.DECIMAL_VALUE)

    def is_precise_decimal_value(self) -> bool:
        return isinstance(self, ManifestValue.PRECISE_DECIMAL_VALUE)

    def is_non_fungible_local_id_value(self) -> bool:
        return isinstance(self, ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE)

    def is_address_reservation_value(self) -> bool:
        return isinstance(self, ManifestValue.ADDRESS_RESERVATION_VALUE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestValue.BOOL_VALUE = type(
    "ManifestValue.BOOL_VALUE",
    (
        ManifestValue.BOOL_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.I8_VALUE = type(
    "ManifestValue.I8_VALUE",
    (
        ManifestValue.I8_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.I16_VALUE = type(
    "ManifestValue.I16_VALUE",
    (
        ManifestValue.I16_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.I32_VALUE = type(
    "ManifestValue.I32_VALUE",
    (
        ManifestValue.I32_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.I64_VALUE = type(
    "ManifestValue.I64_VALUE",
    (
        ManifestValue.I64_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.I128_VALUE = type(
    "ManifestValue.I128_VALUE",
    (
        ManifestValue.I128_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.U8_VALUE = type(
    "ManifestValue.U8_VALUE",
    (
        ManifestValue.U8_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.U16_VALUE = type(
    "ManifestValue.U16_VALUE",
    (
        ManifestValue.U16_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.U32_VALUE = type(
    "ManifestValue.U32_VALUE",
    (
        ManifestValue.U32_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.U64_VALUE = type(
    "ManifestValue.U64_VALUE",
    (
        ManifestValue.U64_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.U128_VALUE = type(
    "ManifestValue.U128_VALUE",
    (
        ManifestValue.U128_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.STRING_VALUE = type(
    "ManifestValue.STRING_VALUE",
    (
        ManifestValue.STRING_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.ENUM_VALUE = type(
    "ManifestValue.ENUM_VALUE",
    (
        ManifestValue.ENUM_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.ARRAY_VALUE = type(
    "ManifestValue.ARRAY_VALUE",
    (
        ManifestValue.ARRAY_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.TUPLE_VALUE = type(
    "ManifestValue.TUPLE_VALUE",
    (
        ManifestValue.TUPLE_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.MAP_VALUE = type(
    "ManifestValue.MAP_VALUE",
    (
        ManifestValue.MAP_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.ADDRESS_VALUE = type(
    "ManifestValue.ADDRESS_VALUE",
    (
        ManifestValue.ADDRESS_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.BUCKET_VALUE = type(
    "ManifestValue.BUCKET_VALUE",
    (
        ManifestValue.BUCKET_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.PROOF_VALUE = type(
    "ManifestValue.PROOF_VALUE",
    (
        ManifestValue.PROOF_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.EXPRESSION_VALUE = type(
    "ManifestValue.EXPRESSION_VALUE",
    (
        ManifestValue.EXPRESSION_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.BLOB_VALUE = type(
    "ManifestValue.BLOB_VALUE",
    (
        ManifestValue.BLOB_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.DECIMAL_VALUE = type(
    "ManifestValue.DECIMAL_VALUE",
    (
        ManifestValue.DECIMAL_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.PRECISE_DECIMAL_VALUE = type(
    "ManifestValue.PRECISE_DECIMAL_VALUE",
    (
        ManifestValue.PRECISE_DECIMAL_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE = type(
    "ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE",
    (
        ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore
ManifestValue.ADDRESS_RESERVATION_VALUE = type(
    "ManifestValue.ADDRESS_RESERVATION_VALUE",
    (
        ManifestValue.ADDRESS_RESERVATION_VALUE,
        ManifestValue,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeManifestValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestValue.BOOL_VALUE(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return ManifestValue.I8_VALUE(
                _UniffiConverterInt8.read(buf),
            )
        if variant == 3:
            return ManifestValue.I16_VALUE(
                _UniffiConverterInt16.read(buf),
            )
        if variant == 4:
            return ManifestValue.I32_VALUE(
                _UniffiConverterInt32.read(buf),
            )
        if variant == 5:
            return ManifestValue.I64_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 6:
            return ManifestValue.I128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ManifestValue.U8_VALUE(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 8:
            return ManifestValue.U16_VALUE(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 9:
            return ManifestValue.U32_VALUE(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return ManifestValue.U64_VALUE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 11:
            return ManifestValue.U128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return ManifestValue.STRING_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return ManifestValue.ENUM_VALUE(
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterSequenceTypeManifestValue.read(buf),
            )
        if variant == 14:
            return ManifestValue.ARRAY_VALUE(
                _UniffiConverterTypeManifestValueKind.read(buf),
                _UniffiConverterSequenceTypeManifestValue.read(buf),
            )
        if variant == 15:
            return ManifestValue.TUPLE_VALUE(
                _UniffiConverterSequenceTypeManifestValue.read(buf),
            )
        if variant == 16:
            return ManifestValue.MAP_VALUE(
                _UniffiConverterTypeManifestValueKind.read(buf),
                _UniffiConverterTypeManifestValueKind.read(buf),
                _UniffiConverterSequenceTypeMapEntry.read(buf),
            )
        if variant == 17:
            return ManifestValue.ADDRESS_VALUE(
                _UniffiConverterTypeManifestAddress.read(buf),
            )
        if variant == 18:
            return ManifestValue.BUCKET_VALUE(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 19:
            return ManifestValue.PROOF_VALUE(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 20:
            return ManifestValue.EXPRESSION_VALUE(
                _UniffiConverterTypeManifestExpression.read(buf),
            )
        if variant == 21:
            return ManifestValue.BLOB_VALUE(
                _UniffiConverterTypeManifestBlobRef.read(buf),
            )
        if variant == 22:
            return ManifestValue.DECIMAL_VALUE(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 23:
            return ManifestValue.PRECISE_DECIMAL_VALUE(
                _UniffiConverterTypePreciseDecimal.read(buf),
            )
        if variant == 24:
            return ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleLocalId.read(buf),
            )
        if variant == 25:
            return ManifestValue.ADDRESS_RESERVATION_VALUE(
                _UniffiConverterTypeManifestAddressReservation.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bool_value():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.value, buf)
        if value.is_i8_value():
            buf.write_i32(2)
            _UniffiConverterInt8.write(value.value, buf)
        if value.is_i16_value():
            buf.write_i32(3)
            _UniffiConverterInt16.write(value.value, buf)
        if value.is_i32_value():
            buf.write_i32(4)
            _UniffiConverterInt32.write(value.value, buf)
        if value.is_i64_value():
            buf.write_i32(5)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_i128_value():
            buf.write_i32(6)
            _UniffiConverterString.write(value.value, buf)
        if value.is_u8_value():
            buf.write_i32(7)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_u16_value():
            buf.write_i32(8)
            _UniffiConverterUInt16.write(value.value, buf)
        if value.is_u32_value():
            buf.write_i32(9)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_u64_value():
            buf.write_i32(10)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_u128_value():
            buf.write_i32(11)
            _UniffiConverterString.write(value.value, buf)
        if value.is_string_value():
            buf.write_i32(12)
            _UniffiConverterString.write(value.value, buf)
        if value.is_enum_value():
            buf.write_i32(13)
            _UniffiConverterUInt8.write(value.discriminator, buf)
            _UniffiConverterSequenceTypeManifestValue.write(value.fields, buf)
        if value.is_array_value():
            buf.write_i32(14)
            _UniffiConverterTypeManifestValueKind.write(value.element_value_kind, buf)
            _UniffiConverterSequenceTypeManifestValue.write(value.elements, buf)
        if value.is_tuple_value():
            buf.write_i32(15)
            _UniffiConverterSequenceTypeManifestValue.write(value.fields, buf)
        if value.is_map_value():
            buf.write_i32(16)
            _UniffiConverterTypeManifestValueKind.write(value.key_value_kind, buf)
            _UniffiConverterTypeManifestValueKind.write(value.value_value_kind, buf)
            _UniffiConverterSequenceTypeMapEntry.write(value.entries, buf)
        if value.is_address_value():
            buf.write_i32(17)
            _UniffiConverterTypeManifestAddress.write(value.value, buf)
        if value.is_bucket_value():
            buf.write_i32(18)
            _UniffiConverterTypeManifestBucket.write(value.value, buf)
        if value.is_proof_value():
            buf.write_i32(19)
            _UniffiConverterTypeManifestProof.write(value.value, buf)
        if value.is_expression_value():
            buf.write_i32(20)
            _UniffiConverterTypeManifestExpression.write(value.value, buf)
        if value.is_blob_value():
            buf.write_i32(21)
            _UniffiConverterTypeManifestBlobRef.write(value.value, buf)
        if value.is_decimal_value():
            buf.write_i32(22)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_precise_decimal_value():
            buf.write_i32(23)
            _UniffiConverterTypePreciseDecimal.write(value.value, buf)
        if value.is_non_fungible_local_id_value():
            buf.write_i32(24)
            _UniffiConverterTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_address_reservation_value():
            buf.write_i32(25)
            _UniffiConverterTypeManifestAddressReservation.write(value.value, buf)


class ManifestValueKind(enum.Enum):
    BOOL_VALUE = 1
    I8_VALUE = 2
    I16_VALUE = 3
    I32_VALUE = 4
    I64_VALUE = 5
    I128_VALUE = 6
    U8_VALUE = 7
    U16_VALUE = 8
    U32_VALUE = 9
    U64_VALUE = 10
    U128_VALUE = 11
    STRING_VALUE = 12
    ENUM_VALUE = 13
    ARRAY_VALUE = 14
    TUPLE_VALUE = 15
    MAP_VALUE = 16
    ADDRESS_VALUE = 17
    BUCKET_VALUE = 18
    PROOF_VALUE = 19
    EXPRESSION_VALUE = 20
    BLOB_VALUE = 21
    DECIMAL_VALUE = 22
    PRECISE_DECIMAL_VALUE = 23
    NON_FUNGIBLE_LOCAL_ID_VALUE = 24
    ADDRESS_RESERVATION_VALUE = 25


class _UniffiConverterTypeManifestValueKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestValueKind.BOOL_VALUE
        if variant == 2:
            return ManifestValueKind.I8_VALUE
        if variant == 3:
            return ManifestValueKind.I16_VALUE
        if variant == 4:
            return ManifestValueKind.I32_VALUE
        if variant == 5:
            return ManifestValueKind.I64_VALUE
        if variant == 6:
            return ManifestValueKind.I128_VALUE
        if variant == 7:
            return ManifestValueKind.U8_VALUE
        if variant == 8:
            return ManifestValueKind.U16_VALUE
        if variant == 9:
            return ManifestValueKind.U32_VALUE
        if variant == 10:
            return ManifestValueKind.U64_VALUE
        if variant == 11:
            return ManifestValueKind.U128_VALUE
        if variant == 12:
            return ManifestValueKind.STRING_VALUE
        if variant == 13:
            return ManifestValueKind.ENUM_VALUE
        if variant == 14:
            return ManifestValueKind.ARRAY_VALUE
        if variant == 15:
            return ManifestValueKind.TUPLE_VALUE
        if variant == 16:
            return ManifestValueKind.MAP_VALUE
        if variant == 17:
            return ManifestValueKind.ADDRESS_VALUE
        if variant == 18:
            return ManifestValueKind.BUCKET_VALUE
        if variant == 19:
            return ManifestValueKind.PROOF_VALUE
        if variant == 20:
            return ManifestValueKind.EXPRESSION_VALUE
        if variant == 21:
            return ManifestValueKind.BLOB_VALUE
        if variant == 22:
            return ManifestValueKind.DECIMAL_VALUE
        if variant == 23:
            return ManifestValueKind.PRECISE_DECIMAL_VALUE
        if variant == 24:
            return ManifestValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE
        if variant == 25:
            return ManifestValueKind.ADDRESS_RESERVATION_VALUE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestValueKind.BOOL_VALUE:
            buf.write_i32(1)
        if value == ManifestValueKind.I8_VALUE:
            buf.write_i32(2)
        if value == ManifestValueKind.I16_VALUE:
            buf.write_i32(3)
        if value == ManifestValueKind.I32_VALUE:
            buf.write_i32(4)
        if value == ManifestValueKind.I64_VALUE:
            buf.write_i32(5)
        if value == ManifestValueKind.I128_VALUE:
            buf.write_i32(6)
        if value == ManifestValueKind.U8_VALUE:
            buf.write_i32(7)
        if value == ManifestValueKind.U16_VALUE:
            buf.write_i32(8)
        if value == ManifestValueKind.U32_VALUE:
            buf.write_i32(9)
        if value == ManifestValueKind.U64_VALUE:
            buf.write_i32(10)
        if value == ManifestValueKind.U128_VALUE:
            buf.write_i32(11)
        if value == ManifestValueKind.STRING_VALUE:
            buf.write_i32(12)
        if value == ManifestValueKind.ENUM_VALUE:
            buf.write_i32(13)
        if value == ManifestValueKind.ARRAY_VALUE:
            buf.write_i32(14)
        if value == ManifestValueKind.TUPLE_VALUE:
            buf.write_i32(15)
        if value == ManifestValueKind.MAP_VALUE:
            buf.write_i32(16)
        if value == ManifestValueKind.ADDRESS_VALUE:
            buf.write_i32(17)
        if value == ManifestValueKind.BUCKET_VALUE:
            buf.write_i32(18)
        if value == ManifestValueKind.PROOF_VALUE:
            buf.write_i32(19)
        if value == ManifestValueKind.EXPRESSION_VALUE:
            buf.write_i32(20)
        if value == ManifestValueKind.BLOB_VALUE:
            buf.write_i32(21)
        if value == ManifestValueKind.DECIMAL_VALUE:
            buf.write_i32(22)
        if value == ManifestValueKind.PRECISE_DECIMAL_VALUE:
            buf.write_i32(23)
        if value == ManifestValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE:
            buf.write_i32(24)
        if value == ManifestValueKind.ADDRESS_RESERVATION_VALUE:
            buf.write_i32(25)


class Message:
    def __init__(self):
        raise RuntimeError("Message cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NONE:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "Message.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True

    class PLAIN_TEXT:
        value: "PlainTextMessage"

        @typing.no_type_check
        def __init__(self, value: "PlainTextMessage"):

            self.value = value

        def __str__(self):
            return "Message.PLAIN_TEXT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_plain_text():
                return False
            if self.value != other.value:
                return False
            return True

    class ENCRYPTED:
        value: "EncryptedMessage"

        @typing.no_type_check
        def __init__(self, value: "EncryptedMessage"):

            self.value = value

        def __str__(self):
            return "Message.ENCRYPTED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_encrypted():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_none(self) -> bool:
        return isinstance(self, Message.NONE)

    def is_plain_text(self) -> bool:
        return isinstance(self, Message.PLAIN_TEXT)

    def is_encrypted(self) -> bool:
        return isinstance(self, Message.ENCRYPTED)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Message.NONE = type(
    "Message.NONE",
    (
        Message.NONE,
        Message,
    ),
    {},
)  # type: ignore
Message.PLAIN_TEXT = type(
    "Message.PLAIN_TEXT",
    (
        Message.PLAIN_TEXT,
        Message,
    ),
    {},
)  # type: ignore
Message.ENCRYPTED = type(
    "Message.ENCRYPTED",
    (
        Message.ENCRYPTED,
        Message,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Message.NONE()
        if variant == 2:
            return Message.PLAIN_TEXT(
                _UniffiConverterTypePlainTextMessage.read(buf),
            )
        if variant == 3:
            return Message.ENCRYPTED(
                _UniffiConverterTypeEncryptedMessage.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_none():
            buf.write_i32(1)
        if value.is_plain_text():
            buf.write_i32(2)
            _UniffiConverterTypePlainTextMessage.write(value.value, buf)
        if value.is_encrypted():
            buf.write_i32(3)
            _UniffiConverterTypeEncryptedMessage.write(value.value, buf)


class MessageContent:
    def __init__(self):
        raise RuntimeError("MessageContent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class STR:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "MessageContent.STR(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.value != other.value:
                return False
            return True

    class BYTES:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "MessageContent.BYTES(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bytes():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_str(self) -> bool:
        return isinstance(self, MessageContent.STR)

    def is_bytes(self) -> bool:
        return isinstance(self, MessageContent.BYTES)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MessageContent.STR = type(
    "MessageContent.STR",
    (
        MessageContent.STR,
        MessageContent,
    ),
    {},
)  # type: ignore
MessageContent.BYTES = type(
    "MessageContent.BYTES",
    (
        MessageContent.BYTES,
        MessageContent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeMessageContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MessageContent.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return MessageContent.BYTES(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_str():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_bytes():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.value, buf)


class MetadataValue:
    def __init__(self):
        raise RuntimeError("MetadataValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class STRING_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "MetadataValue.STRING_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BOOL_VALUE:
        value: "bool"

        @typing.no_type_check
        def __init__(self, value: "bool"):

            self.value = value

        def __str__(self):
            return "MetadataValue.BOOL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U8_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "MetadataValue.U8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U32_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "MetadataValue.U32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U64_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "MetadataValue.U64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I32_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "MetadataValue.I32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I64_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "MetadataValue.I64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_value():
                return False
            if self.value != other.value:
                return False
            return True

    class DECIMAL_VALUE:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "MetadataValue.DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True

    class GLOBAL_ADDRESS_VALUE:
        value: "Address"

        @typing.no_type_check
        def __init__(self, value: "Address"):

            self.value = value

        def __str__(self):
            return "MetadataValue.GLOBAL_ADDRESS_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_global_address_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PUBLIC_KEY_VALUE:
        value: "PublicKey"

        @typing.no_type_check
        def __init__(self, value: "PublicKey"):

            self.value = value

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_GLOBAL_ID_VALUE:
        value: "NonFungibleGlobalId"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleGlobalId"):

            self.value = value

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_global_id_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_LOCAL_ID_VALUE:
        value: "NonFungibleLocalId"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleLocalId"):

            self.value = value

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_value():
                return False
            if self.value != other.value:
                return False
            return True

    class INSTANT_VALUE:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "MetadataValue.INSTANT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_instant_value():
                return False
            if self.value != other.value:
                return False
            return True

    class URL_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "MetadataValue.URL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_url_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ORIGIN_VALUE:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "MetadataValue.ORIGIN_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_origin_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PUBLIC_KEY_HASH_VALUE:
        value: "PublicKeyHash"

        @typing.no_type_check
        def __init__(self, value: "PublicKeyHash"):

            self.value = value

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_HASH_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_hash_value():
                return False
            if self.value != other.value:
                return False
            return True

    class STRING_ARRAY_VALUE:
        value: "typing.List[str]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[str]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.STRING_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BOOL_ARRAY_VALUE:
        value: "typing.List[bool]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[bool]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.BOOL_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U8_ARRAY_VALUE:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "MetadataValue.U8_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U32_ARRAY_VALUE:
        value: "typing.List[int]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[int]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.U32_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class U64_ARRAY_VALUE:
        value: "typing.List[int]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[int]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.U64_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I32_ARRAY_VALUE:
        value: "typing.List[int]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[int]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.I32_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class I64_ARRAY_VALUE:
        value: "typing.List[int]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[int]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.I64_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class DECIMAL_ARRAY_VALUE:
        value: "typing.List[Decimal]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[Decimal]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.DECIMAL_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class GLOBAL_ADDRESS_ARRAY_VALUE:
        value: "typing.List[Address]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[Address]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_global_address_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PUBLIC_KEY_ARRAY_VALUE:
        value: "typing.List[PublicKey]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[PublicKey]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE:
        value: "typing.List[NonFungibleGlobalId]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[NonFungibleGlobalId]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_global_id_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE:
        value: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[NonFungibleLocalId]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class INSTANT_ARRAY_VALUE:
        value: "typing.List[int]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[int]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.INSTANT_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_instant_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class URL_ARRAY_VALUE:
        value: "typing.List[str]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[str]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.URL_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_url_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ORIGIN_ARRAY_VALUE:
        value: "typing.List[str]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[str]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.ORIGIN_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_origin_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PUBLIC_KEY_HASH_ARRAY_VALUE:
        value: "typing.List[PublicKeyHash]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[PublicKeyHash]"):

            self.value = value

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_public_key_hash_array_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_string_value(self) -> bool:
        return isinstance(self, MetadataValue.STRING_VALUE)

    def is_bool_value(self) -> bool:
        return isinstance(self, MetadataValue.BOOL_VALUE)

    def is_u8_value(self) -> bool:
        return isinstance(self, MetadataValue.U8_VALUE)

    def is_u32_value(self) -> bool:
        return isinstance(self, MetadataValue.U32_VALUE)

    def is_u64_value(self) -> bool:
        return isinstance(self, MetadataValue.U64_VALUE)

    def is_i32_value(self) -> bool:
        return isinstance(self, MetadataValue.I32_VALUE)

    def is_i64_value(self) -> bool:
        return isinstance(self, MetadataValue.I64_VALUE)

    def is_decimal_value(self) -> bool:
        return isinstance(self, MetadataValue.DECIMAL_VALUE)

    def is_global_address_value(self) -> bool:
        return isinstance(self, MetadataValue.GLOBAL_ADDRESS_VALUE)

    def is_public_key_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_VALUE)

    def is_non_fungible_global_id_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE)

    def is_non_fungible_local_id_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE)

    def is_instant_value(self) -> bool:
        return isinstance(self, MetadataValue.INSTANT_VALUE)

    def is_url_value(self) -> bool:
        return isinstance(self, MetadataValue.URL_VALUE)

    def is_origin_value(self) -> bool:
        return isinstance(self, MetadataValue.ORIGIN_VALUE)

    def is_public_key_hash_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_HASH_VALUE)

    def is_string_array_value(self) -> bool:
        return isinstance(self, MetadataValue.STRING_ARRAY_VALUE)

    def is_bool_array_value(self) -> bool:
        return isinstance(self, MetadataValue.BOOL_ARRAY_VALUE)

    def is_u8_array_value(self) -> bool:
        return isinstance(self, MetadataValue.U8_ARRAY_VALUE)

    def is_u32_array_value(self) -> bool:
        return isinstance(self, MetadataValue.U32_ARRAY_VALUE)

    def is_u64_array_value(self) -> bool:
        return isinstance(self, MetadataValue.U64_ARRAY_VALUE)

    def is_i32_array_value(self) -> bool:
        return isinstance(self, MetadataValue.I32_ARRAY_VALUE)

    def is_i64_array_value(self) -> bool:
        return isinstance(self, MetadataValue.I64_ARRAY_VALUE)

    def is_decimal_array_value(self) -> bool:
        return isinstance(self, MetadataValue.DECIMAL_ARRAY_VALUE)

    def is_global_address_array_value(self) -> bool:
        return isinstance(self, MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE)

    def is_public_key_array_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_ARRAY_VALUE)

    def is_non_fungible_global_id_array_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE)

    def is_non_fungible_local_id_array_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE)

    def is_instant_array_value(self) -> bool:
        return isinstance(self, MetadataValue.INSTANT_ARRAY_VALUE)

    def is_url_array_value(self) -> bool:
        return isinstance(self, MetadataValue.URL_ARRAY_VALUE)

    def is_origin_array_value(self) -> bool:
        return isinstance(self, MetadataValue.ORIGIN_ARRAY_VALUE)

    def is_public_key_hash_array_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MetadataValue.STRING_VALUE = type(
    "MetadataValue.STRING_VALUE",
    (
        MetadataValue.STRING_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.BOOL_VALUE = type(
    "MetadataValue.BOOL_VALUE",
    (
        MetadataValue.BOOL_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.U8_VALUE = type(
    "MetadataValue.U8_VALUE",
    (
        MetadataValue.U8_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.U32_VALUE = type(
    "MetadataValue.U32_VALUE",
    (
        MetadataValue.U32_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.U64_VALUE = type(
    "MetadataValue.U64_VALUE",
    (
        MetadataValue.U64_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.I32_VALUE = type(
    "MetadataValue.I32_VALUE",
    (
        MetadataValue.I32_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.I64_VALUE = type(
    "MetadataValue.I64_VALUE",
    (
        MetadataValue.I64_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.DECIMAL_VALUE = type(
    "MetadataValue.DECIMAL_VALUE",
    (
        MetadataValue.DECIMAL_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.GLOBAL_ADDRESS_VALUE = type(
    "MetadataValue.GLOBAL_ADDRESS_VALUE",
    (
        MetadataValue.GLOBAL_ADDRESS_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.PUBLIC_KEY_VALUE = type(
    "MetadataValue.PUBLIC_KEY_VALUE",
    (
        MetadataValue.PUBLIC_KEY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE = type(
    "MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE",
    (
        MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE = type(
    "MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE",
    (
        MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.INSTANT_VALUE = type(
    "MetadataValue.INSTANT_VALUE",
    (
        MetadataValue.INSTANT_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.URL_VALUE = type(
    "MetadataValue.URL_VALUE",
    (
        MetadataValue.URL_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.ORIGIN_VALUE = type(
    "MetadataValue.ORIGIN_VALUE",
    (
        MetadataValue.ORIGIN_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.PUBLIC_KEY_HASH_VALUE = type(
    "MetadataValue.PUBLIC_KEY_HASH_VALUE",
    (
        MetadataValue.PUBLIC_KEY_HASH_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.STRING_ARRAY_VALUE = type(
    "MetadataValue.STRING_ARRAY_VALUE",
    (
        MetadataValue.STRING_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.BOOL_ARRAY_VALUE = type(
    "MetadataValue.BOOL_ARRAY_VALUE",
    (
        MetadataValue.BOOL_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.U8_ARRAY_VALUE = type(
    "MetadataValue.U8_ARRAY_VALUE",
    (
        MetadataValue.U8_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.U32_ARRAY_VALUE = type(
    "MetadataValue.U32_ARRAY_VALUE",
    (
        MetadataValue.U32_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.U64_ARRAY_VALUE = type(
    "MetadataValue.U64_ARRAY_VALUE",
    (
        MetadataValue.U64_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.I32_ARRAY_VALUE = type(
    "MetadataValue.I32_ARRAY_VALUE",
    (
        MetadataValue.I32_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.I64_ARRAY_VALUE = type(
    "MetadataValue.I64_ARRAY_VALUE",
    (
        MetadataValue.I64_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.DECIMAL_ARRAY_VALUE = type(
    "MetadataValue.DECIMAL_ARRAY_VALUE",
    (
        MetadataValue.DECIMAL_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE = type(
    "MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE",
    (
        MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.PUBLIC_KEY_ARRAY_VALUE = type(
    "MetadataValue.PUBLIC_KEY_ARRAY_VALUE",
    (
        MetadataValue.PUBLIC_KEY_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE = type(
    "MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE",
    (
        MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE = type(
    "MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE",
    (
        MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.INSTANT_ARRAY_VALUE = type(
    "MetadataValue.INSTANT_ARRAY_VALUE",
    (
        MetadataValue.INSTANT_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.URL_ARRAY_VALUE = type(
    "MetadataValue.URL_ARRAY_VALUE",
    (
        MetadataValue.URL_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.ORIGIN_ARRAY_VALUE = type(
    "MetadataValue.ORIGIN_ARRAY_VALUE",
    (
        MetadataValue.ORIGIN_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore
MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE = type(
    "MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE",
    (
        MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE,
        MetadataValue,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeMetadataValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MetadataValue.STRING_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return MetadataValue.BOOL_VALUE(
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return MetadataValue.U8_VALUE(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 4:
            return MetadataValue.U32_VALUE(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 5:
            return MetadataValue.U64_VALUE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 6:
            return MetadataValue.I32_VALUE(
                _UniffiConverterInt32.read(buf),
            )
        if variant == 7:
            return MetadataValue.I64_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 8:
            return MetadataValue.DECIMAL_VALUE(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 9:
            return MetadataValue.GLOBAL_ADDRESS_VALUE(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 10:
            return MetadataValue.PUBLIC_KEY_VALUE(
                _UniffiConverterTypePublicKey.read(buf),
            )
        if variant == 11:
            return MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleGlobalId.read(buf),
            )
        if variant == 12:
            return MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleLocalId.read(buf),
            )
        if variant == 13:
            return MetadataValue.INSTANT_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 14:
            return MetadataValue.URL_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return MetadataValue.ORIGIN_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return MetadataValue.PUBLIC_KEY_HASH_VALUE(
                _UniffiConverterTypePublicKeyHash.read(buf),
            )
        if variant == 17:
            return MetadataValue.STRING_ARRAY_VALUE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 18:
            return MetadataValue.BOOL_ARRAY_VALUE(
                _UniffiConverterSequenceBool.read(buf),
            )
        if variant == 19:
            return MetadataValue.U8_ARRAY_VALUE(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 20:
            return MetadataValue.U32_ARRAY_VALUE(
                _UniffiConverterSequenceUInt32.read(buf),
            )
        if variant == 21:
            return MetadataValue.U64_ARRAY_VALUE(
                _UniffiConverterSequenceUInt64.read(buf),
            )
        if variant == 22:
            return MetadataValue.I32_ARRAY_VALUE(
                _UniffiConverterSequenceInt32.read(buf),
            )
        if variant == 23:
            return MetadataValue.I64_ARRAY_VALUE(
                _UniffiConverterSequenceInt64.read(buf),
            )
        if variant == 24:
            return MetadataValue.DECIMAL_ARRAY_VALUE(
                _UniffiConverterSequenceTypeDecimal.read(buf),
            )
        if variant == 25:
            return MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE(
                _UniffiConverterSequenceTypeAddress.read(buf),
            )
        if variant == 26:
            return MetadataValue.PUBLIC_KEY_ARRAY_VALUE(
                _UniffiConverterSequenceTypePublicKey.read(buf),
            )
        if variant == 27:
            return MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE(
                _UniffiConverterSequenceTypeNonFungibleGlobalId.read(buf),
            )
        if variant == 28:
            return MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 29:
            return MetadataValue.INSTANT_ARRAY_VALUE(
                _UniffiConverterSequenceInt64.read(buf),
            )
        if variant == 30:
            return MetadataValue.URL_ARRAY_VALUE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 31:
            return MetadataValue.ORIGIN_ARRAY_VALUE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 32:
            return MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE(
                _UniffiConverterSequenceTypePublicKeyHash.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_string_value():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_bool_value():
            buf.write_i32(2)
            _UniffiConverterBool.write(value.value, buf)
        if value.is_u8_value():
            buf.write_i32(3)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_u32_value():
            buf.write_i32(4)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_u64_value():
            buf.write_i32(5)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_i32_value():
            buf.write_i32(6)
            _UniffiConverterInt32.write(value.value, buf)
        if value.is_i64_value():
            buf.write_i32(7)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_decimal_value():
            buf.write_i32(8)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_global_address_value():
            buf.write_i32(9)
            _UniffiConverterTypeAddress.write(value.value, buf)
        if value.is_public_key_value():
            buf.write_i32(10)
            _UniffiConverterTypePublicKey.write(value.value, buf)
        if value.is_non_fungible_global_id_value():
            buf.write_i32(11)
            _UniffiConverterTypeNonFungibleGlobalId.write(value.value, buf)
        if value.is_non_fungible_local_id_value():
            buf.write_i32(12)
            _UniffiConverterTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_instant_value():
            buf.write_i32(13)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_url_value():
            buf.write_i32(14)
            _UniffiConverterString.write(value.value, buf)
        if value.is_origin_value():
            buf.write_i32(15)
            _UniffiConverterString.write(value.value, buf)
        if value.is_public_key_hash_value():
            buf.write_i32(16)
            _UniffiConverterTypePublicKeyHash.write(value.value, buf)
        if value.is_string_array_value():
            buf.write_i32(17)
            _UniffiConverterSequenceString.write(value.value, buf)
        if value.is_bool_array_value():
            buf.write_i32(18)
            _UniffiConverterSequenceBool.write(value.value, buf)
        if value.is_u8_array_value():
            buf.write_i32(19)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_u32_array_value():
            buf.write_i32(20)
            _UniffiConverterSequenceUInt32.write(value.value, buf)
        if value.is_u64_array_value():
            buf.write_i32(21)
            _UniffiConverterSequenceUInt64.write(value.value, buf)
        if value.is_i32_array_value():
            buf.write_i32(22)
            _UniffiConverterSequenceInt32.write(value.value, buf)
        if value.is_i64_array_value():
            buf.write_i32(23)
            _UniffiConverterSequenceInt64.write(value.value, buf)
        if value.is_decimal_array_value():
            buf.write_i32(24)
            _UniffiConverterSequenceTypeDecimal.write(value.value, buf)
        if value.is_global_address_array_value():
            buf.write_i32(25)
            _UniffiConverterSequenceTypeAddress.write(value.value, buf)
        if value.is_public_key_array_value():
            buf.write_i32(26)
            _UniffiConverterSequenceTypePublicKey.write(value.value, buf)
        if value.is_non_fungible_global_id_array_value():
            buf.write_i32(27)
            _UniffiConverterSequenceTypeNonFungibleGlobalId.write(value.value, buf)
        if value.is_non_fungible_local_id_array_value():
            buf.write_i32(28)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_instant_array_value():
            buf.write_i32(29)
            _UniffiConverterSequenceInt64.write(value.value, buf)
        if value.is_url_array_value():
            buf.write_i32(30)
            _UniffiConverterSequenceString.write(value.value, buf)
        if value.is_origin_array_value():
            buf.write_i32(31)
            _UniffiConverterSequenceString.write(value.value, buf)
        if value.is_public_key_hash_array_value():
            buf.write_i32(32)
            _UniffiConverterSequenceTypePublicKeyHash.write(value.value, buf)


class ModuleId(enum.Enum):
    MAIN = 1
    METADATA = 2
    ROYALTY = 3
    ROLE_ASSIGNMENT = 4


class _UniffiConverterTypeModuleId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ModuleId.MAIN
        if variant == 2:
            return ModuleId.METADATA
        if variant == 3:
            return ModuleId.ROYALTY
        if variant == 4:
            return ModuleId.ROLE_ASSIGNMENT
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ModuleId.MAIN:
            buf.write_i32(1)
        if value == ModuleId.METADATA:
            buf.write_i32(2)
        if value == ModuleId.ROYALTY:
            buf.write_i32(3)
        if value == ModuleId.ROLE_ASSIGNMENT:
            buf.write_i32(4)


class NameRecordError:
    def __init__(self):
        raise RuntimeError("NameRecordError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OBJECT_NAME_IS_ALREADY_TAKEN:
        object: "str"
        name: "str"

        @typing.no_type_check
        def __init__(self, object: "str", name: "str"):

            self.object = object
            self.name = name

        def __str__(self):
            return "NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN(object={}, name={})".format(
                self.object, self.name
            )

        def __eq__(self, other):
            if not other.is_object_name_is_already_taken():
                return False
            if self.object != other.object:
                return False
            if self.name != other.name:
                return False
            return True

    class OBJECT_DOES_NOT_EXIST:
        object: "str"
        name: "str"

        @typing.no_type_check
        def __init__(self, object: "str", name: "str"):

            self.object = object
            self.name = name

        def __str__(self):
            return "NameRecordError.OBJECT_DOES_NOT_EXIST(object={}, name={})".format(
                self.object, self.name
            )

        def __eq__(self, other):
            if not other.is_object_does_not_exist():
                return False
            if self.object != other.object:
                return False
            if self.name != other.name:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_object_name_is_already_taken(self) -> bool:
        return isinstance(self, NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN)

    def is_object_does_not_exist(self) -> bool:
        return isinstance(self, NameRecordError.OBJECT_DOES_NOT_EXIST)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN = type(
    "NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN",
    (
        NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN,
        NameRecordError,
    ),
    {},
)  # type: ignore
NameRecordError.OBJECT_DOES_NOT_EXIST = type(
    "NameRecordError.OBJECT_DOES_NOT_EXIST",
    (
        NameRecordError.OBJECT_DOES_NOT_EXIST,
        NameRecordError,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeNameRecordError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return NameRecordError.OBJECT_DOES_NOT_EXIST(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_object_name_is_already_taken():
            buf.write_i32(1)
            _UniffiConverterString.write(value.object, buf)
            _UniffiConverterString.write(value.name, buf)
        if value.is_object_does_not_exist():
            buf.write_i32(2)
            _UniffiConverterString.write(value.object, buf)
            _UniffiConverterString.write(value.name, buf)


class NonFungibleLocalId:
    def __init__(self):
        raise RuntimeError("NonFungibleLocalId cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INTEGER:
        value: "int"

        @typing.no_type_check
        def __init__(self, value: "int"):

            self.value = value

        def __str__(self):
            return "NonFungibleLocalId.INTEGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_integer():
                return False
            if self.value != other.value:
                return False
            return True

    class STR:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "NonFungibleLocalId.STR(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.value != other.value:
                return False
            return True

    class BYTES:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "NonFungibleLocalId.BYTES(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bytes():
                return False
            if self.value != other.value:
                return False
            return True

    class RUID:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "NonFungibleLocalId.RUID(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ruid():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_integer(self) -> bool:
        return isinstance(self, NonFungibleLocalId.INTEGER)

    def is_str(self) -> bool:
        return isinstance(self, NonFungibleLocalId.STR)

    def is_bytes(self) -> bool:
        return isinstance(self, NonFungibleLocalId.BYTES)

    def is_ruid(self) -> bool:
        return isinstance(self, NonFungibleLocalId.RUID)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NonFungibleLocalId.INTEGER = type(
    "NonFungibleLocalId.INTEGER",
    (
        NonFungibleLocalId.INTEGER,
        NonFungibleLocalId,
    ),
    {},
)  # type: ignore
NonFungibleLocalId.STR = type(
    "NonFungibleLocalId.STR",
    (
        NonFungibleLocalId.STR,
        NonFungibleLocalId,
    ),
    {},
)  # type: ignore
NonFungibleLocalId.BYTES = type(
    "NonFungibleLocalId.BYTES",
    (
        NonFungibleLocalId.BYTES,
        NonFungibleLocalId,
    ),
    {},
)  # type: ignore
NonFungibleLocalId.RUID = type(
    "NonFungibleLocalId.RUID",
    (
        NonFungibleLocalId.RUID,
        NonFungibleLocalId,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeNonFungibleLocalId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NonFungibleLocalId.INTEGER(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return NonFungibleLocalId.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return NonFungibleLocalId.BYTES(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 4:
            return NonFungibleLocalId.RUID(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_integer():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_str():
            buf.write_i32(2)
            _UniffiConverterString.write(value.value, buf)
        if value.is_bytes():
            buf.write_i32(3)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_ruid():
            buf.write_i32(4)
            _UniffiConverterBytes.write(value.value, buf)


class NonFungibleResourceIndicator:
    def __init__(self):
        raise RuntimeError(
            "NonFungibleResourceIndicator cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class BY_ALL:
        predicted_amount: "PredictedDecimal"
        predicted_ids: "PredictedNonFungibleIds"

        @typing.no_type_check
        def __init__(
            self,
            predicted_amount: "PredictedDecimal",
            predicted_ids: "PredictedNonFungibleIds",
        ):

            self.predicted_amount = predicted_amount
            self.predicted_ids = predicted_ids

        def __str__(self):
            return "NonFungibleResourceIndicator.BY_ALL(predicted_amount={}, predicted_ids={})".format(
                self.predicted_amount, self.predicted_ids
            )

        def __eq__(self, other):
            if not other.is_by_all():
                return False
            if self.predicted_amount != other.predicted_amount:
                return False
            if self.predicted_ids != other.predicted_ids:
                return False
            return True

    class BY_AMOUNT:
        amount: "Decimal"
        predicted_ids: "PredictedNonFungibleIds"

        @typing.no_type_check
        def __init__(self, amount: "Decimal", predicted_ids: "PredictedNonFungibleIds"):

            self.amount = amount
            self.predicted_ids = predicted_ids

        def __str__(self):
            return "NonFungibleResourceIndicator.BY_AMOUNT(amount={}, predicted_ids={})".format(
                self.amount, self.predicted_ids
            )

        def __eq__(self, other):
            if not other.is_by_amount():
                return False
            if self.amount != other.amount:
                return False
            if self.predicted_ids != other.predicted_ids:
                return False
            return True

    class BY_IDS:
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(self, ids: "typing.List[NonFungibleLocalId]"):

            self.ids = ids

        def __str__(self):
            return "NonFungibleResourceIndicator.BY_IDS(ids={})".format(self.ids)

        def __eq__(self, other):
            if not other.is_by_ids():
                return False
            if self.ids != other.ids:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_by_all(self) -> bool:
        return isinstance(self, NonFungibleResourceIndicator.BY_ALL)

    def is_by_amount(self) -> bool:
        return isinstance(self, NonFungibleResourceIndicator.BY_AMOUNT)

    def is_by_ids(self) -> bool:
        return isinstance(self, NonFungibleResourceIndicator.BY_IDS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NonFungibleResourceIndicator.BY_ALL = type(
    "NonFungibleResourceIndicator.BY_ALL",
    (
        NonFungibleResourceIndicator.BY_ALL,
        NonFungibleResourceIndicator,
    ),
    {},
)  # type: ignore
NonFungibleResourceIndicator.BY_AMOUNT = type(
    "NonFungibleResourceIndicator.BY_AMOUNT",
    (
        NonFungibleResourceIndicator.BY_AMOUNT,
        NonFungibleResourceIndicator,
    ),
    {},
)  # type: ignore
NonFungibleResourceIndicator.BY_IDS = type(
    "NonFungibleResourceIndicator.BY_IDS",
    (
        NonFungibleResourceIndicator.BY_IDS,
        NonFungibleResourceIndicator,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeNonFungibleResourceIndicator(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NonFungibleResourceIndicator.BY_ALL(
                _UniffiConverterTypePredictedDecimal.read(buf),
                _UniffiConverterTypePredictedNonFungibleIds.read(buf),
            )
        if variant == 2:
            return NonFungibleResourceIndicator.BY_AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
                _UniffiConverterTypePredictedNonFungibleIds.read(buf),
            )
        if variant == 3:
            return NonFungibleResourceIndicator.BY_IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_by_all():
            buf.write_i32(1)
            _UniffiConverterTypePredictedDecimal.write(value.predicted_amount, buf)
            _UniffiConverterTypePredictedNonFungibleIds.write(value.predicted_ids, buf)
        if value.is_by_amount():
            buf.write_i32(2)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
            _UniffiConverterTypePredictedNonFungibleIds.write(value.predicted_ids, buf)
        if value.is_by_ids():
            buf.write_i32(3)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class OlympiaNetwork(enum.Enum):
    MAINNET = 1
    STOKENET = 2
    RELEASENET = 3
    RC_NET = 4
    MILESTONENET = 5
    DEVOPSNET = 6
    SANDPITNET = 7
    LOCALNET = 8


class _UniffiConverterTypeOlympiaNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OlympiaNetwork.MAINNET
        if variant == 2:
            return OlympiaNetwork.STOKENET
        if variant == 3:
            return OlympiaNetwork.RELEASENET
        if variant == 4:
            return OlympiaNetwork.RC_NET
        if variant == 5:
            return OlympiaNetwork.MILESTONENET
        if variant == 6:
            return OlympiaNetwork.DEVOPSNET
        if variant == 7:
            return OlympiaNetwork.SANDPITNET
        if variant == 8:
            return OlympiaNetwork.LOCALNET
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == OlympiaNetwork.MAINNET:
            buf.write_i32(1)
        if value == OlympiaNetwork.STOKENET:
            buf.write_i32(2)
        if value == OlympiaNetwork.RELEASENET:
            buf.write_i32(3)
        if value == OlympiaNetwork.RC_NET:
            buf.write_i32(4)
        if value == OlympiaNetwork.MILESTONENET:
            buf.write_i32(5)
        if value == OlympiaNetwork.DEVOPSNET:
            buf.write_i32(6)
        if value == OlympiaNetwork.SANDPITNET:
            buf.write_i32(7)
        if value == OlympiaNetwork.LOCALNET:
            buf.write_i32(8)


class Operation(enum.Enum):
    ADD = 1
    REMOVE = 2


class _UniffiConverterTypeOperation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Operation.ADD
        if variant == 2:
            return Operation.REMOVE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Operation.ADD:
            buf.write_i32(1)
        if value == Operation.REMOVE:
            buf.write_i32(2)


class OwnerRole:
    def __init__(self):
        raise RuntimeError("OwnerRole cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NONE:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "OwnerRole.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True

    class FIXED:
        value: "AccessRule"

        @typing.no_type_check
        def __init__(self, value: "AccessRule"):

            self.value = value

        def __str__(self):
            return "OwnerRole.FIXED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_fixed():
                return False
            if self.value != other.value:
                return False
            return True

    class UPDATABLE:
        value: "AccessRule"

        @typing.no_type_check
        def __init__(self, value: "AccessRule"):

            self.value = value

        def __str__(self):
            return "OwnerRole.UPDATABLE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_updatable():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_none(self) -> bool:
        return isinstance(self, OwnerRole.NONE)

    def is_fixed(self) -> bool:
        return isinstance(self, OwnerRole.FIXED)

    def is_updatable(self) -> bool:
        return isinstance(self, OwnerRole.UPDATABLE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
OwnerRole.NONE = type(
    "OwnerRole.NONE",
    (
        OwnerRole.NONE,
        OwnerRole,
    ),
    {},
)  # type: ignore
OwnerRole.FIXED = type(
    "OwnerRole.FIXED",
    (
        OwnerRole.FIXED,
        OwnerRole,
    ),
    {},
)  # type: ignore
OwnerRole.UPDATABLE = type(
    "OwnerRole.UPDATABLE",
    (
        OwnerRole.UPDATABLE,
        OwnerRole,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeOwnerRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OwnerRole.NONE()
        if variant == 2:
            return OwnerRole.FIXED(
                _UniffiConverterTypeAccessRule.read(buf),
            )
        if variant == 3:
            return OwnerRole.UPDATABLE(
                _UniffiConverterTypeAccessRule.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_none():
            buf.write_i32(1)
        if value.is_fixed():
            buf.write_i32(2)
            _UniffiConverterTypeAccessRule.write(value.value, buf)
        if value.is_updatable():
            buf.write_i32(3)
            _UniffiConverterTypeAccessRule.write(value.value, buf)


class Proposer(enum.Enum):
    PRIMARY = 1
    RECOVERY = 2


class _UniffiConverterTypeProposer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Proposer.PRIMARY
        if variant == 2:
            return Proposer.RECOVERY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Proposer.PRIMARY:
            buf.write_i32(1)
        if value == Proposer.RECOVERY:
            buf.write_i32(2)


class PublicKey:
    def __init__(self):
        raise RuntimeError("PublicKey cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "PublicKey.SECP256K1(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.value != other.value:
                return False
            return True

    class ED25519:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "PublicKey.ED25519(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, PublicKey.SECP256K1)

    def is_ed25519(self) -> bool:
        return isinstance(self, PublicKey.ED25519)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PublicKey.SECP256K1 = type(
    "PublicKey.SECP256K1",
    (
        PublicKey.SECP256K1,
        PublicKey,
    ),
    {},
)  # type: ignore
PublicKey.ED25519 = type(
    "PublicKey.ED25519",
    (
        PublicKey.ED25519,
        PublicKey,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypePublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PublicKey.SECP256K1(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return PublicKey.ED25519(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.value, buf)


class PublicKeyHash:
    def __init__(self):
        raise RuntimeError("PublicKeyHash cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "PublicKeyHash.SECP256K1(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.value != other.value:
                return False
            return True

    class ED25519:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "PublicKeyHash.ED25519(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, PublicKeyHash.SECP256K1)

    def is_ed25519(self) -> bool:
        return isinstance(self, PublicKeyHash.ED25519)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PublicKeyHash.SECP256K1 = type(
    "PublicKeyHash.SECP256K1",
    (
        PublicKeyHash.SECP256K1,
        PublicKeyHash,
    ),
    {},
)  # type: ignore
PublicKeyHash.ED25519 = type(
    "PublicKeyHash.ED25519",
    (
        PublicKeyHash.ED25519,
        PublicKeyHash,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypePublicKeyHash(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PublicKeyHash.SECP256K1(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return PublicKeyHash.ED25519(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.value, buf)


# RadixEngineToolkitError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RadixEngineToolkitError(Exception):
    pass


_UniffiTempRadixEngineToolkitError = RadixEngineToolkitError


class RadixEngineToolkitError:  # type: ignore
    class InvalidLength(_UniffiTempRadixEngineToolkitError):
        def __init__(self, expected, actual, data):
            super().__init__(
                ", ".join(
                    [
                        "expected={!r}".format(expected),
                        "actual={!r}".format(actual),
                        "data={!r}".format(data),
                    ]
                )
            )
            self.expected = expected
            self.actual = actual
            self.data = data

        def __repr__(self):
            return "RadixEngineToolkitError.InvalidLength({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.InvalidLength = InvalidLength  # type: ignore

    class FailedToExtractNetwork(_UniffiTempRadixEngineToolkitError):
        def __init__(self, address):
            super().__init__(
                ", ".join(
                    [
                        "address={!r}".format(address),
                    ]
                )
            )
            self.address = address

        def __repr__(self):
            return "RadixEngineToolkitError.FailedToExtractNetwork({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.FailedToExtractNetwork = FailedToExtractNetwork  # type: ignore

    class Bech32DecodeError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.Bech32DecodeError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.Bech32DecodeError = Bech32DecodeError  # type: ignore

    class ParseError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, type_name, error):
            super().__init__(
                ", ".join(
                    [
                        "type_name={!r}".format(type_name),
                        "error={!r}".format(error),
                    ]
                )
            )
            self.type_name = type_name
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.ParseError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.ParseError = ParseError  # type: ignore

    class NonFungibleContentValidationError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return (
                "RadixEngineToolkitError.NonFungibleContentValidationError({})".format(
                    str(self)
                )
            )

    _UniffiTempRadixEngineToolkitError.NonFungibleContentValidationError = NonFungibleContentValidationError  # type: ignore

    class EntityTypeMismatchError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, expected, actual):
            super().__init__(
                ", ".join(
                    [
                        "expected={!r}".format(expected),
                        "actual={!r}".format(actual),
                    ]
                )
            )
            self.expected = expected
            self.actual = actual

        def __repr__(self):
            return "RadixEngineToolkitError.EntityTypeMismatchError({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.EntityTypeMismatchError = EntityTypeMismatchError  # type: ignore

    class DerivationError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.DerivationError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.DerivationError = DerivationError  # type: ignore

    class InvalidPublicKey(_UniffiTempRadixEngineToolkitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RadixEngineToolkitError.InvalidPublicKey({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.InvalidPublicKey = InvalidPublicKey  # type: ignore

    class CompileError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.CompileError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.CompileError = CompileError  # type: ignore

    class DecompileError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.DecompileError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.DecompileError = DecompileError  # type: ignore

    class PrepareError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.PrepareError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.PrepareError = PrepareError  # type: ignore

    class EncodeError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.EncodeError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.EncodeError = EncodeError  # type: ignore

    class DecodeError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.DecodeError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.DecodeError = DecodeError  # type: ignore

    class TransactionValidationFailed(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.TransactionValidationFailed({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.TransactionValidationFailed = TransactionValidationFailed  # type: ignore

    class ExecutionModuleError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.ExecutionModuleError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.ExecutionModuleError = ExecutionModuleError  # type: ignore

    class ManifestSborError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.ManifestSborError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.ManifestSborError = ManifestSborError  # type: ignore

    class ScryptoSborError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.ScryptoSborError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.ScryptoSborError = ScryptoSborError  # type: ignore

    class TypedNativeEventError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.TypedNativeEventError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.TypedNativeEventError = TypedNativeEventError  # type: ignore

    class FailedToDecodeTransactionHash(_UniffiTempRadixEngineToolkitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RadixEngineToolkitError.FailedToDecodeTransactionHash({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.FailedToDecodeTransactionHash = FailedToDecodeTransactionHash  # type: ignore

    class ManifestBuilderNameRecordError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.ManifestBuilderNameRecordError({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.ManifestBuilderNameRecordError = ManifestBuilderNameRecordError  # type: ignore

    class ManifestModificationError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.ManifestModificationError({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.ManifestModificationError = ManifestModificationError  # type: ignore

    class InvalidEntityTypeIdError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.InvalidEntityTypeIdError({})".format(
                str(self)
            )

    _UniffiTempRadixEngineToolkitError.InvalidEntityTypeIdError = InvalidEntityTypeIdError  # type: ignore

    class DecimalError(_UniffiTempRadixEngineToolkitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RadixEngineToolkitError.DecimalError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.DecimalError = DecimalError  # type: ignore

    class SignerError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(
                ", ".join(
                    [
                        "error={!r}".format(error),
                    ]
                )
            )
            self.error = error

        def __repr__(self):
            return "RadixEngineToolkitError.SignerError({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.SignerError = SignerError  # type: ignore

    class InvalidReceipt(_UniffiTempRadixEngineToolkitError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RadixEngineToolkitError.InvalidReceipt({})".format(str(self))

    _UniffiTempRadixEngineToolkitError.InvalidReceipt = InvalidReceipt  # type: ignore


RadixEngineToolkitError = _UniffiTempRadixEngineToolkitError  # type: ignore
del _UniffiTempRadixEngineToolkitError


class _UniffiConverterTypeRadixEngineToolkitError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RadixEngineToolkitError.InvalidLength(
                expected=_UniffiConverterUInt64.read(buf),
                actual=_UniffiConverterUInt64.read(buf),
                data=_UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return RadixEngineToolkitError.FailedToExtractNetwork(
                address=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RadixEngineToolkitError.Bech32DecodeError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return RadixEngineToolkitError.ParseError(
                type_name=_UniffiConverterString.read(buf),
                error=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return RadixEngineToolkitError.NonFungibleContentValidationError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 6:
            return RadixEngineToolkitError.EntityTypeMismatchError(
                expected=_UniffiConverterSequenceTypeEntityType.read(buf),
                actual=_UniffiConverterTypeEntityType.read(buf),
            )
        if variant == 7:
            return RadixEngineToolkitError.DerivationError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return RadixEngineToolkitError.InvalidPublicKey()
        if variant == 9:
            return RadixEngineToolkitError.CompileError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return RadixEngineToolkitError.DecompileError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 11:
            return RadixEngineToolkitError.PrepareError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 12:
            return RadixEngineToolkitError.EncodeError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 13:
            return RadixEngineToolkitError.DecodeError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 14:
            return RadixEngineToolkitError.TransactionValidationFailed(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 15:
            return RadixEngineToolkitError.ExecutionModuleError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 16:
            return RadixEngineToolkitError.ManifestSborError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 17:
            return RadixEngineToolkitError.ScryptoSborError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 18:
            return RadixEngineToolkitError.TypedNativeEventError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 19:
            return RadixEngineToolkitError.FailedToDecodeTransactionHash()
        if variant == 20:
            return RadixEngineToolkitError.ManifestBuilderNameRecordError(
                error=_UniffiConverterTypeNameRecordError.read(buf),
            )
        if variant == 21:
            return RadixEngineToolkitError.ManifestModificationError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 22:
            return RadixEngineToolkitError.InvalidEntityTypeIdError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 23:
            return RadixEngineToolkitError.DecimalError()
        if variant == 24:
            return RadixEngineToolkitError.SignerError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 25:
            return RadixEngineToolkitError.InvalidReceipt()
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, RadixEngineToolkitError.InvalidLength):
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.expected, buf)
            _UniffiConverterUInt64.write(value.actual, buf)
            _UniffiConverterBytes.write(value.data, buf)
        if isinstance(value, RadixEngineToolkitError.FailedToExtractNetwork):
            buf.write_i32(2)
            _UniffiConverterString.write(value.address, buf)
        if isinstance(value, RadixEngineToolkitError.Bech32DecodeError):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ParseError):
            buf.write_i32(4)
            _UniffiConverterString.write(value.type_name, buf)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.NonFungibleContentValidationError):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.EntityTypeMismatchError):
            buf.write_i32(6)
            _UniffiConverterSequenceTypeEntityType.write(value.expected, buf)
            _UniffiConverterTypeEntityType.write(value.actual, buf)
        if isinstance(value, RadixEngineToolkitError.DerivationError):
            buf.write_i32(7)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.InvalidPublicKey):
            buf.write_i32(8)
        if isinstance(value, RadixEngineToolkitError.CompileError):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.DecompileError):
            buf.write_i32(10)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.PrepareError):
            buf.write_i32(11)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.EncodeError):
            buf.write_i32(12)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.DecodeError):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.TransactionValidationFailed):
            buf.write_i32(14)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ExecutionModuleError):
            buf.write_i32(15)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ManifestSborError):
            buf.write_i32(16)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ScryptoSborError):
            buf.write_i32(17)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.TypedNativeEventError):
            buf.write_i32(18)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.FailedToDecodeTransactionHash):
            buf.write_i32(19)
        if isinstance(value, RadixEngineToolkitError.ManifestBuilderNameRecordError):
            buf.write_i32(20)
            _UniffiConverterTypeNameRecordError.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ManifestModificationError):
            buf.write_i32(21)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.InvalidEntityTypeIdError):
            buf.write_i32(22)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.DecimalError):
            buf.write_i32(23)
        if isinstance(value, RadixEngineToolkitError.SignerError):
            buf.write_i32(24)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.InvalidReceipt):
            buf.write_i32(25)


class RecallResourceEvent:
    def __init__(self):
        raise RuntimeError("RecallResourceEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "RecallResourceEvent.AMOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.value != other.value:
                return False
            return True

    class IDS:
        value: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[NonFungibleLocalId]"):

            self.value = value

        def __str__(self):
            return "RecallResourceEvent.IDS(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, RecallResourceEvent.AMOUNT)

    def is_ids(self) -> bool:
        return isinstance(self, RecallResourceEvent.IDS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RecallResourceEvent.AMOUNT = type(
    "RecallResourceEvent.AMOUNT",
    (
        RecallResourceEvent.AMOUNT,
        RecallResourceEvent,
    ),
    {},
)  # type: ignore
RecallResourceEvent.IDS = type(
    "RecallResourceEvent.IDS",
    (
        RecallResourceEvent.IDS,
        RecallResourceEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeRecallResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RecallResourceEvent.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return RecallResourceEvent.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)


class ReservedInstruction(enum.Enum):
    ACCOUNT_LOCK_FEE = 1
    ACCOUNT_SECURIFY = 2
    IDENTITY_SECURIFY = 3
    ACCESS_CONTROLLER_METHOD = 4


class _UniffiConverterTypeReservedInstruction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReservedInstruction.ACCOUNT_LOCK_FEE
        if variant == 2:
            return ReservedInstruction.ACCOUNT_SECURIFY
        if variant == 3:
            return ReservedInstruction.IDENTITY_SECURIFY
        if variant == 4:
            return ReservedInstruction.ACCESS_CONTROLLER_METHOD
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ReservedInstruction.ACCOUNT_LOCK_FEE:
            buf.write_i32(1)
        if value == ReservedInstruction.ACCOUNT_SECURIFY:
            buf.write_i32(2)
        if value == ReservedInstruction.IDENTITY_SECURIFY:
            buf.write_i32(3)
        if value == ReservedInstruction.ACCESS_CONTROLLER_METHOD:
            buf.write_i32(4)


class ResourceIndicator:
    def __init__(self):
        raise RuntimeError("ResourceIndicator cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE:
        resource_address: "Address"
        indicator: "FungibleResourceIndicator"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", indicator: "FungibleResourceIndicator"
        ):

            self.resource_address = resource_address
            self.indicator = indicator

        def __str__(self):
            return (
                "ResourceIndicator.FUNGIBLE(resource_address={}, indicator={})".format(
                    self.resource_address, self.indicator
                )
            )

        def __eq__(self, other):
            if not other.is_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.indicator != other.indicator:
                return False
            return True

    class NON_FUNGIBLE:
        resource_address: "Address"
        indicator: "NonFungibleResourceIndicator"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", indicator: "NonFungibleResourceIndicator"
        ):

            self.resource_address = resource_address
            self.indicator = indicator

        def __str__(self):
            return "ResourceIndicator.NON_FUNGIBLE(resource_address={}, indicator={})".format(
                self.resource_address, self.indicator
            )

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.indicator != other.indicator:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible(self) -> bool:
        return isinstance(self, ResourceIndicator.FUNGIBLE)

    def is_non_fungible(self) -> bool:
        return isinstance(self, ResourceIndicator.NON_FUNGIBLE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourceIndicator.FUNGIBLE = type(
    "ResourceIndicator.FUNGIBLE",
    (
        ResourceIndicator.FUNGIBLE,
        ResourceIndicator,
    ),
    {},
)  # type: ignore
ResourceIndicator.NON_FUNGIBLE = type(
    "ResourceIndicator.NON_FUNGIBLE",
    (
        ResourceIndicator.NON_FUNGIBLE,
        ResourceIndicator,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeResourceIndicator(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourceIndicator.FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeFungibleResourceIndicator.read(buf),
            )
        if variant == 2:
            return ResourceIndicator.NON_FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeNonFungibleResourceIndicator.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeFungibleResourceIndicator.write(value.indicator, buf)
        if value.is_non_fungible():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeNonFungibleResourceIndicator.write(value.indicator, buf)


class ResourceOrNonFungible:
    def __init__(self):
        raise RuntimeError("ResourceOrNonFungible cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NON_FUNGIBLE:
        value: "NonFungibleGlobalId"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleGlobalId"):

            self.value = value

        def __str__(self):
            return "ResourceOrNonFungible.NON_FUNGIBLE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.value != other.value:
                return False
            return True

    class RESOURCE:
        value: "Address"

        @typing.no_type_check
        def __init__(self, value: "Address"):

            self.value = value

        def __str__(self):
            return "ResourceOrNonFungible.RESOURCE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_resource():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_non_fungible(self) -> bool:
        return isinstance(self, ResourceOrNonFungible.NON_FUNGIBLE)

    def is_resource(self) -> bool:
        return isinstance(self, ResourceOrNonFungible.RESOURCE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourceOrNonFungible.NON_FUNGIBLE = type(
    "ResourceOrNonFungible.NON_FUNGIBLE",
    (
        ResourceOrNonFungible.NON_FUNGIBLE,
        ResourceOrNonFungible,
    ),
    {},
)  # type: ignore
ResourceOrNonFungible.RESOURCE = type(
    "ResourceOrNonFungible.RESOURCE",
    (
        ResourceOrNonFungible.RESOURCE,
        ResourceOrNonFungible,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeResourceOrNonFungible(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourceOrNonFungible.NON_FUNGIBLE(
                _UniffiConverterTypeNonFungibleGlobalId.read(buf),
            )
        if variant == 2:
            return ResourceOrNonFungible.RESOURCE(
                _UniffiConverterTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_non_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeNonFungibleGlobalId.write(value.value, buf)
        if value.is_resource():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.value, buf)


class ResourcePreference(enum.Enum):
    ALLOWED = 1
    DISALLOWED = 2


class _UniffiConverterTypeResourcePreference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourcePreference.ALLOWED
        if variant == 2:
            return ResourcePreference.DISALLOWED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ResourcePreference.ALLOWED:
            buf.write_i32(1)
        if value == ResourcePreference.DISALLOWED:
            buf.write_i32(2)


class ResourcePreferenceUpdate:
    def __init__(self):
        raise RuntimeError("ResourcePreferenceUpdate cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SET:
        value: "ResourcePreference"

        @typing.no_type_check
        def __init__(self, value: "ResourcePreference"):

            self.value = value

        def __str__(self):
            return "ResourcePreferenceUpdate.SET(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set():
                return False
            if self.value != other.value:
                return False
            return True

    class REMOVE:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "ResourcePreferenceUpdate.REMOVE()".format()

        def __eq__(self, other):
            if not other.is_remove():
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_set(self) -> bool:
        return isinstance(self, ResourcePreferenceUpdate.SET)

    def is_remove(self) -> bool:
        return isinstance(self, ResourcePreferenceUpdate.REMOVE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourcePreferenceUpdate.SET = type(
    "ResourcePreferenceUpdate.SET",
    (
        ResourcePreferenceUpdate.SET,
        ResourcePreferenceUpdate,
    ),
    {},
)  # type: ignore
ResourcePreferenceUpdate.REMOVE = type(
    "ResourcePreferenceUpdate.REMOVE",
    (
        ResourcePreferenceUpdate.REMOVE,
        ResourcePreferenceUpdate,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeResourcePreferenceUpdate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourcePreferenceUpdate.SET(
                _UniffiConverterTypeResourcePreference.read(buf),
            )
        if variant == 2:
            return ResourcePreferenceUpdate.REMOVE()
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_set():
            buf.write_i32(1)
            _UniffiConverterTypeResourcePreference.write(value.value, buf)
        if value.is_remove():
            buf.write_i32(2)


class ResourceSpecifier:
    def __init__(self):
        raise RuntimeError("ResourceSpecifier cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        resource_address: "Address"
        amount: "Decimal"

        @typing.no_type_check
        def __init__(self, resource_address: "Address", amount: "Decimal"):

            self.resource_address = resource_address
            self.amount = amount

        def __str__(self):
            return "ResourceSpecifier.AMOUNT(resource_address={}, amount={})".format(
                self.resource_address, self.amount
            )

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True

    class IDS:
        resource_address: "Address"
        ids: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(
            self, resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"
        ):

            self.resource_address = resource_address
            self.ids = ids

        def __str__(self):
            return "ResourceSpecifier.IDS(resource_address={}, ids={})".format(
                self.resource_address, self.ids
            )

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, ResourceSpecifier.AMOUNT)

    def is_ids(self) -> bool:
        return isinstance(self, ResourceSpecifier.IDS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourceSpecifier.AMOUNT = type(
    "ResourceSpecifier.AMOUNT",
    (
        ResourceSpecifier.AMOUNT,
        ResourceSpecifier,
    ),
    {},
)  # type: ignore
ResourceSpecifier.IDS = type(
    "ResourceSpecifier.IDS",
    (
        ResourceSpecifier.IDS,
        ResourceSpecifier,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeResourceSpecifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourceSpecifier.AMOUNT(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return ResourceSpecifier.IDS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class Role(enum.Enum):
    PRIMARY = 1
    RECOVERY = 2
    CONFIRMATION = 3


class _UniffiConverterTypeRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Role.PRIMARY
        if variant == 2:
            return Role.RECOVERY
        if variant == 3:
            return Role.CONFIRMATION
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Role.PRIMARY:
            buf.write_i32(1)
        if value == Role.RECOVERY:
            buf.write_i32(2)
        if value == Role.CONFIRMATION:
            buf.write_i32(3)


class RoundingMode(enum.Enum):
    TO_POSITIVE_INFINITY = 1
    TO_NEGATIVE_INFINITY = 2
    TO_ZERO = 3
    AWAY_FROM_ZERO = 4
    TO_NEAREST_MIDPOINT_TOWARD_ZERO = 5
    TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO = 6
    TO_NEAREST_MIDPOINT_TO_EVEN = 7


class _UniffiConverterTypeRoundingMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RoundingMode.TO_POSITIVE_INFINITY
        if variant == 2:
            return RoundingMode.TO_NEGATIVE_INFINITY
        if variant == 3:
            return RoundingMode.TO_ZERO
        if variant == 4:
            return RoundingMode.AWAY_FROM_ZERO
        if variant == 5:
            return RoundingMode.TO_NEAREST_MIDPOINT_TOWARD_ZERO
        if variant == 6:
            return RoundingMode.TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO
        if variant == 7:
            return RoundingMode.TO_NEAREST_MIDPOINT_TO_EVEN
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == RoundingMode.TO_POSITIVE_INFINITY:
            buf.write_i32(1)
        if value == RoundingMode.TO_NEGATIVE_INFINITY:
            buf.write_i32(2)
        if value == RoundingMode.TO_ZERO:
            buf.write_i32(3)
        if value == RoundingMode.AWAY_FROM_ZERO:
            buf.write_i32(4)
        if value == RoundingMode.TO_NEAREST_MIDPOINT_TOWARD_ZERO:
            buf.write_i32(5)
        if value == RoundingMode.TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO:
            buf.write_i32(6)
        if value == RoundingMode.TO_NEAREST_MIDPOINT_TO_EVEN:
            buf.write_i32(7)


class RoyaltyAmount:
    def __init__(self):
        raise RuntimeError("RoyaltyAmount cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FREE:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "RoyaltyAmount.FREE()".format()

        def __eq__(self, other):
            if not other.is_free():
                return False
            return True

    class XRD:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "RoyaltyAmount.XRD(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_xrd():
                return False
            if self.value != other.value:
                return False
            return True

    class USD:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "RoyaltyAmount.USD(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_usd():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_free(self) -> bool:
        return isinstance(self, RoyaltyAmount.FREE)

    def is_xrd(self) -> bool:
        return isinstance(self, RoyaltyAmount.XRD)

    def is_usd(self) -> bool:
        return isinstance(self, RoyaltyAmount.USD)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RoyaltyAmount.FREE = type(
    "RoyaltyAmount.FREE",
    (
        RoyaltyAmount.FREE,
        RoyaltyAmount,
    ),
    {},
)  # type: ignore
RoyaltyAmount.XRD = type(
    "RoyaltyAmount.XRD",
    (
        RoyaltyAmount.XRD,
        RoyaltyAmount,
    ),
    {},
)  # type: ignore
RoyaltyAmount.USD = type(
    "RoyaltyAmount.USD",
    (
        RoyaltyAmount.USD,
        RoyaltyAmount,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeRoyaltyAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RoyaltyAmount.FREE()
        if variant == 2:
            return RoyaltyAmount.XRD(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 3:
            return RoyaltyAmount.USD(
                _UniffiConverterTypeDecimal.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_free():
            buf.write_i32(1)
        if value.is_xrd():
            buf.write_i32(2)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_usd():
            buf.write_i32(3)
            _UniffiConverterTypeDecimal.write(value.value, buf)


class ScryptoSborString:
    def __init__(self):
        raise RuntimeError("ScryptoSborString cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PROGRAMMATIC_JSON:
        value: "str"

        @typing.no_type_check
        def __init__(self, value: "str"):

            self.value = value

        def __str__(self):
            return "ScryptoSborString.PROGRAMMATIC_JSON(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_programmatic_json():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_programmatic_json(self) -> bool:
        return isinstance(self, ScryptoSborString.PROGRAMMATIC_JSON)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ScryptoSborString.PROGRAMMATIC_JSON = type(
    "ScryptoSborString.PROGRAMMATIC_JSON",
    (
        ScryptoSborString.PROGRAMMATIC_JSON,
        ScryptoSborString,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeScryptoSborString(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ScryptoSborString.PROGRAMMATIC_JSON(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_programmatic_json():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)


class SerializationMode(enum.Enum):
    PROGRAMMATIC = 1
    NATURAL = 2


class _UniffiConverterTypeSerializationMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SerializationMode.PROGRAMMATIC
        if variant == 2:
            return SerializationMode.NATURAL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SerializationMode.PROGRAMMATIC:
            buf.write_i32(1)
        if value == SerializationMode.NATURAL:
            buf.write_i32(2)


class Signature:
    def __init__(self):
        raise RuntimeError("Signature cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "Signature.SECP256K1(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.value != other.value:
                return False
            return True

    class ED25519:
        value: "bytes"

        @typing.no_type_check
        def __init__(self, value: "bytes"):

            self.value = value

        def __str__(self):
            return "Signature.ED25519(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, Signature.SECP256K1)

    def is_ed25519(self) -> bool:
        return isinstance(self, Signature.ED25519)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Signature.SECP256K1 = type(
    "Signature.SECP256K1",
    (
        Signature.SECP256K1,
        Signature,
    ),
    {},
)  # type: ignore
Signature.ED25519 = type(
    "Signature.ED25519",
    (
        Signature.ED25519,
        Signature,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeSignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Signature.SECP256K1(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return Signature.ED25519(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.value, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.value, buf)


class SignatureWithPublicKey:
    def __init__(self):
        raise RuntimeError("SignatureWithPublicKey cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        signature: "bytes"

        @typing.no_type_check
        def __init__(self, signature: "bytes"):

            self.signature = signature

        def __str__(self):
            return "SignatureWithPublicKey.SECP256K1(signature={})".format(
                self.signature
            )

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.signature != other.signature:
                return False
            return True

    class ED25519:
        signature: "bytes"
        public_key: "bytes"

        @typing.no_type_check
        def __init__(self, signature: "bytes", public_key: "bytes"):

            self.signature = signature
            self.public_key = public_key

        def __str__(self):
            return "SignatureWithPublicKey.ED25519(signature={}, public_key={})".format(
                self.signature, self.public_key
            )

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.signature != other.signature:
                return False
            if self.public_key != other.public_key:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, SignatureWithPublicKey.SECP256K1)

    def is_ed25519(self) -> bool:
        return isinstance(self, SignatureWithPublicKey.ED25519)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SignatureWithPublicKey.SECP256K1 = type(
    "SignatureWithPublicKey.SECP256K1",
    (
        SignatureWithPublicKey.SECP256K1,
        SignatureWithPublicKey,
    ),
    {},
)  # type: ignore
SignatureWithPublicKey.ED25519 = type(
    "SignatureWithPublicKey.ED25519",
    (
        SignatureWithPublicKey.ED25519,
        SignatureWithPublicKey,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeSignatureWithPublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignatureWithPublicKey.SECP256K1(
                _UniffiConverterBytes.read(buf),
            )
        if variant == 2:
            return SignatureWithPublicKey.ED25519(
                _UniffiConverterBytes.read(buf),
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.signature, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.signature, buf)
            _UniffiConverterBytes.write(value.public_key, buf)


class TypedAccessControllerBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedAccessControllerBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class INITIATE_RECOVERY_EVENT_VALUE:
        value: "InitiateRecoveryEvent"

        @typing.no_type_check
        def __init__(self, value: "InitiateRecoveryEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_initiate_recovery_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE:
        value: "InitiateBadgeWithdrawAttemptEvent"

        @typing.no_type_check
        def __init__(self, value: "InitiateBadgeWithdrawAttemptEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_initiate_badge_withdraw_attempt_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class RULE_SET_UPDATE_EVENT_VALUE:
        value: "RuleSetUpdateEvent"

        @typing.no_type_check
        def __init__(self, value: "RuleSetUpdateEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_rule_set_update_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BADGE_WITHDRAW_EVENT_VALUE:
        value: "BadgeWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "BadgeWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_badge_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE:
        value: "CancelRecoveryProposalEvent"

        @typing.no_type_check
        def __init__(self, value: "CancelRecoveryProposalEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_cancel_recovery_proposal_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE:
        value: "CancelBadgeWithdrawAttemptEvent"

        @typing.no_type_check
        def __init__(self, value: "CancelBadgeWithdrawAttemptEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_cancel_badge_withdraw_attempt_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class LOCK_PRIMARY_ROLE_EVENT_VALUE:
        value: "LockPrimaryRoleEvent"

        @typing.no_type_check
        def __init__(self, value: "LockPrimaryRoleEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_lock_primary_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class UNLOCK_PRIMARY_ROLE_EVENT_VALUE:
        value: "UnlockPrimaryRoleEvent"

        @typing.no_type_check
        def __init__(self, value: "UnlockPrimaryRoleEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_unlock_primary_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class STOP_TIMED_RECOVERY_EVENT_VALUE:
        value: "StopTimedRecoveryEvent"

        @typing.no_type_check
        def __init__(self, value: "StopTimedRecoveryEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_stop_timed_recovery_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class DEPOSIT_RECOVERY_XRD_EVENT_VALUE:
        value: "DepositRecoveryXrdEvent"

        @typing.no_type_check
        def __init__(self, value: "DepositRecoveryXrdEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.DEPOSIT_RECOVERY_XRD_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_deposit_recovery_xrd_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class WITHDRAW_RECOVERY_XRD_EVENT_VALUE:
        value: "WithdrawRecoveryXrdEvent"

        @typing.no_type_check
        def __init__(self, value: "WithdrawRecoveryXrdEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.WITHDRAW_RECOVERY_XRD_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_withdraw_recovery_xrd_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_initiate_recovery_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE
        )

    def is_initiate_badge_withdraw_attempt_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE,
        )

    def is_rule_set_update_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE
        )

    def is_badge_withdraw_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE
        )

    def is_cancel_recovery_proposal_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE,
        )

    def is_cancel_badge_withdraw_attempt_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE,
        )

    def is_lock_primary_role_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE
        )

    def is_unlock_primary_role_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE
        )

    def is_stop_timed_recovery_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE
        )

    def is_deposit_recovery_xrd_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.DEPOSIT_RECOVERY_XRD_EVENT_VALUE
        )

    def is_withdraw_recovery_xrd_event_value(self) -> bool:
        return isinstance(
            self, TypedAccessControllerBlueprintEvent.WITHDRAW_RECOVERY_XRD_EVENT_VALUE
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.DEPOSIT_RECOVERY_XRD_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.DEPOSIT_RECOVERY_XRD_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.DEPOSIT_RECOVERY_XRD_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccessControllerBlueprintEvent.WITHDRAW_RECOVERY_XRD_EVENT_VALUE = type(
    "TypedAccessControllerBlueprintEvent.WITHDRAW_RECOVERY_XRD_EVENT_VALUE",
    (
        TypedAccessControllerBlueprintEvent.WITHDRAW_RECOVERY_XRD_EVENT_VALUE,
        TypedAccessControllerBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedAccessControllerBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE(
                _UniffiConverterTypeInitiateRecoveryEvent.read(buf),
            )
        if variant == 2:
            return TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(
                _UniffiConverterTypeInitiateBadgeWithdrawAttemptEvent.read(buf),
            )
        if variant == 3:
            return TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE(
                _UniffiConverterTypeRuleSetUpdateEvent.read(buf),
            )
        if variant == 4:
            return TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeBadgeWithdrawEvent.read(buf),
            )
        if variant == 5:
            return TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE(
                _UniffiConverterTypeCancelRecoveryProposalEvent.read(buf),
            )
        if variant == 6:
            return TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(
                _UniffiConverterTypeCancelBadgeWithdrawAttemptEvent.read(buf),
            )
        if variant == 7:
            return TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE(
                _UniffiConverterTypeLockPrimaryRoleEvent.read(buf),
            )
        if variant == 8:
            return TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE(
                _UniffiConverterTypeUnlockPrimaryRoleEvent.read(buf),
            )
        if variant == 9:
            return TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE(
                _UniffiConverterTypeStopTimedRecoveryEvent.read(buf),
            )
        if variant == 10:
            return TypedAccessControllerBlueprintEvent.DEPOSIT_RECOVERY_XRD_EVENT_VALUE(
                _UniffiConverterTypeDepositRecoveryXrdEvent.read(buf),
            )
        if variant == 11:
            return (
                TypedAccessControllerBlueprintEvent.WITHDRAW_RECOVERY_XRD_EVENT_VALUE(
                    _UniffiConverterTypeWithdrawRecoveryXrdEvent.read(buf),
                )
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_initiate_recovery_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeInitiateRecoveryEvent.write(value.value, buf)
        if value.is_initiate_badge_withdraw_attempt_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeInitiateBadgeWithdrawAttemptEvent.write(
                value.value, buf
            )
        if value.is_rule_set_update_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeRuleSetUpdateEvent.write(value.value, buf)
        if value.is_badge_withdraw_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeBadgeWithdrawEvent.write(value.value, buf)
        if value.is_cancel_recovery_proposal_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeCancelRecoveryProposalEvent.write(value.value, buf)
        if value.is_cancel_badge_withdraw_attempt_event_value():
            buf.write_i32(6)
            _UniffiConverterTypeCancelBadgeWithdrawAttemptEvent.write(value.value, buf)
        if value.is_lock_primary_role_event_value():
            buf.write_i32(7)
            _UniffiConverterTypeLockPrimaryRoleEvent.write(value.value, buf)
        if value.is_unlock_primary_role_event_value():
            buf.write_i32(8)
            _UniffiConverterTypeUnlockPrimaryRoleEvent.write(value.value, buf)
        if value.is_stop_timed_recovery_event_value():
            buf.write_i32(9)
            _UniffiConverterTypeStopTimedRecoveryEvent.write(value.value, buf)
        if value.is_deposit_recovery_xrd_event_value():
            buf.write_i32(10)
            _UniffiConverterTypeDepositRecoveryXrdEvent.write(value.value, buf)
        if value.is_withdraw_recovery_xrd_event_value():
            buf.write_i32(11)
            _UniffiConverterTypeWithdrawRecoveryXrdEvent.write(value.value, buf)


class TypedAccessControllerPackageEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedAccessControllerPackageEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class ACCESS_CONTROLLER:
        value: "TypedAccessControllerBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedAccessControllerBlueprintEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedAccessControllerPackageEvent.ACCESS_CONTROLLER(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_access_controller():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_access_controller(self) -> bool:
        return isinstance(self, TypedAccessControllerPackageEvent.ACCESS_CONTROLLER)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccessControllerPackageEvent.ACCESS_CONTROLLER = type(
    "TypedAccessControllerPackageEvent.ACCESS_CONTROLLER",
    (
        TypedAccessControllerPackageEvent.ACCESS_CONTROLLER,
        TypedAccessControllerPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedAccessControllerPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccessControllerPackageEvent.ACCESS_CONTROLLER(
                _UniffiConverterTypeTypedAccessControllerBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_access_controller():
            buf.write_i32(1)
            _UniffiConverterTypeTypedAccessControllerBlueprintEvent.write(
                value.value, buf
            )


class TypedAccountBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedAccountBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCOUNT_WITHDRAW_EVENT_VALUE:
        value: "AccountWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_DEPOSIT_EVENT_VALUE:
        value: "AccountDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE:
        value: "AccountRejectedDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountRejectedDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_rejected_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE:
        value: "AccountSetResourcePreferenceEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountSetResourcePreferenceEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_set_resource_preference_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE:
        value: "AccountRemoveResourcePreferenceEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountRemoveResourcePreferenceEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_remove_resource_preference_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE:
        value: "AccountSetDefaultDepositRuleEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountSetDefaultDepositRuleEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_set_default_deposit_rule_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE:
        value: "AccountAddAuthorizedDepositorEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountAddAuthorizedDepositorEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_add_authorized_depositor_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE:
        value: "AccountRemoveAuthorizedDepositorEvent"

        @typing.no_type_check
        def __init__(self, value: "AccountRemoveAuthorizedDepositorEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountBlueprintEvent.ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_account_remove_authorized_depositor_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_account_withdraw_event_value(self) -> bool:
        return isinstance(self, TypedAccountBlueprintEvent.ACCOUNT_WITHDRAW_EVENT_VALUE)

    def is_account_deposit_event_value(self) -> bool:
        return isinstance(self, TypedAccountBlueprintEvent.ACCOUNT_DEPOSIT_EVENT_VALUE)

    def is_account_rejected_deposit_event_value(self) -> bool:
        return isinstance(
            self, TypedAccountBlueprintEvent.ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE
        )

    def is_account_set_resource_preference_event_value(self) -> bool:
        return isinstance(
            self, TypedAccountBlueprintEvent.ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE
        )

    def is_account_remove_resource_preference_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccountBlueprintEvent.ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE,
        )

    def is_account_set_default_deposit_rule_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccountBlueprintEvent.ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE,
        )

    def is_account_add_authorized_depositor_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccountBlueprintEvent.ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE,
        )

    def is_account_remove_authorized_depositor_event_value(self) -> bool:
        return isinstance(
            self,
            TypedAccountBlueprintEvent.ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccountBlueprintEvent.ACCOUNT_WITHDRAW_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_WITHDRAW_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_WITHDRAW_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_DEPOSIT_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_DEPOSIT_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_DEPOSIT_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountBlueprintEvent.ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE = type(
    "TypedAccountBlueprintEvent.ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE",
    (
        TypedAccountBlueprintEvent.ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE,
        TypedAccountBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedAccountBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccountBlueprintEvent.ACCOUNT_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeAccountWithdrawEvent.read(buf),
            )
        if variant == 2:
            return TypedAccountBlueprintEvent.ACCOUNT_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeAccountDepositEvent.read(buf),
            )
        if variant == 3:
            return TypedAccountBlueprintEvent.ACCOUNT_REJECTED_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeAccountRejectedDepositEvent.read(buf),
            )
        if variant == 4:
            return (
                TypedAccountBlueprintEvent.ACCOUNT_SET_RESOURCE_PREFERENCE_EVENT_VALUE(
                    _UniffiConverterTypeAccountSetResourcePreferenceEvent.read(buf),
                )
            )
        if variant == 5:
            return TypedAccountBlueprintEvent.ACCOUNT_REMOVE_RESOURCE_PREFERENCE_EVENT_VALUE(
                _UniffiConverterTypeAccountRemoveResourcePreferenceEvent.read(buf),
            )
        if variant == 6:
            return (
                TypedAccountBlueprintEvent.ACCOUNT_SET_DEFAULT_DEPOSIT_RULE_EVENT_VALUE(
                    _UniffiConverterTypeAccountSetDefaultDepositRuleEvent.read(buf),
                )
            )
        if variant == 7:
            return (
                TypedAccountBlueprintEvent.ACCOUNT_ADD_AUTHORIZED_DEPOSITOR_EVENT_VALUE(
                    _UniffiConverterTypeAccountAddAuthorizedDepositorEvent.read(buf),
                )
            )
        if variant == 8:
            return TypedAccountBlueprintEvent.ACCOUNT_REMOVE_AUTHORIZED_DEPOSITOR_EVENT_VALUE(
                _UniffiConverterTypeAccountRemoveAuthorizedDepositorEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_account_withdraw_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeAccountWithdrawEvent.write(value.value, buf)
        if value.is_account_deposit_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeAccountDepositEvent.write(value.value, buf)
        if value.is_account_rejected_deposit_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeAccountRejectedDepositEvent.write(value.value, buf)
        if value.is_account_set_resource_preference_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeAccountSetResourcePreferenceEvent.write(
                value.value, buf
            )
        if value.is_account_remove_resource_preference_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeAccountRemoveResourcePreferenceEvent.write(
                value.value, buf
            )
        if value.is_account_set_default_deposit_rule_event_value():
            buf.write_i32(6)
            _UniffiConverterTypeAccountSetDefaultDepositRuleEvent.write(
                value.value, buf
            )
        if value.is_account_add_authorized_depositor_event_value():
            buf.write_i32(7)
            _UniffiConverterTypeAccountAddAuthorizedDepositorEvent.write(
                value.value, buf
            )
        if value.is_account_remove_authorized_depositor_event_value():
            buf.write_i32(8)
            _UniffiConverterTypeAccountRemoveAuthorizedDepositorEvent.write(
                value.value, buf
            )


class TypedAccountLockerBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedAccountLockerBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class STORE_EVENT_VALUE:
        value: "StoreEvent"

        @typing.no_type_check
        def __init__(self, value: "StoreEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedAccountLockerBlueprintEvent.STORE_EVENT_VALUE(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_store_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class RECOVER_EVENT_VALUE:
        value: "RecoverEvent"

        @typing.no_type_check
        def __init__(self, value: "RecoverEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedAccountLockerBlueprintEvent.RECOVER_EVENT_VALUE(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_recover_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class CLAIM_EVENT_VALUE:
        value: "ClaimEvent"

        @typing.no_type_check
        def __init__(self, value: "ClaimEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedAccountLockerBlueprintEvent.CLAIM_EVENT_VALUE(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_claim_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_store_event_value(self) -> bool:
        return isinstance(self, TypedAccountLockerBlueprintEvent.STORE_EVENT_VALUE)

    def is_recover_event_value(self) -> bool:
        return isinstance(self, TypedAccountLockerBlueprintEvent.RECOVER_EVENT_VALUE)

    def is_claim_event_value(self) -> bool:
        return isinstance(self, TypedAccountLockerBlueprintEvent.CLAIM_EVENT_VALUE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccountLockerBlueprintEvent.STORE_EVENT_VALUE = type(
    "TypedAccountLockerBlueprintEvent.STORE_EVENT_VALUE",
    (
        TypedAccountLockerBlueprintEvent.STORE_EVENT_VALUE,
        TypedAccountLockerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountLockerBlueprintEvent.RECOVER_EVENT_VALUE = type(
    "TypedAccountLockerBlueprintEvent.RECOVER_EVENT_VALUE",
    (
        TypedAccountLockerBlueprintEvent.RECOVER_EVENT_VALUE,
        TypedAccountLockerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedAccountLockerBlueprintEvent.CLAIM_EVENT_VALUE = type(
    "TypedAccountLockerBlueprintEvent.CLAIM_EVENT_VALUE",
    (
        TypedAccountLockerBlueprintEvent.CLAIM_EVENT_VALUE,
        TypedAccountLockerBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedAccountLockerBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccountLockerBlueprintEvent.STORE_EVENT_VALUE(
                _UniffiConverterTypeStoreEvent.read(buf),
            )
        if variant == 2:
            return TypedAccountLockerBlueprintEvent.RECOVER_EVENT_VALUE(
                _UniffiConverterTypeRecoverEvent.read(buf),
            )
        if variant == 3:
            return TypedAccountLockerBlueprintEvent.CLAIM_EVENT_VALUE(
                _UniffiConverterTypeClaimEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_store_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeStoreEvent.write(value.value, buf)
        if value.is_recover_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeRecoverEvent.write(value.value, buf)
        if value.is_claim_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeClaimEvent.write(value.value, buf)


class TypedAccountPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedAccountPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCOUNT:
        value: "TypedAccountBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedAccountBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedAccountPackageEvent.ACCOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_account():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_account(self) -> bool:
        return isinstance(self, TypedAccountPackageEvent.ACCOUNT)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccountPackageEvent.ACCOUNT = type(
    "TypedAccountPackageEvent.ACCOUNT",
    (
        TypedAccountPackageEvent.ACCOUNT,
        TypedAccountPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedAccountPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccountPackageEvent.ACCOUNT(
                _UniffiConverterTypeTypedAccountBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_account():
            buf.write_i32(1)
            _UniffiConverterTypeTypedAccountBlueprintEvent.write(value.value, buf)


class TypedConsensusManagerBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedConsensusManagerBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class ROUND_CHANGE_EVENT_VALUE:
        value: "RoundChangeEvent"

        @typing.no_type_check
        def __init__(self, value: "RoundChangeEvent"):

            self.value = value

        def __str__(self):
            return "TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_round_change_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class EPOCH_CHANGE_EVENT_VALUE:
        value: "EpochChangeEvent"

        @typing.no_type_check
        def __init__(self, value: "EpochChangeEvent"):

            self.value = value

        def __str__(self):
            return "TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_epoch_change_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_round_change_event_value(self) -> bool:
        return isinstance(
            self, TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE
        )

    def is_epoch_change_event_value(self) -> bool:
        return isinstance(
            self, TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE = type(
    "TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE",
    (
        TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE,
        TypedConsensusManagerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE = type(
    "TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE",
    (
        TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE,
        TypedConsensusManagerBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedConsensusManagerBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE(
                _UniffiConverterTypeRoundChangeEvent.read(buf),
            )
        if variant == 2:
            return TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE(
                _UniffiConverterTypeEpochChangeEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_round_change_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeRoundChangeEvent.write(value.value, buf)
        if value.is_epoch_change_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeEpochChangeEvent.write(value.value, buf)


class TypedConsensusManagerPackageEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedConsensusManagerPackageEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class CONSENSUS_MANAGER:
        value: "TypedConsensusManagerBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedConsensusManagerBlueprintEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_consensus_manager():
                return False
            if self.value != other.value:
                return False
            return True

    class VALIDATOR:
        value: "TypedValidatorBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedValidatorBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedConsensusManagerPackageEvent.VALIDATOR(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_validator():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_consensus_manager(self) -> bool:
        return isinstance(self, TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER)

    def is_validator(self) -> bool:
        return isinstance(self, TypedConsensusManagerPackageEvent.VALIDATOR)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER = type(
    "TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER",
    (
        TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER,
        TypedConsensusManagerPackageEvent,
    ),
    {},
)  # type: ignore
TypedConsensusManagerPackageEvent.VALIDATOR = type(
    "TypedConsensusManagerPackageEvent.VALIDATOR",
    (
        TypedConsensusManagerPackageEvent.VALIDATOR,
        TypedConsensusManagerPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedConsensusManagerPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER(
                _UniffiConverterTypeTypedConsensusManagerBlueprintEvent.read(buf),
            )
        if variant == 2:
            return TypedConsensusManagerPackageEvent.VALIDATOR(
                _UniffiConverterTypeTypedValidatorBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_consensus_manager():
            buf.write_i32(1)
            _UniffiConverterTypeTypedConsensusManagerBlueprintEvent.write(
                value.value, buf
            )
        if value.is_validator():
            buf.write_i32(2)
            _UniffiConverterTypeTypedValidatorBlueprintEvent.write(value.value, buf)


class TypedFungibleResourceManagerBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedFungibleResourceManagerBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class VAULT_CREATION_EVENT_VALUE:
        value: "VaultCreationEvent"

        @typing.no_type_check
        def __init__(self, value: "VaultCreationEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_vault_creation_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class MINT_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "MintFungibleResourceEvent"

        @typing.no_type_check
        def __init__(self, value: "MintFungibleResourceEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_mint_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BURN_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "BurnFungibleResourceEvent"

        @typing.no_type_check
        def __init__(self, value: "BurnFungibleResourceEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_burn_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_vault_creation_event_value(self) -> bool:
        return isinstance(
            self, TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE
        )

    def is_mint_fungible_resource_event_value(self) -> bool:
        return isinstance(
            self,
            TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE,
        )

    def is_burn_fungible_resource_event_value(self) -> bool:
        return isinstance(
            self,
            TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE = type(
    "TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE",
    (
        TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE,
        TypedFungibleResourceManagerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE = type(
    "TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE",
    (
        TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE,
        TypedFungibleResourceManagerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE = type(
    "TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE",
    (
        TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE,
        TypedFungibleResourceManagerBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedFungibleResourceManagerBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return (
                TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(
                    _UniffiConverterTypeVaultCreationEvent.read(buf),
                )
            )
        if variant == 2:
            return TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeMintFungibleResourceEvent.read(buf),
            )
        if variant == 3:
            return TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeBurnFungibleResourceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_vault_creation_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeVaultCreationEvent.write(value.value, buf)
        if value.is_mint_fungible_resource_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeMintFungibleResourceEvent.write(value.value, buf)
        if value.is_burn_fungible_resource_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeBurnFungibleResourceEvent.write(value.value, buf)


class TypedFungibleVaultBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedFungibleVaultBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE:
        value: "FungibleVaultLockFeeEvent"

        @typing.no_type_check
        def __init__(self, value: "FungibleVaultLockFeeEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_fungible_vault_lock_fee_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE:
        value: "FungibleVaultWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "FungibleVaultWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_fungible_vault_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE:
        value: "FungibleVaultDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "FungibleVaultDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_fungible_vault_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class FUNGIBLE_VAULT_RECALL_EVENT_VALUE:
        value: "FungibleVaultRecallEvent"

        @typing.no_type_check
        def __init__(self, value: "FungibleVaultRecallEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_RECALL_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_fungible_vault_recall_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE:
        value: "FungibleVaultPayFeeEvent"

        @typing.no_type_check
        def __init__(self, value: "FungibleVaultPayFeeEvent"):

            self.value = value

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_fungible_vault_pay_fee_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible_vault_lock_fee_event_value(self) -> bool:
        return isinstance(
            self, TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE
        )

    def is_fungible_vault_withdraw_event_value(self) -> bool:
        return isinstance(
            self, TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE
        )

    def is_fungible_vault_deposit_event_value(self) -> bool:
        return isinstance(
            self, TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE
        )

    def is_fungible_vault_recall_event_value(self) -> bool:
        return isinstance(
            self, TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_RECALL_EVENT_VALUE
        )

    def is_fungible_vault_pay_fee_event_value(self) -> bool:
        return isinstance(
            self, TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE = type(
    "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE",
    (
        TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE,
        TypedFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE = type(
    "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE",
    (
        TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE,
        TypedFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE = type(
    "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE",
    (
        TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE,
        TypedFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_RECALL_EVENT_VALUE = type(
    "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_RECALL_EVENT_VALUE",
    (
        TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_RECALL_EVENT_VALUE,
        TypedFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE = type(
    "TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE",
    (
        TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE,
        TypedFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedFungibleVaultBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_LOCK_FEE_EVENT_VALUE(
                _UniffiConverterTypeFungibleVaultLockFeeEvent.read(buf),
            )
        if variant == 2:
            return TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeFungibleVaultWithdrawEvent.read(buf),
            )
        if variant == 3:
            return TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeFungibleVaultDepositEvent.read(buf),
            )
        if variant == 4:
            return TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_RECALL_EVENT_VALUE(
                _UniffiConverterTypeFungibleVaultRecallEvent.read(buf),
            )
        if variant == 5:
            return TypedFungibleVaultBlueprintEvent.FUNGIBLE_VAULT_PAY_FEE_EVENT_VALUE(
                _UniffiConverterTypeFungibleVaultPayFeeEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible_vault_lock_fee_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeFungibleVaultLockFeeEvent.write(value.value, buf)
        if value.is_fungible_vault_withdraw_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeFungibleVaultWithdrawEvent.write(value.value, buf)
        if value.is_fungible_vault_deposit_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeFungibleVaultDepositEvent.write(value.value, buf)
        if value.is_fungible_vault_recall_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeFungibleVaultRecallEvent.write(value.value, buf)
        if value.is_fungible_vault_pay_fee_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeFungibleVaultPayFeeEvent.write(value.value, buf)


class TypedLockerPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedLockerPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCOUNT_LOCKER:
        value: "TypedAccountLockerBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedAccountLockerBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedLockerPackageEvent.ACCOUNT_LOCKER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_account_locker():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_account_locker(self) -> bool:
        return isinstance(self, TypedLockerPackageEvent.ACCOUNT_LOCKER)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedLockerPackageEvent.ACCOUNT_LOCKER = type(
    "TypedLockerPackageEvent.ACCOUNT_LOCKER",
    (
        TypedLockerPackageEvent.ACCOUNT_LOCKER,
        TypedLockerPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedLockerPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedLockerPackageEvent.ACCOUNT_LOCKER(
                _UniffiConverterTypeTypedAccountLockerBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_account_locker():
            buf.write_i32(1)
            _UniffiConverterTypeTypedAccountLockerBlueprintEvent.write(value.value, buf)


class TypedMetadataBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedMetadataBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class SET_METADATA_EVENT_VALUE:
        value: "SetMetadataEvent"

        @typing.no_type_check
        def __init__(self, value: "SetMetadataEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_set_metadata_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class REMOVE_METADATA_EVENT_VALUE:
        value: "RemoveMetadataEvent"

        @typing.no_type_check
        def __init__(self, value: "RemoveMetadataEvent"):

            self.value = value

        def __str__(self):
            return "TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_remove_metadata_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_set_metadata_event_value(self) -> bool:
        return isinstance(self, TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE)

    def is_remove_metadata_event_value(self) -> bool:
        return isinstance(self, TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE = type(
    "TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE",
    (
        TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE,
        TypedMetadataBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE = type(
    "TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE",
    (
        TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE,
        TypedMetadataBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedMetadataBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE(
                _UniffiConverterTypeSetMetadataEvent.read(buf),
            )
        if variant == 2:
            return TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE(
                _UniffiConverterTypeRemoveMetadataEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_set_metadata_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeSetMetadataEvent.write(value.value, buf)
        if value.is_remove_metadata_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeRemoveMetadataEvent.write(value.value, buf)


class TypedMetadataPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedMetadataPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class METADATA:
        value: "TypedMetadataBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedMetadataBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedMetadataPackageEvent.METADATA(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_metadata():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_metadata(self) -> bool:
        return isinstance(self, TypedMetadataPackageEvent.METADATA)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedMetadataPackageEvent.METADATA = type(
    "TypedMetadataPackageEvent.METADATA",
    (
        TypedMetadataPackageEvent.METADATA,
        TypedMetadataPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedMetadataPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedMetadataPackageEvent.METADATA(
                _UniffiConverterTypeTypedMetadataBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_metadata():
            buf.write_i32(1)
            _UniffiConverterTypeTypedMetadataBlueprintEvent.write(value.value, buf)


class TypedMultiResourcePoolBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedMultiResourcePoolBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE:
        value: "MultiResourcePoolContributionEvent"

        @typing.no_type_check
        def __init__(self, value: "MultiResourcePoolContributionEvent"):

            self.value = value

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_multi_resource_pool_contribution_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE:
        value: "MultiResourcePoolRedemptionEvent"

        @typing.no_type_check
        def __init__(self, value: "MultiResourcePoolRedemptionEvent"):

            self.value = value

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_multi_resource_pool_redemption_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE:
        value: "MultiResourcePoolWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "MultiResourcePoolWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_multi_resource_pool_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE:
        value: "MultiResourcePoolDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "MultiResourcePoolDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_multi_resource_pool_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_multi_resource_pool_contribution_event_value(self) -> bool:
        return isinstance(
            self,
            TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE,
        )

    def is_multi_resource_pool_redemption_event_value(self) -> bool:
        return isinstance(
            self,
            TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE,
        )

    def is_multi_resource_pool_withdraw_event_value(self) -> bool:
        return isinstance(
            self,
            TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE,
        )

    def is_multi_resource_pool_deposit_event_value(self) -> bool:
        return isinstance(
            self,
            TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE = type(
    "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE",
    (
        TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE,
        TypedMultiResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE = type(
    "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE",
    (
        TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE,
        TypedMultiResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE = type(
    "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE",
    (
        TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE,
        TypedMultiResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE = type(
    "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE",
    (
        TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE,
        TypedMultiResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedMultiResourcePoolBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolContributionEvent.read(buf),
            )
        if variant == 2:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolRedemptionEvent.read(buf),
            )
        if variant == 3:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolWithdrawEvent.read(buf),
            )
        if variant == 4:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolDepositEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_multi_resource_pool_contribution_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeMultiResourcePoolContributionEvent.write(
                value.value, buf
            )
        if value.is_multi_resource_pool_redemption_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeMultiResourcePoolRedemptionEvent.write(value.value, buf)
        if value.is_multi_resource_pool_withdraw_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeMultiResourcePoolWithdrawEvent.write(value.value, buf)
        if value.is_multi_resource_pool_deposit_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeMultiResourcePoolDepositEvent.write(value.value, buf)


class TypedNativeEvent:
    def __init__(self):
        raise RuntimeError("TypedNativeEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCESS_CONTROLLER:
        value: "TypedAccessControllerPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedAccessControllerPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.ACCESS_CONTROLLER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_access_controller():
                return False
            if self.value != other.value:
                return False
            return True

    class ACCOUNT:
        value: "TypedAccountPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedAccountPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.ACCOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_account():
                return False
            if self.value != other.value:
                return False
            return True

    class CONSENSUS_MANAGER:
        value: "TypedConsensusManagerPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedConsensusManagerPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.CONSENSUS_MANAGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_consensus_manager():
                return False
            if self.value != other.value:
                return False
            return True

    class POOL:
        value: "TypedPoolPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedPoolPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.POOL(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_pool():
                return False
            if self.value != other.value:
                return False
            return True

    class RESOURCE:
        value: "TypedResourcePackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedResourcePackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.RESOURCE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_resource():
                return False
            if self.value != other.value:
                return False
            return True

    class ROLE_ASSIGNMENT:
        value: "TypedRoleAssignmentPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedRoleAssignmentPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.ROLE_ASSIGNMENT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_role_assignment():
                return False
            if self.value != other.value:
                return False
            return True

    class METADATA:
        value: "TypedMetadataPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedMetadataPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.METADATA(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_metadata():
                return False
            if self.value != other.value:
                return False
            return True

    class LOCKER:
        value: "TypedLockerPackageEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedLockerPackageEvent"):

            self.value = value

        def __str__(self):
            return "TypedNativeEvent.LOCKER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_locker():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_access_controller(self) -> bool:
        return isinstance(self, TypedNativeEvent.ACCESS_CONTROLLER)

    def is_account(self) -> bool:
        return isinstance(self, TypedNativeEvent.ACCOUNT)

    def is_consensus_manager(self) -> bool:
        return isinstance(self, TypedNativeEvent.CONSENSUS_MANAGER)

    def is_pool(self) -> bool:
        return isinstance(self, TypedNativeEvent.POOL)

    def is_resource(self) -> bool:
        return isinstance(self, TypedNativeEvent.RESOURCE)

    def is_role_assignment(self) -> bool:
        return isinstance(self, TypedNativeEvent.ROLE_ASSIGNMENT)

    def is_metadata(self) -> bool:
        return isinstance(self, TypedNativeEvent.METADATA)

    def is_locker(self) -> bool:
        return isinstance(self, TypedNativeEvent.LOCKER)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedNativeEvent.ACCESS_CONTROLLER = type(
    "TypedNativeEvent.ACCESS_CONTROLLER",
    (
        TypedNativeEvent.ACCESS_CONTROLLER,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.ACCOUNT = type(
    "TypedNativeEvent.ACCOUNT",
    (
        TypedNativeEvent.ACCOUNT,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.CONSENSUS_MANAGER = type(
    "TypedNativeEvent.CONSENSUS_MANAGER",
    (
        TypedNativeEvent.CONSENSUS_MANAGER,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.POOL = type(
    "TypedNativeEvent.POOL",
    (
        TypedNativeEvent.POOL,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.RESOURCE = type(
    "TypedNativeEvent.RESOURCE",
    (
        TypedNativeEvent.RESOURCE,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.ROLE_ASSIGNMENT = type(
    "TypedNativeEvent.ROLE_ASSIGNMENT",
    (
        TypedNativeEvent.ROLE_ASSIGNMENT,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.METADATA = type(
    "TypedNativeEvent.METADATA",
    (
        TypedNativeEvent.METADATA,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore
TypedNativeEvent.LOCKER = type(
    "TypedNativeEvent.LOCKER",
    (
        TypedNativeEvent.LOCKER,
        TypedNativeEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedNativeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedNativeEvent.ACCESS_CONTROLLER(
                _UniffiConverterTypeTypedAccessControllerPackageEvent.read(buf),
            )
        if variant == 2:
            return TypedNativeEvent.ACCOUNT(
                _UniffiConverterTypeTypedAccountPackageEvent.read(buf),
            )
        if variant == 3:
            return TypedNativeEvent.CONSENSUS_MANAGER(
                _UniffiConverterTypeTypedConsensusManagerPackageEvent.read(buf),
            )
        if variant == 4:
            return TypedNativeEvent.POOL(
                _UniffiConverterTypeTypedPoolPackageEvent.read(buf),
            )
        if variant == 5:
            return TypedNativeEvent.RESOURCE(
                _UniffiConverterTypeTypedResourcePackageEvent.read(buf),
            )
        if variant == 6:
            return TypedNativeEvent.ROLE_ASSIGNMENT(
                _UniffiConverterTypeTypedRoleAssignmentPackageEvent.read(buf),
            )
        if variant == 7:
            return TypedNativeEvent.METADATA(
                _UniffiConverterTypeTypedMetadataPackageEvent.read(buf),
            )
        if variant == 8:
            return TypedNativeEvent.LOCKER(
                _UniffiConverterTypeTypedLockerPackageEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_access_controller():
            buf.write_i32(1)
            _UniffiConverterTypeTypedAccessControllerPackageEvent.write(
                value.value, buf
            )
        if value.is_account():
            buf.write_i32(2)
            _UniffiConverterTypeTypedAccountPackageEvent.write(value.value, buf)
        if value.is_consensus_manager():
            buf.write_i32(3)
            _UniffiConverterTypeTypedConsensusManagerPackageEvent.write(
                value.value, buf
            )
        if value.is_pool():
            buf.write_i32(4)
            _UniffiConverterTypeTypedPoolPackageEvent.write(value.value, buf)
        if value.is_resource():
            buf.write_i32(5)
            _UniffiConverterTypeTypedResourcePackageEvent.write(value.value, buf)
        if value.is_role_assignment():
            buf.write_i32(6)
            _UniffiConverterTypeTypedRoleAssignmentPackageEvent.write(value.value, buf)
        if value.is_metadata():
            buf.write_i32(7)
            _UniffiConverterTypeTypedMetadataPackageEvent.write(value.value, buf)
        if value.is_locker():
            buf.write_i32(8)
            _UniffiConverterTypeTypedLockerPackageEvent.write(value.value, buf)


class TypedNonFungibleResourceManagerBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedNonFungibleResourceManagerBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class VAULT_CREATION_EVENT_VALUE:
        value: "VaultCreationEvent"

        @typing.no_type_check
        def __init__(self, value: "VaultCreationEvent"):

            self.value = value

        def __str__(self):
            return "TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_vault_creation_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "MintNonFungibleResourceEvent"

        @typing.no_type_check
        def __init__(self, value: "MintNonFungibleResourceEvent"):

            self.value = value

        def __str__(self):
            return "TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_mint_non_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "BurnNonFungibleResourceEvent"

        @typing.no_type_check
        def __init__(self, value: "BurnNonFungibleResourceEvent"):

            self.value = value

        def __str__(self):
            return "TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_burn_non_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_vault_creation_event_value(self) -> bool:
        return isinstance(
            self,
            TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE,
        )

    def is_mint_non_fungible_resource_event_value(self) -> bool:
        return isinstance(
            self,
            TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE,
        )

    def is_burn_non_fungible_resource_event_value(self) -> bool:
        return isinstance(
            self,
            TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE = type(
    "TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE",
    (
        TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE,
        TypedNonFungibleResourceManagerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE = type(
    "TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE",
    (
        TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE,
        TypedNonFungibleResourceManagerBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE = type(
    "TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE",
    (
        TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE,
        TypedNonFungibleResourceManagerBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(
                _UniffiConverterTypeVaultCreationEvent.read(buf),
            )
        if variant == 2:
            return TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeMintNonFungibleResourceEvent.read(buf),
            )
        if variant == 3:
            return TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeBurnNonFungibleResourceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_vault_creation_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeVaultCreationEvent.write(value.value, buf)
        if value.is_mint_non_fungible_resource_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeMintNonFungibleResourceEvent.write(value.value, buf)
        if value.is_burn_non_fungible_resource_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeBurnNonFungibleResourceEvent.write(value.value, buf)


class TypedNonFungibleVaultBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedNonFungibleVaultBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE:
        value: "NonFungibleVaultWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleVaultWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_vault_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE:
        value: "NonFungibleVaultDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleVaultDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_vault_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE:
        value: "NonFungibleVaultRecallEvent"

        @typing.no_type_check
        def __init__(self, value: "NonFungibleVaultRecallEvent"):

            self.value = value

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_vault_recall_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_non_fungible_vault_withdraw_event_value(self) -> bool:
        return isinstance(
            self,
            TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE,
        )

    def is_non_fungible_vault_deposit_event_value(self) -> bool:
        return isinstance(
            self,
            TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE,
        )

    def is_non_fungible_vault_recall_event_value(self) -> bool:
        return isinstance(
            self,
            TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE = type(
    "TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE",
    (
        TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE,
        TypedNonFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE = type(
    "TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE",
    (
        TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE,
        TypedNonFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE = type(
    "TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE",
    (
        TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE,
        TypedNonFungibleVaultBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedNonFungibleVaultBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeNonFungibleVaultWithdrawEvent.read(buf),
            )
        if variant == 2:
            return TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeNonFungibleVaultDepositEvent.read(buf),
            )
        if variant == 3:
            return TypedNonFungibleVaultBlueprintEvent.NON_FUNGIBLE_VAULT_RECALL_EVENT_VALUE(
                _UniffiConverterTypeNonFungibleVaultRecallEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_non_fungible_vault_withdraw_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeNonFungibleVaultWithdrawEvent.write(value.value, buf)
        if value.is_non_fungible_vault_deposit_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeNonFungibleVaultDepositEvent.write(value.value, buf)
        if value.is_non_fungible_vault_recall_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeNonFungibleVaultRecallEvent.write(value.value, buf)


class TypedOneResourcePoolBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedOneResourcePoolBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE:
        value: "OneResourcePoolContributionEvent"

        @typing.no_type_check
        def __init__(self, value: "OneResourcePoolContributionEvent"):

            self.value = value

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_one_resource_pool_contribution_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE:
        value: "OneResourcePoolRedemptionEvent"

        @typing.no_type_check
        def __init__(self, value: "OneResourcePoolRedemptionEvent"):

            self.value = value

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_one_resource_pool_redemption_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE:
        value: "OneResourcePoolWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "OneResourcePoolWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_one_resource_pool_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE:
        value: "OneResourcePoolDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "OneResourcePoolDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_one_resource_pool_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_one_resource_pool_contribution_event_value(self) -> bool:
        return isinstance(
            self,
            TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE,
        )

    def is_one_resource_pool_redemption_event_value(self) -> bool:
        return isinstance(
            self,
            TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE,
        )

    def is_one_resource_pool_withdraw_event_value(self) -> bool:
        return isinstance(
            self,
            TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE,
        )

    def is_one_resource_pool_deposit_event_value(self) -> bool:
        return isinstance(
            self,
            TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE = type(
    "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE",
    (
        TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE,
        TypedOneResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE = type(
    "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE",
    (
        TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE,
        TypedOneResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE = type(
    "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE",
    (
        TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE,
        TypedOneResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE = type(
    "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE",
    (
        TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE,
        TypedOneResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedOneResourcePoolBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolContributionEvent.read(buf),
            )
        if variant == 2:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolRedemptionEvent.read(buf),
            )
        if variant == 3:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolWithdrawEvent.read(buf),
            )
        if variant == 4:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolDepositEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_one_resource_pool_contribution_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeOneResourcePoolContributionEvent.write(value.value, buf)
        if value.is_one_resource_pool_redemption_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeOneResourcePoolRedemptionEvent.write(value.value, buf)
        if value.is_one_resource_pool_withdraw_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeOneResourcePoolWithdrawEvent.write(value.value, buf)
        if value.is_one_resource_pool_deposit_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeOneResourcePoolDepositEvent.write(value.value, buf)


class TypedPoolPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedPoolPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONE_RESOURCE_POOL:
        value: "TypedOneResourcePoolBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedOneResourcePoolBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedPoolPackageEvent.ONE_RESOURCE_POOL(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_one_resource_pool():
                return False
            if self.value != other.value:
                return False
            return True

    class TWO_RESOURCE_POOL:
        value: "TypedTwoResourcePoolBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedTwoResourcePoolBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedPoolPackageEvent.TWO_RESOURCE_POOL(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_two_resource_pool():
                return False
            if self.value != other.value:
                return False
            return True

    class MULTI_RESOURCE_POOL:
        value: "TypedMultiResourcePoolBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedMultiResourcePoolBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedPoolPackageEvent.MULTI_RESOURCE_POOL(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_multi_resource_pool():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_one_resource_pool(self) -> bool:
        return isinstance(self, TypedPoolPackageEvent.ONE_RESOURCE_POOL)

    def is_two_resource_pool(self) -> bool:
        return isinstance(self, TypedPoolPackageEvent.TWO_RESOURCE_POOL)

    def is_multi_resource_pool(self) -> bool:
        return isinstance(self, TypedPoolPackageEvent.MULTI_RESOURCE_POOL)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedPoolPackageEvent.ONE_RESOURCE_POOL = type(
    "TypedPoolPackageEvent.ONE_RESOURCE_POOL",
    (
        TypedPoolPackageEvent.ONE_RESOURCE_POOL,
        TypedPoolPackageEvent,
    ),
    {},
)  # type: ignore
TypedPoolPackageEvent.TWO_RESOURCE_POOL = type(
    "TypedPoolPackageEvent.TWO_RESOURCE_POOL",
    (
        TypedPoolPackageEvent.TWO_RESOURCE_POOL,
        TypedPoolPackageEvent,
    ),
    {},
)  # type: ignore
TypedPoolPackageEvent.MULTI_RESOURCE_POOL = type(
    "TypedPoolPackageEvent.MULTI_RESOURCE_POOL",
    (
        TypedPoolPackageEvent.MULTI_RESOURCE_POOL,
        TypedPoolPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedPoolPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedPoolPackageEvent.ONE_RESOURCE_POOL(
                _UniffiConverterTypeTypedOneResourcePoolBlueprintEvent.read(buf),
            )
        if variant == 2:
            return TypedPoolPackageEvent.TWO_RESOURCE_POOL(
                _UniffiConverterTypeTypedTwoResourcePoolBlueprintEvent.read(buf),
            )
        if variant == 3:
            return TypedPoolPackageEvent.MULTI_RESOURCE_POOL(
                _UniffiConverterTypeTypedMultiResourcePoolBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_one_resource_pool():
            buf.write_i32(1)
            _UniffiConverterTypeTypedOneResourcePoolBlueprintEvent.write(
                value.value, buf
            )
        if value.is_two_resource_pool():
            buf.write_i32(2)
            _UniffiConverterTypeTypedTwoResourcePoolBlueprintEvent.write(
                value.value, buf
            )
        if value.is_multi_resource_pool():
            buf.write_i32(3)
            _UniffiConverterTypeTypedMultiResourcePoolBlueprintEvent.write(
                value.value, buf
            )


class TypedResourcePackageEvent:
    def __init__(self):
        raise RuntimeError("TypedResourcePackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE_VAULT:
        value: "TypedFungibleVaultBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedFungibleVaultBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedResourcePackageEvent.FUNGIBLE_VAULT(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_fungible_vault():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_VAULT:
        value: "TypedNonFungibleVaultBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedNonFungibleVaultBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedResourcePackageEvent.NON_FUNGIBLE_VAULT(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_vault():
                return False
            if self.value != other.value:
                return False
            return True

    class FUNGIBLE_RESOURCE_MANAGER:
        value: "TypedFungibleResourceManagerBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedFungibleResourceManagerBlueprintEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_fungible_resource_manager():
                return False
            if self.value != other.value:
                return False
            return True

    class NON_FUNGIBLE_RESOURCE_MANAGER:
        value: "TypedNonFungibleResourceManagerBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedNonFungibleResourceManagerBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_non_fungible_resource_manager():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible_vault(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.FUNGIBLE_VAULT)

    def is_non_fungible_vault(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.NON_FUNGIBLE_VAULT)

    def is_fungible_resource_manager(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER)

    def is_non_fungible_resource_manager(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedResourcePackageEvent.FUNGIBLE_VAULT = type(
    "TypedResourcePackageEvent.FUNGIBLE_VAULT",
    (
        TypedResourcePackageEvent.FUNGIBLE_VAULT,
        TypedResourcePackageEvent,
    ),
    {},
)  # type: ignore
TypedResourcePackageEvent.NON_FUNGIBLE_VAULT = type(
    "TypedResourcePackageEvent.NON_FUNGIBLE_VAULT",
    (
        TypedResourcePackageEvent.NON_FUNGIBLE_VAULT,
        TypedResourcePackageEvent,
    ),
    {},
)  # type: ignore
TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER = type(
    "TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER",
    (
        TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER,
        TypedResourcePackageEvent,
    ),
    {},
)  # type: ignore
TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER = type(
    "TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER",
    (
        TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER,
        TypedResourcePackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedResourcePackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedResourcePackageEvent.FUNGIBLE_VAULT(
                _UniffiConverterTypeTypedFungibleVaultBlueprintEvent.read(buf),
            )
        if variant == 2:
            return TypedResourcePackageEvent.NON_FUNGIBLE_VAULT(
                _UniffiConverterTypeTypedNonFungibleVaultBlueprintEvent.read(buf),
            )
        if variant == 3:
            return TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER(
                _UniffiConverterTypeTypedFungibleResourceManagerBlueprintEvent.read(
                    buf
                ),
            )
        if variant == 4:
            return TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER(
                _UniffiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.read(
                    buf
                ),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible_vault():
            buf.write_i32(1)
            _UniffiConverterTypeTypedFungibleVaultBlueprintEvent.write(value.value, buf)
        if value.is_non_fungible_vault():
            buf.write_i32(2)
            _UniffiConverterTypeTypedNonFungibleVaultBlueprintEvent.write(
                value.value, buf
            )
        if value.is_fungible_resource_manager():
            buf.write_i32(3)
            _UniffiConverterTypeTypedFungibleResourceManagerBlueprintEvent.write(
                value.value, buf
            )
        if value.is_non_fungible_resource_manager():
            buf.write_i32(4)
            _UniffiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.write(
                value.value, buf
            )


class TypedRoleAssignmentBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedRoleAssignmentBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class SET_ROLE_EVENT_VALUE:
        value: "SetRoleEvent"

        @typing.no_type_check
        def __init__(self, value: "SetRoleEvent"):

            self.value = value

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_set_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class SET_OWNER_ROLE_EVENT_VALUE:
        value: "SetOwnerRoleEvent"

        @typing.no_type_check
        def __init__(self, value: "SetOwnerRoleEvent"):

            self.value = value

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_set_owner_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class LOCK_OWNER_ROLE_EVENT_VALUE:
        value: "LockOwnerRoleEvent"

        @typing.no_type_check
        def __init__(self, value: "LockOwnerRoleEvent"):

            self.value = value

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_lock_owner_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_set_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE)

    def is_set_owner_role_event_value(self) -> bool:
        return isinstance(
            self, TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE
        )

    def is_lock_owner_role_event_value(self) -> bool:
        return isinstance(
            self, TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE = type(
    "TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE",
    (
        TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE,
        TypedRoleAssignmentBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE = type(
    "TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE",
    (
        TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE,
        TypedRoleAssignmentBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE = type(
    "TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE",
    (
        TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE,
        TypedRoleAssignmentBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedRoleAssignmentBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE(
                _UniffiConverterTypeSetRoleEvent.read(buf),
            )
        if variant == 2:
            return TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE(
                _UniffiConverterTypeSetOwnerRoleEvent.read(buf),
            )
        if variant == 3:
            return TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE(
                _UniffiConverterTypeLockOwnerRoleEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_set_role_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeSetRoleEvent.write(value.value, buf)
        if value.is_set_owner_role_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeSetOwnerRoleEvent.write(value.value, buf)
        if value.is_lock_owner_role_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeLockOwnerRoleEvent.write(value.value, buf)


class TypedRoleAssignmentPackageEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedRoleAssignmentPackageEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class ROLE_ASSIGNMENT:
        value: "TypedRoleAssignmentBlueprintEvent"

        @typing.no_type_check
        def __init__(self, value: "TypedRoleAssignmentBlueprintEvent"):

            self.value = value

        def __str__(self):
            return "TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_role_assignment():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_role_assignment(self) -> bool:
        return isinstance(self, TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT = type(
    "TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT",
    (
        TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT,
        TypedRoleAssignmentPackageEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedRoleAssignmentPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT(
                _UniffiConverterTypeTypedRoleAssignmentBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_role_assignment():
            buf.write_i32(1)
            _UniffiConverterTypeTypedRoleAssignmentBlueprintEvent.write(
                value.value, buf
            )


class TypedTwoResourcePoolBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedTwoResourcePoolBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE:
        value: "TwoResourcePoolContributionEvent"

        @typing.no_type_check
        def __init__(self, value: "TwoResourcePoolContributionEvent"):

            self.value = value

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_two_resource_pool_contribution_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE:
        value: "TwoResourcePoolRedemptionEvent"

        @typing.no_type_check
        def __init__(self, value: "TwoResourcePoolRedemptionEvent"):

            self.value = value

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_two_resource_pool_redemption_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE:
        value: "TwoResourcePoolWithdrawEvent"

        @typing.no_type_check
        def __init__(self, value: "TwoResourcePoolWithdrawEvent"):

            self.value = value

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_two_resource_pool_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE:
        value: "TwoResourcePoolDepositEvent"

        @typing.no_type_check
        def __init__(self, value: "TwoResourcePoolDepositEvent"):

            self.value = value

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_two_resource_pool_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_two_resource_pool_contribution_event_value(self) -> bool:
        return isinstance(
            self,
            TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE,
        )

    def is_two_resource_pool_redemption_event_value(self) -> bool:
        return isinstance(
            self,
            TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE,
        )

    def is_two_resource_pool_withdraw_event_value(self) -> bool:
        return isinstance(
            self,
            TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE,
        )

    def is_two_resource_pool_deposit_event_value(self) -> bool:
        return isinstance(
            self,
            TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE,
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE = type(
    "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE",
    (
        TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE,
        TypedTwoResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE = type(
    "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE",
    (
        TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE,
        TypedTwoResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE = type(
    "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE",
    (
        TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE,
        TypedTwoResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE = type(
    "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE",
    (
        TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE,
        TypedTwoResourcePoolBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedTwoResourcePoolBlueprintEvent(
    _UniffiConverterRustBuffer
):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolContributionEvent.read(buf),
            )
        if variant == 2:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolRedemptionEvent.read(buf),
            )
        if variant == 3:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolWithdrawEvent.read(buf),
            )
        if variant == 4:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolDepositEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_two_resource_pool_contribution_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeTwoResourcePoolContributionEvent.write(value.value, buf)
        if value.is_two_resource_pool_redemption_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeTwoResourcePoolRedemptionEvent.write(value.value, buf)
        if value.is_two_resource_pool_withdraw_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeTwoResourcePoolWithdrawEvent.write(value.value, buf)
        if value.is_two_resource_pool_deposit_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeTwoResourcePoolDepositEvent.write(value.value, buf)


class TypedValidatorBlueprintEvent:
    def __init__(self):
        raise RuntimeError(
            "TypedValidatorBlueprintEvent cannot be instantiated directly"
        )

    # Each enum variant is a nested class of the enum itself.
    class REGISTER_VALIDATOR_EVENT_VALUE:
        value: "RegisterValidatorEvent"

        @typing.no_type_check
        def __init__(self, value: "RegisterValidatorEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_register_validator_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class UNREGISTER_VALIDATOR_EVENT_VALUE:
        value: "UnregisterValidatorEvent"

        @typing.no_type_check
        def __init__(self, value: "UnregisterValidatorEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_unregister_validator_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class STAKE_EVENT_VALUE:
        value: "StakeEvent"

        @typing.no_type_check
        def __init__(self, value: "StakeEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_stake_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class UNSTAKE_EVENT_VALUE:
        value: "UnstakeEvent"

        @typing.no_type_check
        def __init__(self, value: "UnstakeEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_unstake_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class CLAIM_XRD_EVENT_VALUE:
        value: "ClaimXrdEvent"

        @typing.no_type_check
        def __init__(self, value: "ClaimXrdEvent"):

            self.value = value

        def __str__(self):
            return (
                "TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE(value={})".format(
                    self.value
                )
            )

        def __eq__(self, other):
            if not other.is_claim_xrd_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE:
        value: "UpdateAcceptingStakeDelegationStateEvent"

        @typing.no_type_check
        def __init__(self, value: "UpdateAcceptingStakeDelegationStateEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_update_accepting_stake_delegation_state_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE:
        value: "ProtocolUpdateReadinessSignalEvent"

        @typing.no_type_check
        def __init__(self, value: "ProtocolUpdateReadinessSignalEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_protocol_update_readiness_signal_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class VALIDATOR_EMISSION_APPLIED_EVENT_VALUE:
        value: "ValidatorEmissionAppliedEvent"

        @typing.no_type_check
        def __init__(self, value: "ValidatorEmissionAppliedEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_validator_emission_applied_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    class VALIDATOR_REWARD_APPLIED_EVENT_VALUE:
        value: "ValidatorRewardAppliedEvent"

        @typing.no_type_check
        def __init__(self, value: "ValidatorRewardAppliedEvent"):

            self.value = value

        def __str__(self):
            return "TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE(value={})".format(
                self.value
            )

        def __eq__(self, other):
            if not other.is_validator_reward_applied_event_value():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_register_validator_event_value(self) -> bool:
        return isinstance(
            self, TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE
        )

    def is_unregister_validator_event_value(self) -> bool:
        return isinstance(
            self, TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE
        )

    def is_stake_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE)

    def is_unstake_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE)

    def is_claim_xrd_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE)

    def is_update_accepting_stake_delegation_state_event_value(self) -> bool:
        return isinstance(
            self,
            TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE,
        )

    def is_protocol_update_readiness_signal_event_value(self) -> bool:
        return isinstance(
            self,
            TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE,
        )

    def is_validator_emission_applied_event_value(self) -> bool:
        return isinstance(
            self, TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE
        )

    def is_validator_reward_applied_event_value(self) -> bool:
        return isinstance(
            self, TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE
        )


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore
TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE = type(
    "TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE",
    (
        TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE,
        TypedValidatorBlueprintEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeTypedValidatorBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE(
                _UniffiConverterTypeRegisterValidatorEvent.read(buf),
            )
        if variant == 2:
            return TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE(
                _UniffiConverterTypeUnregisterValidatorEvent.read(buf),
            )
        if variant == 3:
            return TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE(
                _UniffiConverterTypeStakeEvent.read(buf),
            )
        if variant == 4:
            return TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE(
                _UniffiConverterTypeUnstakeEvent.read(buf),
            )
        if variant == 5:
            return TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE(
                _UniffiConverterTypeClaimXrdEvent.read(buf),
            )
        if variant == 6:
            return TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE(
                _UniffiConverterTypeUpdateAcceptingStakeDelegationStateEvent.read(buf),
            )
        if variant == 7:
            return TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE(
                _UniffiConverterTypeProtocolUpdateReadinessSignalEvent.read(buf),
            )
        if variant == 8:
            return TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE(
                _UniffiConverterTypeValidatorEmissionAppliedEvent.read(buf),
            )
        if variant == 9:
            return TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE(
                _UniffiConverterTypeValidatorRewardAppliedEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_register_validator_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeRegisterValidatorEvent.write(value.value, buf)
        if value.is_unregister_validator_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeUnregisterValidatorEvent.write(value.value, buf)
        if value.is_stake_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeStakeEvent.write(value.value, buf)
        if value.is_unstake_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeUnstakeEvent.write(value.value, buf)
        if value.is_claim_xrd_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeClaimXrdEvent.write(value.value, buf)
        if value.is_update_accepting_stake_delegation_state_event_value():
            buf.write_i32(6)
            _UniffiConverterTypeUpdateAcceptingStakeDelegationStateEvent.write(
                value.value, buf
            )
        if value.is_protocol_update_readiness_signal_event_value():
            buf.write_i32(7)
            _UniffiConverterTypeProtocolUpdateReadinessSignalEvent.write(
                value.value, buf
            )
        if value.is_validator_emission_applied_event_value():
            buf.write_i32(8)
            _UniffiConverterTypeValidatorEmissionAppliedEvent.write(value.value, buf)
        if value.is_validator_reward_applied_event_value():
            buf.write_i32(9)
            _UniffiConverterTypeValidatorRewardAppliedEvent.write(value.value, buf)


class WithdrawResourceEvent:
    def __init__(self):
        raise RuntimeError("WithdrawResourceEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        value: "Decimal"

        @typing.no_type_check
        def __init__(self, value: "Decimal"):

            self.value = value

        def __str__(self):
            return "WithdrawResourceEvent.AMOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.value != other.value:
                return False
            return True

    class IDS:
        value: "typing.List[NonFungibleLocalId]"

        @typing.no_type_check
        def __init__(self, value: "typing.List[NonFungibleLocalId]"):

            self.value = value

        def __str__(self):
            return "WithdrawResourceEvent.IDS(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.value != other.value:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, WithdrawResourceEvent.AMOUNT)

    def is_ids(self) -> bool:
        return isinstance(self, WithdrawResourceEvent.IDS)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WithdrawResourceEvent.AMOUNT = type(
    "WithdrawResourceEvent.AMOUNT",
    (
        WithdrawResourceEvent.AMOUNT,
        WithdrawResourceEvent,
    ),
    {},
)  # type: ignore
WithdrawResourceEvent.IDS = type(
    "WithdrawResourceEvent.IDS",
    (
        WithdrawResourceEvent.IDS,
        WithdrawResourceEvent,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeWithdrawResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WithdrawResourceEvent.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return WithdrawResourceEvent.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)


class WithdrawStrategy:
    def __init__(self):
        raise RuntimeError("WithdrawStrategy cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EXACT:

        @typing.no_type_check
        def __init__(
            self,
        ):

            pass

        def __str__(self):
            return "WithdrawStrategy.EXACT()".format()

        def __eq__(self, other):
            if not other.is_exact():
                return False
            return True

    class ROUNDED:
        rounding_mode: "RoundingMode"

        @typing.no_type_check
        def __init__(self, rounding_mode: "RoundingMode"):

            self.rounding_mode = rounding_mode

        def __str__(self):
            return "WithdrawStrategy.ROUNDED(rounding_mode={})".format(
                self.rounding_mode
            )

        def __eq__(self, other):
            if not other.is_rounded():
                return False
            if self.rounding_mode != other.rounding_mode:
                return False
            return True

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_exact(self) -> bool:
        return isinstance(self, WithdrawStrategy.EXACT)

    def is_rounded(self) -> bool:
        return isinstance(self, WithdrawStrategy.ROUNDED)


# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WithdrawStrategy.EXACT = type(
    "WithdrawStrategy.EXACT",
    (
        WithdrawStrategy.EXACT,
        WithdrawStrategy,
    ),
    {},
)  # type: ignore
WithdrawStrategy.ROUNDED = type(
    "WithdrawStrategy.ROUNDED",
    (
        WithdrawStrategy.ROUNDED,
        WithdrawStrategy,
    ),
    {},
)  # type: ignore


class _UniffiConverterTypeWithdrawStrategy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WithdrawStrategy.EXACT()
        if variant == 2:
            return WithdrawStrategy.ROUNDED(
                _UniffiConverterTypeRoundingMode.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_exact():
            buf.write_i32(1)
        if value.is_rounded():
            buf.write_i32(2)
            _UniffiConverterTypeRoundingMode.write(value.rounding_mode, buf)


import threading


class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1

    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj


# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2


class _UniffiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))


# Declaration and _UniffiConverters for Signer Callback Interface


class Signer:
    def sign(self, hash: "Hash"):
        raise NotImplementedError

    def sign_to_signature(self, hash: "Hash"):
        raise NotImplementedError

    def sign_to_signature_with_public_key(self, hash: "Hash"):
        raise NotImplementedError

    def public_key(
        self,
    ):
        raise NotImplementedError


def py_foreignCallbackCallbackInterfaceSigner(
    handle, method, args_data, args_len, buf_ptr
):

    def invoke_sign(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.sign(_UniffiConverterTypeHash.read(args_stream))

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterBytes.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS

        return makeCallAndHandleReturn()

    def invoke_sign_to_signature(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.sign_to_signature(
                _UniffiConverterTypeHash.read(args_stream)
            )

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeSignature.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS

        return makeCallAndHandleReturn()

    def invoke_sign_to_signature_with_public_key(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.sign_to_signature_with_public_key(
                _UniffiConverterTypeHash.read(args_stream)
            )

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeSignatureWithPublicKey.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS

        return makeCallAndHandleReturn()

    def invoke_public_key(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.public_key()

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypePublicKey.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS

        return makeCallAndHandleReturn()

    cb = _UniffiConverterCallbackInterfaceSigner.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceSigner.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_sign(
                cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr
            )
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 2:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_sign_to_signature(
                cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr
            )
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 3:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_sign_to_signature_with_public_key(
                cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr
            )
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 4:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_public_key(
                cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr
            )
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR


# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceSigner = _UNIFFI_FOREIGN_CALLBACK_T(
    py_foreignCallbackCallbackInterfaceSigner
)
_rust_call(
    lambda err: _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer(
        foreignCallbackCallbackInterfaceSigner, err
    )
)

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceSigner = _UniffiConverterCallbackInterface(
    foreignCallbackCallbackInterfaceSigner
)


class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeAccessRule(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAccessRule.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAccessRule.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDecimal.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDecimal.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypePreciseDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePreciseDecimal.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePreciseDecimal.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeLockFeeModification(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLockFeeModification.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLockFeeModification.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeManifestBuilderAddressReservation(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeManifestBuilderAddressReservation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeManifestBuilderAddressReservation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeResourceManagerRole(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeResourceManagerRole.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeResourceManagerRole.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeSchema(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSchema.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSchema.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeMetadataValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMetadataValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMetadataValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterOptionalTypeResourceOrNonFungible(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeResourceOrNonFungible.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeResourceOrNonFungible.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class _UniffiConverterSequenceUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterUInt32.read(buf) for i in range(count)]


class _UniffiConverterSequenceInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterInt32.read(buf) for i in range(count)]


class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterUInt64.read(buf) for i in range(count)]


class _UniffiConverterSequenceInt64(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterInt64.read(buf) for i in range(count)]


class _UniffiConverterSequenceBool(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBool.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterBool.read(buf) for i in range(count)]


class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterString.read(buf) for i in range(count)]


class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterBytes.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeAddress.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDecimal.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeDecimal.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeNonFungibleGlobalId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNonFungibleGlobalId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeNonFungibleGlobalId.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeIndexedAssertion(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIndexedAssertion.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeIndexedAssertion.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeManifestBuilderBucket(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestBuilderBucket.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeManifestBuilderBucket.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeManifestBuilderMapEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestBuilderMapEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeManifestBuilderMapEntry.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeMapEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMapEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeMapEntry.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeTrackedPoolContribution(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTrackedPoolContribution.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTrackedPoolContribution.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeTrackedPoolRedemption(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTrackedPoolRedemption.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTrackedPoolRedemption.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeTrackedValidatorClaim(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTrackedValidatorClaim.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTrackedValidatorClaim.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeTrackedValidatorStake(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTrackedValidatorStake.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTrackedValidatorStake.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeTrackedValidatorUnstake(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTrackedValidatorUnstake.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTrackedValidatorUnstake.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeUnstakeDataEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUnstakeDataEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeUnstakeDataEntry.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeDetailedManifestClass(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDetailedManifestClass.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDetailedManifestClass.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeEntityType(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEntityType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeEntityType.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeInstruction(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeInstruction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeInstruction.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeManifestBuilderValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestBuilderValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeManifestBuilderValue.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeManifestClass(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestClass.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeManifestClass.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeManifestValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeManifestValue.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeNonFungibleLocalId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNonFungibleLocalId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeNonFungibleLocalId.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypePublicKey.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypePublicKeyHash(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKeyHash.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypePublicKeyHash.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeReservedInstruction(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeReservedInstruction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeReservedInstruction.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeResourceIndicator(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeResourceIndicator.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeResourceIndicator.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeResourceOrNonFungible(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeResourceOrNonFungible.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeResourceOrNonFungible.read(buf) for i in range(count)
        ]


class _UniffiConverterSequenceTypeResourceSpecifier(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeResourceSpecifier.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [_UniffiConverterTypeResourceSpecifier.read(buf) for i in range(count)]


class _UniffiConverterSequenceTypeSignatureWithPublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSignatureWithPublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSignatureWithPublicKey.read(buf) for i in range(count)
        ]


class _UniffiConverterMapStringTypeDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeDecimal.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeDecimal.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringTypeMetadataInitEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeMetadataInitEntry.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeMetadataInitEntry.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringTypeValidatorInfo(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeValidatorInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeValidatorInfo.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringTypeAccountDefaultDepositRule(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeAccountDefaultDepositRule.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeAccountDefaultDepositRule.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringTypeResourcePreferenceUpdate(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeResourcePreferenceUpdate.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeResourcePreferenceUpdate.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringTypeResourceSpecifier(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeResourceSpecifier.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeResourceSpecifier.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringOptionalTypeAccessRule(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterOptionalTypeAccessRule.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterOptionalTypeAccessRule.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringOptionalTypeMetadataValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterOptionalTypeMetadataValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterOptionalTypeMetadataValue.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringSequenceTypeResourceIndicator(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeResourceIndicator.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeResourceIndicator.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringSequenceTypeResourceOrNonFungible(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeResourceOrNonFungible.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeResourceOrNonFungible.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringSequenceTypeResourceSpecifier(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeResourceSpecifier.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeResourceSpecifier.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringMapStringTypeResourcePreferenceUpdate(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringTypeResourcePreferenceUpdate.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringTypeResourcePreferenceUpdate.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapStringMapStringOptionalTypeMetadataValue(
    _UniffiConverterRustBuffer
):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringOptionalTypeMetadataValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringOptionalTypeMetadataValue.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapTypePublicKeyFingerprintBytes(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterTypePublicKeyFingerprint.write(key, buf)
            _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypePublicKeyFingerprint.read(buf)
            val = _UniffiConverterBytes.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapTypeCurveTypeTypeDecryptorsByCurve(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterTypeCurveType.write(key, buf)
            _UniffiConverterTypeDecryptorsByCurve.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeCurveType.read(buf)
            val = _UniffiConverterTypeDecryptorsByCurve.read(buf)
            d[key] = val
        return d


class _UniffiConverterMapTypeEntityTypeSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for key, value in items.items():
            _UniffiConverterTypeEntityType.write(key, buf)
            _UniffiConverterSequenceTypeAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeEntityType.read(buf)
            val = _UniffiConverterSequenceTypeAddress.read(buf)
            d[key] = val
        return d


# Type alias
HashableBytes = bytes


class _UniffiConverterTypeHashableBytes:
    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterBytes.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterBytes.lower(value)


def derive_olympia_account_address_from_public_key(
    public_key: "PublicKey", olympia_network: "OlympiaNetwork"
) -> "OlympiaAddress":

    return _UniffiConverterTypeOlympiaAddress.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterTypeOlympiaNetwork.lower(olympia_network),
        )
    )


def derive_public_key_from_olympia_account_address(
    olympia_resource_address: "OlympiaAddress",
) -> "PublicKey":

    return _UniffiConverterTypePublicKey.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address,
            _UniffiConverterTypeOlympiaAddress.lower(olympia_resource_address),
        )
    )


def derive_resource_address_from_olympia_resource_address(
    olympia_resource_address: "OlympiaAddress", network_id: "int"
) -> "Address":

    return _UniffiConverterTypeAddress.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address,
            _UniffiConverterTypeOlympiaAddress.lower(olympia_resource_address),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def derive_virtual_account_address_from_olympia_account_address(
    olympia_account_address: "OlympiaAddress", network_id: "int"
) -> "Address":

    return _UniffiConverterTypeAddress.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address,
            _UniffiConverterTypeOlympiaAddress.lower(olympia_account_address),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def derive_virtual_account_address_from_public_key(
    public_key: "PublicKey", network_id: "int"
) -> "Address":

    return _UniffiConverterTypeAddress.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def derive_virtual_global_caller_non_fungible_global_id_from_component_address(
    component_address: "Address", network_id: "int"
) -> "NonFungibleGlobalId":

    return _UniffiConverterTypeNonFungibleGlobalId.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_global_caller_non_fungible_global_id_from_component_address,
            _UniffiConverterTypeAddress.lower(component_address),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def derive_virtual_identity_address_from_public_key(
    public_key: "PublicKey", network_id: "int"
) -> "Address":

    return _UniffiConverterTypeAddress.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address(
    package_address: "Address", network_id: "int"
) -> "NonFungibleGlobalId":

    return _UniffiConverterTypeNonFungibleGlobalId.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address,
            _UniffiConverterTypeAddress.lower(package_address),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def derive_virtual_signature_non_fungible_global_id_from_public_key(
    public_key: "PublicKey", network_id: "int"
) -> "NonFungibleGlobalId":

    return _UniffiConverterTypeNonFungibleGlobalId.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key,
            _UniffiConverterTypePublicKey.lower(public_key),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def get_build_information() -> "BuildInformation":
    return _UniffiConverterTypeBuildInformation.lift(
        _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_build_information,
        )
    )


def get_hash(data: "bytes") -> "Hash":

    return _UniffiConverterTypeHash.lift(
        _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_hash,
            _UniffiConverterBytes.lower(data),
        )
    )


def get_known_addresses(network_id: "int") -> "KnownAddresses":

    return _UniffiConverterTypeKnownAddresses.lift(
        _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_get_known_addresses,
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def manifest_sbor_decode_to_string_representation(
    bytes: "bytes",
    representation: "ManifestSborStringRepresentation",
    network_id: "int",
    schema: "typing.Optional[Schema]",
) -> "str":

    return _UniffiConverterString.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation,
            _UniffiConverterBytes.lower(bytes),
            _UniffiConverterTypeManifestSborStringRepresentation.lower(representation),
            _UniffiConverterUInt8.lower(network_id),
            _UniffiConverterOptionalTypeSchema.lower(schema),
        )
    )


def metadata_sbor_decode(bytes: "bytes", network_id: "int") -> "MetadataValue":

    return _UniffiConverterTypeMetadataValue.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode,
            _UniffiConverterBytes.lower(bytes),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def metadata_sbor_encode(value: "MetadataValue") -> "bytes":

    return _UniffiConverterBytes.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode,
            _UniffiConverterTypeMetadataValue.lower(value),
        )
    )


def non_fungible_local_id_as_str(value: "NonFungibleLocalId") -> "str":

    return _UniffiConverterString.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str,
            _UniffiConverterTypeNonFungibleLocalId.lower(value),
        )
    )


def non_fungible_local_id_from_str(string: "str") -> "NonFungibleLocalId":

    return _UniffiConverterTypeNonFungibleLocalId.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str,
            _UniffiConverterString.lower(string),
        )
    )


def non_fungible_local_id_sbor_decode(bytes: "bytes") -> "NonFungibleLocalId":

    return _UniffiConverterTypeNonFungibleLocalId.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode,
            _UniffiConverterBytes.lower(bytes),
        )
    )


def non_fungible_local_id_sbor_encode(value: "NonFungibleLocalId") -> "bytes":

    return _UniffiConverterBytes.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode,
            _UniffiConverterTypeNonFungibleLocalId.lower(value),
        )
    )


def public_key_fingerprint_from_vec(bytes: "bytes") -> "PublicKeyFingerprint":

    return _UniffiConverterTypePublicKeyFingerprint.lift(
        _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_from_vec,
            _UniffiConverterBytes.lower(bytes),
        )
    )


def public_key_fingerprint_to_vec(value: "PublicKeyFingerprint") -> "bytes":

    return _UniffiConverterBytes.lift(
        _rust_call(
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_public_key_fingerprint_to_vec,
            _UniffiConverterTypePublicKeyFingerprint.lower(value),
        )
    )


def sbor_decode_to_string_representation(
    bytes: "bytes",
    representation: "SerializationMode",
    network_id: "int",
    schema: "typing.Optional[Schema]",
) -> "str":

    return _UniffiConverterString.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation,
            _UniffiConverterBytes.lower(bytes),
            _UniffiConverterTypeSerializationMode.lower(representation),
            _UniffiConverterUInt8.lower(network_id),
            _UniffiConverterOptionalTypeSchema.lower(schema),
        )
    )


def sbor_decode_to_typed_native_event(
    event_type_identifier: "EventTypeIdentifier", event_data: "bytes", network_id: "int"
) -> "TypedNativeEvent":

    return _UniffiConverterTypeTypedNativeEvent.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event,
            _UniffiConverterTypeEventTypeIdentifier.lower(event_type_identifier),
            _UniffiConverterBytes.lower(event_data),
            _UniffiConverterUInt8.lower(network_id),
        )
    )


def scrypto_sbor_decode_to_string_representation(
    bytes: "bytes",
    representation: "SerializationMode",
    network_id: "int",
    schema: "typing.Optional[Schema]",
) -> "str":

    return _UniffiConverterString.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation,
            _UniffiConverterBytes.lower(bytes),
            _UniffiConverterTypeSerializationMode.lower(representation),
            _UniffiConverterUInt8.lower(network_id),
            _UniffiConverterOptionalTypeSchema.lower(schema),
        )
    )


def scrypto_sbor_encode_string_representation(
    representation: "ScryptoSborString",
) -> "bytes":

    return _UniffiConverterBytes.lift(
        _rust_call_with_error(
            _UniffiConverterTypeRadixEngineToolkitError,
            _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation,
            _UniffiConverterTypeScryptoSborString.lower(representation),
        )
    )


def test_panic(message: "str"):

    _rust_call_with_error(
        _UniffiConverterTypeRadixEngineToolkitError,
        _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic,
        _UniffiConverterString.lower(message),
    )


__all__ = [
    "InternalError",
    "AccountDefaultDepositRule",
    "AccountDepositEvent",
    "AccountRejectedDepositEvent",
    "AccountWithdrawEvent",
    "Assertion",
    "Curve",
    "CurveType",
    "DecryptorsByCurve",
    "DependencyInformation",
    "DepositResourceEvent",
    "DetailedManifestClass",
    "Emitter",
    "EntityType",
    "FungibleResourceIndicator",
    "Instruction",
    "LocalTypeId",
    "ManifestAddress",
    "ManifestBuilderAddress",
    "ManifestBuilderValue",
    "ManifestBuilderValueKind",
    "ManifestClass",
    "ManifestExpression",
    "ManifestSborStringRepresentation",
    "ManifestValue",
    "ManifestValueKind",
    "Message",
    "MessageContent",
    "MetadataValue",
    "ModuleId",
    "NameRecordError",
    "NonFungibleLocalId",
    "NonFungibleResourceIndicator",
    "OlympiaNetwork",
    "Operation",
    "OwnerRole",
    "Proposer",
    "PublicKey",
    "PublicKeyHash",
    "RadixEngineToolkitError",
    "RecallResourceEvent",
    "ReservedInstruction",
    "ResourceIndicator",
    "ResourceOrNonFungible",
    "ResourcePreference",
    "ResourcePreferenceUpdate",
    "ResourceSpecifier",
    "Role",
    "RoundingMode",
    "RoyaltyAmount",
    "ScryptoSborString",
    "SerializationMode",
    "Signature",
    "SignatureWithPublicKey",
    "TypedAccessControllerBlueprintEvent",
    "TypedAccessControllerPackageEvent",
    "TypedAccountBlueprintEvent",
    "TypedAccountLockerBlueprintEvent",
    "TypedAccountPackageEvent",
    "TypedConsensusManagerBlueprintEvent",
    "TypedConsensusManagerPackageEvent",
    "TypedFungibleResourceManagerBlueprintEvent",
    "TypedFungibleVaultBlueprintEvent",
    "TypedLockerPackageEvent",
    "TypedMetadataBlueprintEvent",
    "TypedMetadataPackageEvent",
    "TypedMultiResourcePoolBlueprintEvent",
    "TypedNativeEvent",
    "TypedNonFungibleResourceManagerBlueprintEvent",
    "TypedNonFungibleVaultBlueprintEvent",
    "TypedOneResourcePoolBlueprintEvent",
    "TypedPoolPackageEvent",
    "TypedResourcePackageEvent",
    "TypedRoleAssignmentBlueprintEvent",
    "TypedRoleAssignmentPackageEvent",
    "TypedTwoResourcePoolBlueprintEvent",
    "TypedValidatorBlueprintEvent",
    "WithdrawResourceEvent",
    "WithdrawStrategy",
    "AccountAddAuthorizedDepositorEvent",
    "AccountRemoveAuthorizedDepositorEvent",
    "AccountRemoveResourcePreferenceEvent",
    "AccountSetDefaultDepositRuleEvent",
    "AccountSetResourcePreferenceEvent",
    "BadgeWithdrawEvent",
    "BuildInformation",
    "BurnFungibleResourceEvent",
    "BurnNonFungibleResourceEvent",
    "CancelBadgeWithdrawAttemptEvent",
    "CancelRecoveryProposalEvent",
    "ClaimEvent",
    "ClaimXrdEvent",
    "ComponentAddresses",
    "DepositRecoveryXrdEvent",
    "Ed25519PublicKey",
    "EncryptedMessage",
    "EpochChangeEvent",
    "EventTypeIdentifier",
    "ExecutionSummary",
    "FeeLocks",
    "FeeSummary",
    "FungibleResourceRoles",
    "FungibleVaultDepositEvent",
    "FungibleVaultLockFeeEvent",
    "FungibleVaultPayFeeEvent",
    "FungibleVaultRecallEvent",
    "FungibleVaultWithdrawEvent",
    "IndexedAssertion",
    "InitiateBadgeWithdrawAttemptEvent",
    "InitiateRecoveryEvent",
    "KnownAddresses",
    "LockFeeModification",
    "LockOwnerRoleEvent",
    "LockPrimaryRoleEvent",
    "LockRoleEvent",
    "ManifestAddressReservation",
    "ManifestBlobRef",
    "ManifestBucket",
    "ManifestBuilderAddressReservation",
    "ManifestBuilderBucket",
    "ManifestBuilderMapEntry",
    "ManifestBuilderNamedAddress",
    "ManifestBuilderProof",
    "ManifestProof",
    "ManifestSummary",
    "MapEntry",
    "MetadataInitEntry",
    "MetadataModuleConfig",
    "MintFungibleResourceEvent",
    "MintNonFungibleResourceEvent",
    "MultiResourcePoolContributionEvent",
    "MultiResourcePoolDepositEvent",
    "MultiResourcePoolRedemptionEvent",
    "MultiResourcePoolWithdrawEvent",
    "NewEntities",
    "NonFungibleVaultDepositEvent",
    "NonFungibleVaultRecallEvent",
    "NonFungibleVaultWithdrawEvent",
    "OneResourcePoolContributionEvent",
    "OneResourcePoolDepositEvent",
    "OneResourcePoolRedemptionEvent",
    "OneResourcePoolWithdrawEvent",
    "PackageAddresses",
    "PlainTextMessage",
    "PredictedDecimal",
    "PredictedNonFungibleIds",
    "ProtocolUpdateReadinessSignalEvent",
    "PublicKeyFingerprint",
    "RecoverEvent",
    "RecoveryProposal",
    "RegisterValidatorEvent",
    "RemoveMetadataEvent",
    "ResourceAddresses",
    "ResourceManagerRole",
    "RoundChangeEvent",
    "RuleSet",
    "RuleSetUpdateEvent",
    "Schema",
    "Secp256k1PublicKey",
    "SecurityStructureRole",
    "SetAndLockRoleEvent",
    "SetMetadataEvent",
    "SetOwnerRoleEvent",
    "SetRoleEvent",
    "StakeEvent",
    "StopTimedRecoveryEvent",
    "StoreEvent",
    "TrackedPoolContribution",
    "TrackedPoolRedemption",
    "TrackedValidatorClaim",
    "TrackedValidatorStake",
    "TrackedValidatorUnstake",
    "TransactionHeader",
    "TransactionManifestModifications",
    "TwoResourcePoolContributionEvent",
    "TwoResourcePoolDepositEvent",
    "TwoResourcePoolRedemptionEvent",
    "TwoResourcePoolWithdrawEvent",
    "UnlockPrimaryRoleEvent",
    "UnregisterValidatorEvent",
    "UnstakeData",
    "UnstakeDataEntry",
    "UnstakeEvent",
    "UpdateAcceptingStakeDelegationStateEvent",
    "ValidatorEmissionAppliedEvent",
    "ValidatorInfo",
    "ValidatorRewardAppliedEvent",
    "VaultCreationEvent",
    "WithdrawRecoveryXrdEvent",
    "derive_olympia_account_address_from_public_key",
    "derive_public_key_from_olympia_account_address",
    "derive_resource_address_from_olympia_resource_address",
    "derive_virtual_account_address_from_olympia_account_address",
    "derive_virtual_account_address_from_public_key",
    "derive_virtual_global_caller_non_fungible_global_id_from_component_address",
    "derive_virtual_identity_address_from_public_key",
    "derive_virtual_package_of_direct_caller_non_fungible_global_id_from_component_address",
    "derive_virtual_signature_non_fungible_global_id_from_public_key",
    "get_build_information",
    "get_hash",
    "get_known_addresses",
    "manifest_sbor_decode_to_string_representation",
    "metadata_sbor_decode",
    "metadata_sbor_encode",
    "non_fungible_local_id_as_str",
    "non_fungible_local_id_from_str",
    "non_fungible_local_id_sbor_decode",
    "non_fungible_local_id_sbor_encode",
    "public_key_fingerprint_from_vec",
    "public_key_fingerprint_to_vec",
    "sbor_decode_to_string_representation",
    "sbor_decode_to_typed_native_event",
    "scrypto_sbor_decode_to_string_representation",
    "scrypto_sbor_encode_string_representation",
    "test_panic",
    "AccessRule",
    "Address",
    "Decimal",
    "Hash",
    "Instructions",
    "Intent",
    "ManifestBuilder",
    "MessageValidationConfig",
    "NonFungibleGlobalId",
    "NotarizedTransaction",
    "OlympiaAddress",
    "PreciseDecimal",
    "PrivateKey",
    "SignedIntent",
    "TransactionBuilder",
    "TransactionBuilderHeaderStep",
    "TransactionBuilderIntentSignaturesStep",
    "TransactionBuilderMessageStep",
    "TransactionHash",
    "TransactionManifest",
    "ValidationConfig",
    "Signer",
]
