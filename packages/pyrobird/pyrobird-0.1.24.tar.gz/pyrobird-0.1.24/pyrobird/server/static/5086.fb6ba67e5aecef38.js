"use strict";(self.webpackChunkfirebird=self.webpackChunkfirebird||[]).push([[5086],{5086:(D,y,c)=>{c.r(y),c.d(y,{TEfficiencyPainter:()=>E});var A=c(467),l=c(6998),M=c(6224),P=c(4693),p=c(230),C=c(4571),L=c(8977);const T=(0,l.BIT)(14),x=(0,l.BIT)(15),B=(0,l.BIT)(17),w=(0,l.BIT)(18),m=(_,t)=>_.fBeta_bin_params.length>t?_.fBeta_bin_params[t].first:_.fBeta_alpha,u=(_,t)=>_.fBeta_bin_params.length>t?_.fBeta_bin_params[t].second:_.fBeta_beta;class E extends M.JW{getEfficiency(t,i){const r=t.fTotalHistogram.fArray[i],n=t.fPassedHistogram.fArray[i];if(t.TestBit(T)){const e=t.TestBit(B)?m(t,i):t.fBeta_alpha,f=t.TestBit(B)?u(t,i):t.fBeta_beta;let o,h;if(t.TestBit(w)){const d=r,O=t.fTotalHistogram.fSumw2?t.fTotalHistogram.fSumw2[i]:Math.abs(r);if(O<=0)return n/d;const H=d/O;o=n*H+e,h=(d-n)*H+f}else o=n+e,h=r-n+f;return t.TestBit(x)?((e,f)=>{if(e<=0||f<=0)return 0;if(e<=1||f<=1){if(e<f)return 0;if(e>f)return 1;if(e===f)return.5}return(e-1)/(e+f-2)})(o,h):((e,f)=>e<=0||f<=0?0:e/(e+f))(o,h)}return r?n/r:0}getEfficiencyErrorLow(t,i,a){const s=t.fTotalHistogram.fArray[i],r=t.fPassedHistogram.fArray[i];let n=0,e=0;return t.TestBit(T)&&(n=t.TestBit(B)?m(t,i):t.fBeta_alpha,e=t.TestBit(B)?u(t,i):t.fBeta_beta),a-this.fBoundary(s,r,t.fConfLevel,!1,n,e)}getEfficiencyErrorUp(t,i,a){const s=t.fTotalHistogram.fArray[i],r=t.fPassedHistogram.fArray[i];let n=0,e=0;return t.TestBit(T)&&(n=t.TestBit(B)?m(t,i):t.fBeta_alpha,e=t.TestBit(B)?u(t,i):t.fBeta_beta),this.fBoundary(s,r,t.fConfLevel,!0,n,e)-a}copyAttributes(t,i){["fLineColor","fLineStyle","fLineWidth","fFillColor","fFillStyle","fMarkerColor","fMarkerStyle","fMarkerSize"].forEach(a=>{t[a]=i[a]})}createGraph(){const t=(0,l.create)(P.clTGraphAsymmErrors);return t.fName="eff_graph",t}createHisto(t){const s=(0,l.createHistogram)(l.clTH2F,t.fTotalHistogram.fXaxis.fNbins,t.fTotalHistogram.fYaxis.fNbins);return Object.assign(s.fXaxis,t.fTotalHistogram.fXaxis),Object.assign(s.fYaxis,t.fTotalHistogram.fYaxis),s.fName="eff_histo",s}fillGraph(t,i){const a=this.getObject(),s=a.fTotalHistogram.fXaxis,r=s.fNbins,n=i.indexOf("e0")>=0;for(let e=0,f=0;e<r;++e){if(!n&&0===a.fTotalHistogram.getBinContent(e+1))continue;const o=this.getEfficiency(a,e+1);t.fX[f]=s.GetBinCenter(e+1),t.fY[f]=o,t.fEXlow[f]=s.GetBinCenter(e+1)-s.GetBinLowEdge(e+1),t.fEXhigh[f]=s.GetBinLowEdge(e+2)-s.GetBinCenter(e+1),t.fEYlow[f]=this.getEfficiencyErrorLow(a,e+1,o),t.fEYhigh[f]=this.getEfficiencyErrorUp(a,e+1,o),t.fNpoints=++f}t.fTitle=a.fTitle,this.copyAttributes(t,a)}fillHisto(t){const i=this.getObject(),a=t.fXaxis.fNbins,s=t.fYaxis.fNbins;for(let r=0;r<a+2;++r)for(let n=0;n<s+2;++n){const e=t.getBin(r,n),f=this.getEfficiency(i,e);t.fArray[e]=f}t.fTitle=i.fTitle,t.fBits=t.fBits|l.kNoStats,this.copyAttributes(t,i)}drawFunction(t){const i=this.getObject();return!i?.fFunctions||t>=i.fFunctions.arr.length?this:p.TF1Painter.draw(this.getDom(),i.fFunctions.arr[t],i.fFunctions.opt[t]).then(()=>this.drawFunction(t+1))}static draw(t,i,a){return(0,A.A)(function*(){if(!i||!i.fTotalHistogram)return null;(!a||!(0,l.isStr)(a))&&(a=""),a=a.toLowerCase();let s=0;if(0===i.fTotalHistogram._typename.indexOf(l.clTH1))s=1;else{if(0!==i.fTotalHistogram._typename.indexOf(l.clTH2))return null;s=2}const r=new E(t,i);let n;if(r.ndim=s,r.fBoundary=(0,L.getTEfficiencyBoundaryFunc)(i.fStatisticOption,i.TestBit(T)),1===s){a||(a="ap"),a.indexOf("same")<0&&a.indexOf("a")<0&&(a+="a"),a.indexOf("p")<0&&(a+="p");const e=r.createGraph(i);r.fillGraph(e,a),n=P.TGraphPainter.draw(t,e,a)}else{a||(a="col");const e=r.createHisto(i);r.fillHisto(e,a),n=C.AJ.draw(t,e,a)}return n.then(()=>(r.addToPadPrimitives(),r.drawFunction(0)))})()}}}}]);