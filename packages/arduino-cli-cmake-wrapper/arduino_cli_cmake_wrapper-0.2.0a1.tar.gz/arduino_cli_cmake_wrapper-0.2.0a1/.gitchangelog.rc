#
# ``ignore_regexps`` is a line of regexps
#
# Any commit having its full commit message matching any regexp listed here
# will be ignored and won't be reported in the changelog.
#
ignore_regexps = [
    r'@minor', r'!minor',
    r'@cosmetic', r'!cosmetic',
    r'@refactor', r'!refactor',
    r'@wip', r'!wip',
    r'^([cC]hg|[fF]ix|[nN]ew)\s*:\s*[p|P]kg:',
    r'^([cC]hg|[fF]ix|[nN]ew)\s*:\s*[d|D]ev:',
    r'^üéâ*(.{1,4}\s*:)?\s*([fF]irst|[iI]nitial) ([Cc]ommit|[Ff]ile).?\s*$',
    r'[cC]hangelog',
    r'([pP][eE][pP]8|[pP][eE][pP] 8)',
    r'^Bump [vV]ersion',
    r'^$',  ## ignore commits with empty messages
]


# ``section_regexps`` is a list of 2-tuples associating a string label and a
# list of regexp
#
# Commit messages will be classified in sections thanks to this. Section
# titles are the label, and a commit is classified under this section if any
# of the regexps associated is matching.

section_regexps = [
    ('‚ú® New', [
        r'^(‚ú®|.{0,2}([aA]dd|[nN]ew|[eE]xample|[sS]keleton|[iI]mplement|[cC]reate))',
     ]),
    ('üöö Changes', [
        r'^.{0,4}(üöö|‚ûñ|[uU]pdate|[eE]nhance|[eE]nchance|[rR]ename|[rR]emove|[mM]ove|[aA]djust)',
     ]),
    ('üêõ Bugs', [
        r'^(üêõ|^.{0,4}[fF]ix|^.{0,2}[bB]ug)',
     ]),

    ('üöëÔ∏è Hotfixes', [
        r'^üöëÔ∏è',
     ]),

    ('üéâ Other', None ## Match all lines
     ),

]


# ``body_process`` is a callable
#
# This callable will be given the original body and result will
# be used in the changelog.

def body_process(*args, **kwargs):
    """Don't send the body to the changelog."""
    return None

# ``subject_process`` is a callable
#
# This callable will be given the original subject and result will
# be used in the changelog.
#
# Available constructs are those listed in ``body_process`` doc.

subject_process = (strip |
    ReSub(r'^([cC]hg|[fF]ix|[nN]ew)\s*:\s*((dev|use?r|pkg|test|doc)\s*:\s*)?([^\n@]*)(@[a-z]+\s+)*$', r'\4') |
    SetIfEmpty("No commit message.") | ucfirst | final_dot)


# ``tag_filter_regexp`` is a regexp
#
# Tags that will be used for the changelog must match this regexp.

tag_filter_regexp = r'^v[0-9]+\.[0-9]+(\.[0-9]+)?$'


# ``unreleased_version_label`` is a string or a callable that outputs a string
#
# This label will be used as the changelog Title of the last set of changes
# between last valid tag and HEAD if any.

unreleased_version_label = "(unreleased)"


# ``output_engine`` is a callable
output_engine = rest_py


# ``include_merge`` is a boolean
#
# This option tells git-log whether to include merge commits in the log.
# The default is to include them.
include_merge = False


# ``log_encoding`` is a string identifier
#
# This option tells gitchangelog what encoding is outputed by ``git log``.
# The default is to be clever about it: it checks ``git config`` for
# ``i18n.logOutputEncoding``, and if not found will default to git's own
# default: ``utf-8``.

#log_encoding = 'utf-8'


# ``publish`` is a callable
#
# Sets what ``gitchangelog`` should do with the output generated by
# the output engine. ``publish`` is a callable taking one argument
# that is an interator on lines from the output engine.
#
# Some helper callable are provided:
#
# Available choices are:
#
#   - stdout
#
#        Outputs directly to standard output
#        (This is the default)
#
#   - FileInsertAtFirstRegexMatch(file, pattern, idx=lamda m: m.start())
#
#        Creates a callable that will parse given file for the given
#        regex pattern and will insert the output in the file.
#        ``idx`` is a callable that receive the matching object and
#        must return a integer index point where to insert the
#        the output in the file. Default is to return the position of
#        the start of the matched string.
#
#   - FileRegexSubst(file, pattern, replace, flags)
#
#        Apply a replace inplace in the given file. Your regex pattern must
#        take care of everything and might be more complex. Check the README
#        for a complete copy-pastable example.

# publish = FileInsertIntoFirstRegexMatch(
#     "CHANGELOG.rst",
#     r'/(?P<rev>[0-9]+\.[0-9]+(\.[0-9]+)?)\s+\([0-9]+-[0-9]{2}-[0-9]{2}\)\n--+\n/',
#     idx=lambda m: m.start(1)
# )
# publish = stdout

def publish(content):
    with open("CHANGELOG.rst", 'w') as fh:
        for chunk in content:
            fh.write(chunk)


# ``revs`` is a list of callable or a list of string
#
# callable will be called to resolve as strings and allow dynamical
# computation of these. The result will be used as revisions for
# gitchangelog (as if directly stated on the command line). This allows
# to filter exaclty which commits will be read by gitchangelog.
#
# To get a full documentation on the format of these strings, please
# refer to the ``git rev-list`` arguments. There are many examples.
#
# Using callables is especially useful, for instance, if you
# are using gitchangelog to generate incrementally your changelog.
#
# Some helpers are provided, you can use them::
#
#   - FileFirstRegexMatch(file, pattern): will return a callable that will
#     return the first string match for the given pattern in the given file.
#     If you use named sub-patterns in your regex pattern, it'll output only
#     the string matching the regex pattern named "rev".
#
#   - Caret(rev): will return the rev prefixed by a "^", which is a
#     way to remove the given revision and all its ancestor.
#
# Please note that if you provide a rev-list on the command line, it'll
# replace this value (which will then be ignored).
#
# If empty, then ``gitchangelog`` will act as it had to generate a full
# changelog.
#
# The default is to use all commits to make the changelog.

#revs = ["^1.0.3", ]
#revs = [
#    Caret(
#        FileFirstRegexMatch(
#            "CHANGELOG.rst",
#            r"(?P<rev>[0-9]+\.[0-9]+(\.[0-9]+)?)\s+\([0-9]+-[0-9]{2}-[0-9]{2}\)\n--+\n")),
#    "HEAD"
#]
# revs = ['^v0.1.0', ]
