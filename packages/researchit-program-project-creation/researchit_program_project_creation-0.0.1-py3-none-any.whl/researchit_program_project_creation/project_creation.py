# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_project_creation.ipynb.

# %% auto 0
__all__ = ['check_requirements', 'create_project_folder_and_subfolders', 'cli', 'create_project_metadata', 'process_row',
           'process_samplesheet']

# %% ../nbs/02_project_creation.ipynb 3
# standard libs
import os
import re

# Common to template
# add into settings.ini, requirements, package name is python-dotenv, for conda build ensure `conda config --add channels conda-forge`
import dotenv  # for loading config from .env files, https://pypi.org/project/python-dotenv/
import envyaml  # Allows to loads env vars into a yaml file, https://github.com/thesimj/envyaml
import fastcore  # To add functionality related to nbdev development, https://github.com/fastai/fastcore/
from fastcore import (
    test,
)
from fastcore.script import (
    call_parse,
)  # for @call_parse, https://fastcore.fast.ai/script
import json  # for nicely printing json and yaml

# import functions from core module (optional, but most likely needed).
from . import core

# Project specific libraries
import pandas as pd
import grp  # for checking if linux groups exist

# %% ../nbs/02_project_creation.ipynb 7
def check_requirements(linux_group_modifiers, project_id, folder_path) -> bool:
    """Check if all requirements are satisfied"""
    # create the names of the group to check based on modifiers and project_id
    #     linux_group_modifiers:
    #         prefix: dpssi_group_
    #         read_postfix: _r
    #         write_postfix: _w

    project_groups = [
        linux_group_modifiers["prefix"]
        + project_id
        + linux_group_modifiers["read_postfix"],
        linux_group_modifiers["prefix"]
        + project_id
        + linux_group_modifiers["write_postfix"],
    ]

    # check that groups exist on the linux computer and that current user can modify
    for group in project_groups:
        try:
            grp.getgrnam(group)
        except KeyError:
            print(f"Group {group} does not exist on this computer.")
            return False

    # check if the folder already exists
    # TODO: allow existing folder to be used and update missing things or details
    if os.path.exists(folder_path):
        print(f"Folder {folder_path} already exists.")
        return False

# %% ../nbs/02_project_creation.ipynb 8
def create_project_folder_and_subfolders(
    locked_resources,
    read_group,
    write_group,
    project_dir,
    project_name,
    read_permission=0o2750,
    write_permission=0o2775,
) -> str:
    """
    Function to create a project folder based on the project name and the project directory.
    """
    # Make the project folder root
    # create the project folder in the project directory with the project name and set to the read group with read permissions
    project_folder = os.path.join(project_dir, project_name)
    os.mkdir(project_folder)
    # ensure the group is set to the read group
    os.chown(project_folder, -1, grp.getgrnam(read_group).gr_gid)
    # ensure the permissions are set to read only
    os.chmod(project_folder, read_permission)

    # Make the subfolders
    # we need a proj folder, this folder will belong to the write group and have write permissions
    proj_folder = os.path.join(project_folder, "proj")
    os.mkdir(proj_folder)
    os.chown(proj_folder, -1, grp.getgrnam(write_group).gr_gid)
    os.chmod(proj_folder, write_permission)

    # Structure under proj is as follows:
    # proj:
    #     Users:
    #     Info:
    #     Resources:
    #     Tools:
    #       git.repositories:
    #       conda_envs:
    #     Scratch:
    #     Analysis:
    #     Results:

    # create the subfolders and their subfolders
    subfolders = [
        "Users",
        "Info",
        "Resources",
        "Tools",
        "Scratch",
        "Analysis",
        "Results",
    ]
    for subfolder in subfolders:
        subfolder_path = os.path.join(proj_folder, subfolder)
        os.mkdir(subfolder_path)
        os.chown(subfolder_path, -1, grp.getgrnam(write_group).gr_gid)
        os.chmod(subfolder_path, write_permission)

        # create subfolders for Tools
        if subfolder == "Tools":
            tools_subfolders = ["git.repositories", "conda_envs"]
            for tools_subfolder in tools_subfolders:
                tools_subfolder_path = os.path.join(subfolder_path, tools_subfolder)
                os.mkdir(tools_subfolder_path)
                os.chown(tools_subfolder_path, -1, grp.getgrnam(write_group).gr_gid)
                os.chmod(tools_subfolder_path, write_permission)

    # check locked_resources, it is created in the root folder, if it's TRUE then create Resources as a folder with read_permissions, if it's False create a symlink to proj/Resources
    if locked_resources:
        resources_folder = os.path.join(project_folder, "Resources")
        os.mkdir(resources_folder)
        os.chown(resources_folder, -1, grp.getgrnam(read_group).gr_gid)
        os.chmod(resources_folder, read_permission)
    else:
        resources_folder = os.path.join(project_folder, "Resources")
        os.symlink(f"{proj_folder}/Resources", resources_folder)

# %% ../nbs/02_project_creation.ipynb 9
from fastcore.script import call_parse


@call_parse
def cli(
    read_group: str = None,  # the group that has read permissions
    write_group: str = None,  # the group that has write permissions
    project_dir: str = None,  # the directory where the project will be created
    project_name: str = None,  # the name of the project
    locked_resources: bool = False,  # if True, then the Resources folder will be created in the project folder, if False, then a symlink to proj/Resources will be created
    read_permission: int = 0o2750,  # the permissions for the read group
    write_permission: int = 0o2775,  # the permissions for the write group
) -> None:
    """
    CLI function to create a project folder with subfolders.
    """
    try:
        create_project_folder_and_subfolders(
            locked_resources,
            read_group,
            write_group,
            project_dir,
            project_name,
            read_permission=0o2750,
            write_permission=0o2775,
        )
    except Exception as e:
        print(f"Error: {e}")
        return False
    return True

# %% ../nbs/02_project_creation.ipynb 10
def create_project_metadata(row: pd.Series, config) -> dict:
    """
    Function to create a project metadata dictionary based on the project name and the project directory.
    """
    meta_data_structure = config["project_creation"]["info_metadata_template"]
    # change to key values and replace all values starting with $ with ones found in config["project_creation"]["sample_sheet_expected_rows"]
    project_metadata = {}
    for key, value in meta_data_structure.items():
        if value.startswith("$"):
            project_metadata[key] = row[value[1:]]
        else:
            project_metadata[key] = value
    return project_metadata

# %% ../nbs/02_project_creation.ipynb 11
# row is a pandas row
def process_row(row: pd.Series, config):
    """
    Process a row of a pandas dataframe.
    """
    # change tuple to print

    linux_group_modifiers = config["project_creation"]["linux_group_modifiers"]
    project_dir = config["project_creation"]["project_dir"]
    # check_requirements(linux_group_modifiers, project_id, project_dir)
    # create_project_folder_and_subfolders(row, "")
    # print(create_project_metadata(row, config))

# %% ../nbs/02_project_creation.ipynb 12
def process_samplesheet(sample_sheet: str, config: dict):
    """Function to get samplesheet from the project"""
    # sample_sheet:
    #   path: path/to/sample_sheet.tsv
    #   delimiter: '\t' # Optional, will assume , for csv and \t otherwises
    #   header: 0 # Optional, 0 indicates first row is header, None indicates no header
    #   columns: ['column1', 'column2', 'column3'] # Optional, if not provided all columns will be used
    sample_sheet_config = {
        "path": sample_sheet,
        "delimiter": "\t",
        "header": 0,
        "columns": config["project_creation"]["sample_sheet_expected_rows"],
    }
    samplesheet_df = core.get_samplesheet(sample_sheet_config)
    for row in samplesheet_df.iterrows():
        # print the row as 1 line and not a df object
        # print(row[1].to_dict())
        process_row(row[1].to_dict(), config)
