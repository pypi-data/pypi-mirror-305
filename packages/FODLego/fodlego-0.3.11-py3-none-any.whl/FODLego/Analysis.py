#!/usr/bin/env python3
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import scipy.stats as stats
import statsmodels.api as sm
import matplotlib.patches as patches

# Important directories
savepath=''
SURVEY_FILES = []
ELEC_COUNT = []
SCF_ITER = []
b2a = 0.529177

# Helper Functions
def generate_random_color():
    import random
    return "#{:06x}".format(random.randint(0, 0xFFFFFF))

# General outline and most comments generated by ChatGPT 3.5
def CreateMolecules(file):
    """
    This function returns a list of Molecules that have been read from a file
    """
    # Preliminary Data
    from Molecule import Molecule
    Mols = []

    # Create empty list that will be returned
    with open(file, 'r') as file:
        # Read each line in the file
        for line in file:
            # Remove leading/trailing whitespaces and newline characters
            files = line.strip()
            files = files.split()

            # Create an instance of the Molecule class with the file_name parameter
            if len(files) == 2:
                try:
                    m = Molecule(files[0],files[1])
                    Mols.append(m)
                except:
                    print(f'Molecule with input structure {files[0]} cannot be loaded properly. Skipping')
                    continue
            elif len(files) == 3:
                try:
                    m = Molecule(files[0],files[1], files[2])
                    Mols.append(m)
                except:
                    continue
    # Return list of molecules
    return Mols

def GridPropRatios(mols):
    """
    This function loops through a list of molecules and creates a Matrix
    """
    import numpy as np
    import matplotlib.pyplot as plt
    from globaldata import GlobalData

    # Dictionary to store bond classes and their associated bond proportions
    bond_pairs = {}

    # Iterate through each bfod
    for bfod in GlobalData.mBFODs:
        # Create a unique key-value pair for each bonding type
        key = frozenset({bfod.mBold.mZ,bfod.mMeek.mZ})
        # Add key to dictionary if nonexistent.
        if key not in bond_pairs:
            bond_pairs[key] = []
        bond_pairs[key].append(bfod.mAssocFOD.mBoldPortion)

    # Initialize a dictionary to store the average bond proportions and standard deviation for each bond pair
    average_bond_proportions = {}
    std_deviation_bond_proportions = {}

    # Calculate the average bond proportion and standard deviation for each bond pair
    for bond_pair, bond_proportions in bond_pairs.items():
        average_bond_proportions[bond_pair] = np.mean(bond_proportions)
        std_deviation_bond_proportions[bond_pair] = np.std(bond_proportions)

    # Extract unique atomic numbers from bond pairs
    unique_atomic_numbers = set()
    for bond_pair in average_bond_proportions.keys():
        unique_atomic_numbers.update(bond_pair)

    # Create a sorted list of unique atomic numbers
    atomic_numbers_sorted = sorted(unique_atomic_numbers)

    # Create a matrix to store the average bond proportions
    matrix_size = len(atomic_numbers_sorted)
    bond_matrix = np.zeros((matrix_size, matrix_size))

    # Fill in the matrix with the average bond proportions
    for bond_pair, avg_bond_proportion in average_bond_proportions.items():
        atomic_numbers_list = sorted(list(bond_pair))
        if len(atomic_numbers_list) == 1:
            atomic_number = atomic_numbers_list[0]
            index = atomic_numbers_sorted.index(atomic_number)
            bond_matrix[index, index] = avg_bond_proportion
        else:
            atomic_number_1, atomic_number_2 = atomic_numbers_list
            index_1 = atomic_numbers_sorted.index(atomic_number_1)
            index_2 = atomic_numbers_sorted.index(atomic_number_2)
            bond_matrix[index_1, index_2] = avg_bond_proportion
            bond_matrix[index_2, index_1] = avg_bond_proportion

    # Plot the heatmap with modified colormap and scaled data
    fig, ax = plt.subplots()
    heatmap = ax.imshow(bond_matrix, cmap='summer', interpolation='nearest', vmin=bond_matrix.min(), vmax=bond_matrix.max())
    plt.colorbar(heatmap, ax=ax, label='Average Bond Proportion')
    plt.xticks(np.arange(matrix_size), atomic_numbers_sorted)
    plt.yticks(np.arange(matrix_size), atomic_numbers_sorted)
    plt.xlabel('Atomic Number')
    plt.ylabel('Atomic Number')
    plt.title('Average Bond Proportion Matrix Heatmap')

    # Annotate the averages and standard deviations in the grid boxes
    for i in range(matrix_size):
        for j in range(matrix_size):
            avg_value = bond_matrix[i, j]
            std_dev_value = std_deviation_bond_proportions.get(frozenset({atomic_numbers_sorted[i], atomic_numbers_sorted[j]}), 0)
            num_data_points = len(bond_pairs.get(frozenset({atomic_numbers_sorted[i], atomic_numbers_sorted[j]}), []))
            annotation = f'μ = {avg_value:.4f}\nσ = {std_dev_value:.4f}\nN = {num_data_points}'
            ax.annotate(annotation, (j, i), color='black', ha='center', va='center')

    
    # Save the image
    plt.savefig('heatmap.pdf')
    print(bond_pairs)

def FODLoop_energies(file_path):
    # Useful Variables
    FOD_Opt = False
    Energies = []
    iteration = []
    last_it = -1
    lastE = 0

    # Load line
    with open(file_path, 'r') as file:
        for line in file:
            parseLine = line.split()

            # check for first line with initial element IT
            if parseLine[0] == 'IT' or parseLine[0] == '1':
                continue

            # Check if FOD Optimization is active
            elif float(parseLine[1]) == 0.0:
                FOD_Opt = True
                lastE = float(parseLine[5])
                last_it += 1
            elif float(parseLine[1]) != 0.0:
                if FOD_Opt == True:
                    Energies.append(lastE)
                    iteration.append(last_it)
                    FOD_Opt = False

    # The last value should be a SIC energy
    Energies.append(lastE)
    iteration.append(last_it)

    # Return value
    return np.array(Energies), iteration


def SCF_iterations(file_path):
    # Useful Variables
    SCF_Opt = True
    count_hist = []
    count = 0
    skip_wf_gen = False
    skip_tally = 0

    # Load line
    with open(file_path, 'r') as file:
        for line in file:
            parseLine = line.split()

            # check for first line with initial element IT
            if not skip_wf_gen:
                if parseLine[0] == 'IT':
                    skip_tally += 1
                if skip_tally == 2:
                    skip_wf_gen = True
            else:
                if parseLine[0] == 'IT':
                    SCF_Opt = True
                    count = 0
                elif parseLine[0] == '1':
                    count += 1
                elif float(parseLine[1]) != 0.0:
                    SCF_Opt = True
                    count += 1
                elif float(parseLine[1]) == 0.0:
                    if SCF_Opt == True:
                        count_hist.append(count)
                        count = 0
                        SCF_Opt = False

    # Return value
    return count_hist

def parse_file(file_path):
    energies = []
    coordinates = []

    with open(file_path, 'r') as file:
        lines = file.readlines()

    i = 0
    while i < len(lines):
        # Read an empty line
        if lines[i].strip() == "":
            i += 1

        # Read energy line
        if i < len(lines):
            energy = float(lines[i].strip())
            energies.append(energy)
            i += 1

        # Read the line with the number of electrons
        if i < len(lines):
            num_electrons = int(lines[i].split()[0])
            i += 1

        # Read the coordinates lines
        snapshot_coords = []
        for _ in range(num_electrons):
            if i < len(lines):
                coords = lines[i].split()[:3]
                coords = [float(coord.replace('D', 'E')) for coord in coords]
                snapshot_coords.append(coords)
                i += 1

        # Skip the extra lines
        i += num_electrons

        # Save the coordinates for the current snapshot
        coordinates.append(snapshot_coords)

    # Convert the coordinates to a numpy array
    coordinates = np.array(coordinates)

    return energies, coordinates, num_electrons

def calculate_rmsd(coords1, coords2):
    """
    Calculate the Root Mean Square Deviation (RMSD) between two sets of coordinates.
    
    Parameters:
    coords1 (numpy.ndarray): The first set of coordinates.
    coords2 (numpy.ndarray): The second set of coordinates.
    
    Returns:
    float: The RMSD value.
    """
    from scipy.stats.mstats import gmean

    if coords1.shape != coords2.shape:
        raise ValueError("The coordinate sets must have the same shape.")

    diff = coords1 - coords2
    diff = np.linalg.norm(diff, axis=1)**2
    msd = np.mean(diff)
    # msd = gmean(diff)
    #return msd*0.529177
    return np.sqrt(msd)*b2a


def calculate_maxD(coords1, coords2):
    diff = coords1 - coords2
    diff = np.linalg.norm(diff, axis=1)
    return np.max(diff*0.529177)

def calculate_all_rmsds(coordinates):
    """
    Calculate the RMSD between successive snapshots of coordinates.
    
    Parameters:
    coordinates (numpy.ndarray): The array of all coordinates, shape (num_snapshots, num_electrons, 3).
    
    Returns:
    numpy.ndarray: An array of RMSD values between successive snapshots.
    """
    num_snapshots = coordinates.shape[0]
    rmsds = np.zeros(num_snapshots - 1)

    for i in range(num_snapshots - 1):
        rmsds[i] = calculate_rmsd(coordinates[i], coordinates[i + 1])

    return rmsds

def plot_rmsd_E(all_energies, all_rmsds, labels):
    snapshots = np.arange(1, max(len(e) for e in all_energies) + 1)  # Snapshot indices

    fig, ax1 = plt.subplots()

    ax1.set_xlabel('Snapshot Index')
    ax1.set_ylabel('Energy Deviation from first energy', color='tab:blue')
    
    for energies, label in zip(all_energies, labels):
        energies = np.array(energies) - energies[0]
        ax1.plot(snapshots[:len(energies)], energies, label=f'Energy {label}', alpha=.5, linewidth=.7)

    ax1.tick_params(axis='y', labelcolor='tab:blue')

    ax2 = ax1.twinx()  # Instantiate a second y-axis sharing the same x-axis
    ax2.set_ylabel('RMSD', color='tab:red')
    
    for rmsds, label in zip(all_rmsds, labels):
       #ax2.plot(snapshots[1:len(rmsds)+1], rmsds, label=f'RMSD {label}', alpha=.5, linewidth=.3)
       pass
    
    ax2.tick_params(axis='y', labelcolor='tab:red')

    fig.tight_layout()  # Ensume the right y-label is not slightly clipped
    plt.title('RMSD and Energy vs. Snapshot Index')
    ax1.legend(loc='best')
    ax1.set_ylim(-.5,.01)
    ax2.set_ylim(0,.11)
    ax2.legend(loc='upper right')
    plt.show()

def plot_all_energ_glob_checkp(all_energies, labels, checkpoints):
    snapshots = np.arange(1, max(len(e) for e in all_energies) + 1)  # Snapshot indices

    # Define height ratios based on the desired y-range
    height_ratios = [1, 0]  # Adjust these ratios as needed

    # Setup generic plot
    fig, ax = plt.subplots()
    
    #Create the ranges for each plot
    y_lim = [(-.015,.001), (-.5, 0)]


    ax.set_xlabel('Iterations')
    ax.set_ylabel('Energy Deviation  ($E_{mn} - E_{m0}$)', color='tab:blue')

    for energies, label, cp in zip(all_energies, labels, checkpoints):
        y =  energies[:cp[1][-2]+1] - energies[-1]
        result = [y[0]]
        for i in range(1, len(y)-2):
            if y[i] < result[-1]:
                result.append(y[i])

        ax.plot(range(0,len(result)), result, label=f'Energy {label}', alpha=.4, linewidth=0.6)
        indices = cp[1][:-1]
        #ax.scatter(indices, energies[indices]-energies[-1], s=4)


    ax.tick_params(axis='y')

    plt.yscale('log')
    fig.tight_layout()  # Ensume the right y-label is not slightly clipped
    #ax.set_ylim(y_lim[i])
    #fig.savefig(savepath + "Energies.svg")

def Plot_RMSD_Levels(all_rmsds, labels):
    snapshots = np.arange(1, max(len(e) for e in all_energies) + 1)  # Snapshot indices

    # Setup generic plot
    fig, ax = plt.subplots(figsize=(6,3))
    
    ax.set_xlabel('Iterations')
    ax.set_ylabel('RMSD (final,initial)')
    meanIters = np.mean([len(x) for x in all_rmsds])
    print(meanIters)

    for rmsds, label in zip(all_rmsds, labels):
        ax.plot(snapshots[1:len(rmsds)+1], rmsds, label=f'RMSD {label}', alpha=.4, linewidth=.8)

    ax.tick_params(axis='y')
    ax.set_ylim(0,.15)
    ax.set_title('RMSD vs. Iterations')
    
    fig.tight_layout()  # Ensume the right y-label is not slightly clipped

    plt.show()
    #fig.savefig(savepath + "RMSD.svg")

def ttest(x,y,axs):
    # Perform linear regression using statsmodels
    x = sm.add_constant(x)  # Adds a constant term to the predictor
    model = sm.OLS(y, x).fit()
    slope = model.params[1]
    intercept = model.params[0]

    # Plot the regression line
    axs.plot(x[:, 1], slope * x[:, 1] + intercept, color='red', label='Best Fit Line')
    axs.legend()  # Add legend for the best fit line

    # Print the slope and intercept
    print(f'Slope (m): {slope}')
    print(f'Intercept (b): {intercept}')

    # Perform t-test on the slope
    t_stat = model.tvalues[1]
    p_value = model.pvalues[1]

    print(f'T-test results for the slope: t-statistic = {t_stat}, p-value = {p_value}')

def delete_residuals(x,y,axs):# Adding a constant to the predictor
    x_with_const = sm.add_constant(x)

    # Fit the model
    model = sm.OLS(y, x_with_const).fit()

    # Obtain influence measures
    influence = model.get_influence()

    # Get deleted residuals
    deleted_residuals = influence.resid_studentized_external

    print("Deleted Residuals:", deleted_residuals)

    # Plotting the deleted residuals
    fig, ax = plt.subplots()
    ax.scatter(x, deleted_residuals, s=20)

def iter_rmsd_scatter(all_coords, all_energies):
    """
    This prints the grid of graphs. However, it is not the best.
    """
    # Setup 3x1 subplots figure
    fig, axs = plt.subplots(figsize=(6,3))
    rmsd_array = []
    it_array = []
    energy_dev_array = []
    global SURVEY_FILES
    global ELEC_COUNT
    uniq_elecs = list(set(ELEC_COUNT))
    cmap = {34: 'r', 30: 'g', 29: 'orange', 28: 'blue'}

    for i, coordinates in enumerate(all_coords):
        if SURVEY_FILES[i] != '36' or  SURVEY_FILES[i] != '239' or  SURVEY_FILES[i] != '242':
            iterations = len(coordinates)
            initial_coords = coordinates[0]
            final_coords = coordinates[-1]
            rmsd = calculate_rmsd(initial_coords, final_coords)
            if True:
                it_array.append(iterations)
                rmsd_array.append(rmsd)
                if iterations > 210 and rmsd > 0.17 and rmsd < 0.20:
                    print_filenames([i])
                    print(iterations, 'iterations')
                    print(rmsd, 'rmsd')

            # axs.axhline(0.17, linewidth=0.05)
            # axs.axhline(0.20, linewidth=0.05)
            # axs.axvline(210, linewidth=0.05)
            energies = all_energies[i]
            energy_deviation =  energies[-1] - energies[0]

            # Plot RMSD vs. Iterations
            #energee = 20 + np.abs(np.exp(-10*energy_deviation))
            energee = np.abs(energy_deviation) * 1000
            color = cmap[ELEC_COUNT[i]]
            if ELEC_COUNT[i] == 29 and rmsd > 0.4:
                print(SURVEY_FILES[i], 'here')
            axs.scatter(iterations, rmsd, s=energee, alpha=0.7, linewidth=0, c=color)
            energy_dev_array.append(-energy_deviation)
            axs.set_xlabel('FOD Loop Iterations')
            axs.set_ylabel('RMSD (Å)')

    # Pearson Correlation
    it_array = np.array(it_array)
    rmsd_array = np.array(rmsd_array)
    correlation, p_value = stats.pearsonr(it_array, rmsd_array)

    # Additional metrics
    print(f'Pearson correlation coefficient: {correlation}')
    print(f'P-value: {p_value}')
    max = np.max(energy_dev_array)
    min = np.min(energy_dev_array)
    min_i = np.argmin(energy_dev_array)
    max_i = np.argmax(energy_dev_array)
    print_filenames([max_i])
    print('Max Deviation:', max, 'at', it_array[max_i], 'iterations')
    print_filenames([min_i])
    print('Min Deviation:',min, 'at', it_array[min_i], 'iterations')

    # Iteration Data
    max = np.max(it_array)
    min = np.min(it_array)
    mean = np.mean(it_array)
    min_i = np.argmin(it_array)
    max_i = np.argmax(it_array)
    print_filenames([max_i])
    print('Max Iterations:', max)
    print_filenames([min_i])
    print('Min Iterations:',min)
    print('MEAN ITERS',mean)


    # Create Label
    cmap = {34: 'r', 30: 'g', 29: 'orange', 28: 'blue'}
    from matplotlib.patches import Patch
    legend_elements = []
    for num in  cmap:
        legend_elements.append(Patch(facecolor=cmap[num], edgecolor=cmap[num], label=(f'{num} electrons')))
    leg1 = axs.legend(handles=legend_elements, fontsize=6, loc='upper left')
    axs.add_artist(leg1)

    # T-test
    x = it_array
    y = rmsd_array
    #ttest(x,y,axs)
    #delete_residuals(x,y,axs)

    # Create some statistics
    # plt.annotate(f'Average RMSD: {np.mean(rmsd_array):.3f} $\pm$ {np.std(rmsd_array):.3f} Bohr', xy=(0.70, 0.11), xycoords='axes fraction', horizontalalignment='center')
    # plt.annotate(f'Average Iterations: {np.mean(it_array):.0f} ', xy=(0.70, 0.04), xycoords='axes fraction', horizontalalignment='center')
    print('The mean deviation: ', np.mean(energy_dev_array))
    print(energy_dev_array)

    # Y Axis
    # axs.set_ylim([0.15*0.529177,.58*0.529177])
    # max = np.max(energy_dev_array)
    # min = np.min(energy_dev_array)
    min = .01
    max = 0.5
    mid = (max+min)/2
    gll = plt.scatter([],[], s=min*1000, linewidth=0, marker='o',alpha=0.5, color='#555555')
    gl = plt.scatter([],[], s=mid*1000, linewidth=0, marker='o',alpha=0.5, color='#555555')
    ga = plt.scatter([],[], s=max*1000, linewidth=0, marker='o',alpha=0.5, color='#555555')

    hart = '$E_h$'
    axs.legend((gll,gl,ga),
        (f'{min:.1} {hart}', f'{mid:.2} {hart}', f'{max:.2} {hart}'),
        scatterpoints=1,
        loc='lower right',
        ncol=1,
        labelspacing=1,
        fontsize=8,
        handleheight=3,
        handlelength=3,
        # handletextpad=2
        )

    # Additional Settings
    fig.tight_layout()  # Ensure the labels are not slightly clipped
    #fig.savefig(savepath + "Iter_RMSD_elecs.svg")

def iter_rmsd_scatter_zoom(all_coords, all_energies):
    """
    This prints the grid of graphs. However, it is not the best.
    """
    # Setup 3x1 subplots figure
    fig, axs = plt.subplots(figsize=(6,2))
    rmsd_array = []
    it_array = []
    energy_dev_array = []
    global SURVEY_FILES
    global ELEC_COUNT
    uniq_elecs = list(set(ELEC_COUNT))
    print(uniq_elecs)
    cmap = {34: 'r', 30: 'g', 29: 'orange', 28: 'blue'}

    # Loop through all coordinates
    for i, coordinates in enumerate(all_coords):
        iterations = len(coordinates)
        initial_coords = coordinates[0]
        final_coords = coordinates[-1]
        rmsd = calculate_rmsd(initial_coords, final_coords)
        if True:
            it_array.append(iterations)
            rmsd_array.append(rmsd)
            if iterations > 210 :
                print_filenames([i])
                print(iterations, 'iterations')
                print(rmsd, 'rmsd')

        # Lines and patches
        axs.axhline(b2a*0.20, linewidth=0.05, alpha=0.2)
        axs.axhline(b2a*0.30, linewidth=0.05, alpha=0.2)
        axs.axvline(210, linewidth=0.02, alpha=0.2)
        axs.axvline(100, linewidth=0.02, alpha=0.2)
        patch1 = patches.Rectangle((210, b2a*0.20), 290, b2a*0.1, linewidth=1, edgecolor='none', facecolor='lightblue', alpha=0.01)
        axs.add_patch(patch1)
        patch2 = patches.Rectangle((75, b2a*0.20), 25, b2a*0.1, linewidth=1, edgecolor='none', facecolor='lightblue', alpha=0.01)
        axs.add_patch(patch2)
        energies = all_energies[i]
        energy_deviation =  energies[-1] - energies[0]

        # Plot RMSD vs. Iterations
        energee = 20 + np.abs(np.exp(-10*energy_deviation))
        #energee = np.abs(energy_deviation) + 10
        color = cmap[ELEC_COUNT[i]]
        axs.scatter(iterations, rmsd, s=energee, alpha=0.8, linewidth=0, c=color)
        energy_dev_array.append(-energy_deviation)
        axs.set_xlabel('FOD Loop Iterations')
        axs.set_ylabel('RMSD (Å)')

    # Pearson Correlation
    # x = np.array(it_array)
    # y = np.array(rmsd_array)
    # correlation, p_value = stats.pearsonr(x, y)

    # print(f'Pearson correlation coefficient: {correlation}')
    # print(f'P-value: {p_value}')

    # T-test
    #ttest(x,y,axs)
    #delete_residuals(x,y,axs)

    # Create some statistics
    # plt.annotate(f'Average RMSD: {np.mean(rmsd_array):.3f} $\pm$ {np.std(rmsd_array):.3f} Bohr', xy=(0.70, 0.11), xycoords='axes fraction', horizontalalignment='center')
    # plt.annotate(f'Average Iterations: {np.mean(it_array):.0f} ', xy=(0.70, 0.04), xycoords='axes fraction', horizontalalignment='center')
    print(energy_dev_array)
    print('Max and Min iterations:', max(it_array), min(it_array))
    # max_i = it_array.index(max(it_array))
    # min_i = it_array.index(min(it_array))
    # print('The min and max iterations in this set')
    # print_filenames([min_i, max_i])

    # Axis Limits
    axs.set_xlim([75,290])
    axs.set_ylim([b2a*0.18,b2a*.32])

    # Additional Settings
    fig.tight_layout()  # Ensure the labels are not slightly clipped
    #fig.savefig(savepath + "Iter_RMSD_elecs.svg")

def print_filenames(indices):
    for i in indices:
        print(SURVEY_FILES[i])

def iter_energy_scatter(all_coords, all_energies):
    """
    This prints the grid of graphs. However, it is not the best.
    """
    # Setup 3x1 subplots figure
    fig, axs = plt.subplots(figsize=(6,2))
    rmsd_array = []
    it_array = []
    energy_dev_array = []
    global ELEC_COUNT
    uniq_elecs = list(set(ELEC_COUNT))
    print(uniq_elecs)
    cmap = {34: 'r', 30: 'g', 29: 'orange', 28: 'blue'}

    for i, coordinates in enumerate(all_coords):
        initial_coords = coordinates[0]
        final_coords = coordinates[-1]
        diff = initial_coords - final_coords
        iterations = len(coordinates)
        rmsd = np.sqrt(np.mean(diff ** 2))
        rmsd_array.append(rmsd)
        it_array.append(iterations)

        energies = all_energies[i]
        energy_deviation =  energies[-1] - energies[0]

        # Files with superior deviation
        # if -energy_deviation > 0.05 and iterations > 200:
        #     print_filenames([i])
        #     print(iterations, 'iterations')
        #     print(energy_deviation, 'deviation')

        # if iterations > 270:
        #     print_filenames([i])
        #     print(iterations, 'iterations')
        #     print(energy_deviation, 'deviation')
        #     print(20*'-')

        # Plot RMSD vs. Iterations
        energee = 20 + np.abs(np.exp(-10*energy_deviation))
        exag_rmsd = 20 + np.abs(np.exp(13*rmsd))
        #energee = np.abs(energy_deviation) + 10
        color = cmap[ELEC_COUNT[i]]
        axs.scatter(iterations, -energy_deviation, alpha=0.8, linewidth=0, c=color)

        # Line
        axs.axhline(0.1, linewidth=0.05)
        axs.annotate(
            '0.1 Hartree',      # Text to display
            xy=(265, 0.12),       # Position to place the annotation (xy)
            size=8
        )
        energy_dev_array.append(-energy_deviation)
        axs.set_xlabel('FOD Loop Iterations')
        axs.set_ylabel('Energy Deviation (hartree)', size=8)

        # Print Information
        if energy_deviation < -.1:
            print('high E. deviation', SURVEY_FILES[i])
            print('Iterations: ', iterations)

    # Create some statistics
    print(energy_dev_array)
    print(max(energy_dev_array), min(energy_dev_array))

    # Y Scale
    axs.set_yscale('log')

    # Additional Settings
    fig.tight_layout()  # Ensure the labels are not slightly clipped
    fig.savefig(savepath + "deviation_RMSD.svg")

def check_iter_rmsd(all_coords, all_energies):
    # Create figure for RMSD vs. Energy Deviation
    fig1, ax1 = plt.subplots()

    for i, coordinates in enumerate(all_coords):
        initial_coords = coordinates[0]
        final_coords = coordinates[-1]
        rmsd = np.sqrt(np.sum((coordinates - initial_coords) ** 2, axis=2).mean(axis=1))
        energy_deviation = all_energies[i][-1] - all_energies[i][0]

        ax1.plot([energy_deviation] * len(rmsd), rmsd, 'o', label=labels[i], alpha=.5, linewidth=1.1, markersize=6)
    ax1.set_xlabel('Energy Deviation ($E_{mn} - E_{m0}$)')
    ax1.set_ylabel('RMSD (Initial vs Final)', color='tab:blue')
    ax1.legend()
    ax1.tick_params(axis='y')
    fig1.tight_layout()
    plt.show()

    # Create figure for RMSD vs. Iterations
    fig2, ax2 = plt.subplots()
    for i, coordinates in enumerate(all_coords):
        initial_coords = coordinates[0]
        rmsd = np.sqrt(np.sum((coordinates - initial_coords) ** 2, axis=2).mean(axis=1))
        iterations = np.arange(len(coordinates))

        ax2.plot(iterations, rmsd, 'o', label=labels[i], alpha=.5, linewidth=1.1, markersize=6)
    ax2.set_xlabel('Iterations')
    ax2.set_ylabel('RMSD (Initial vs Final)', color='tab:blue')
    ax2.legend()
    ax2.tick_params(axis='y')
    fig2.tight_layout()
    plt.show()

    # Create figure for Iterations vs. Energy Deviation
    fig3, ax3 = plt.subplots()
    for i, coordinates in enumerate(all_coords):
        iterations = np.arange(len(coordinates))
        energy_deviation = all_energies[i][-1] - all_energies[i][0]

        ax3.plot(iterations, [energy_deviation] * len(iterations), 'o', label=labels[i], alpha=.5, linewidth=1.1, markersize=6)
    ax3.set_xlabel('Iterations')
    ax3.set_ylabel('Energy Deviation ($E_{mn} - E_{m0}$)', color='tab:blue')
    ax3.legend()
    ax3.tick_params(axis='y')
    fig3.tight_layout()
    plt.show()

def boxplotFirstEnergy(all_energies, all_coords):
    energyDelta = []
    rmsd_array = []
    iterations = []

    # Setup generic plot
    fig, ax = plt.subplots()


    for energies in all_energies:
        energyDelta.append(energies[0] - energies[-1])

    for coordinates in all_coords:
        initial_coords = coordinates[0]
        final_coords = coordinates[-1]
        diff = initial_coords - final_coords
        iterations.append(len(coordinates))
        rmsd = np.sqrt(np.mean(diff ** 2))
        rmsd_array.append(rmsd)

    # Boxplot
    ax.boxplot([iterations], vert=False)

    # Limits
    ax.set_title('Quartiles of energy deviation')
    plt.show()

def convergence_subset(all_energies, labels, checkpoints):
    # Setup generic plot
    fig, ax = plt.subplots(figsize=(12,4))

    #Create the ranges for each plot
    y_lim = (0,.01)

    import random
    #o1, o2, o3, o4, o5 = random.sample(range(81), 4)
    filenumbers =  [243, 263, 233]
    og_indeces = [SURVEY_FILES.index(str(i)) for i in filenumbers]

    # Get final energies and subtract
    for i in og_indeces:
        energydev = all_energies[i]
        energydev = np.array(energydev) - energydev[-1]
        last_i_glob = checkpoints[i][1][-2]
        y = energydev[:last_i_glob+1]
        ax.plot(range(0,len(y)), y, alpha=.5, linewidth=1.1, label=labels[i])
        indices = checkpoints[i][1][:-1]

        # Checkpoints: end of FODLoop
        ax.scatter(indices, energydev[indices],alpha=.5, linewidth=0)

    # Axis Options
    ax.tick_params(axis='y')
    #ax.legend()

    # Y Axis
    #ax.set_ylim(y_lim)

    # X Axis
    ax.set_xlabel('FOD Loop Iterations')
    ax.set_ylabel('Energy Deviation ($E_{n} - E_{n,final}$)')

    # Labels
    ax.set_title("Convergence of Energy Deviation")
    plt.yticks(fontsize=12)
    plt.yscale('log')
    fig.tight_layout()  # isomers_similar.pngume the right y-label is not slightly clipped
    fig.savefig(savepath + "convergence_subset.svg")

def rateOfConv(all_energies):
    # Convert data type

    #Create figure
    fig, ax = plt.subplots()

    # Other variables
    all_errors = []

    # Asymptotic Error
    print("The asymptotic error (q=1)")
    for energies in all_energies:
        errors = []
        energies = np.array(energies)
        for k in range(energies.size - 1):
            num = np.abs(energies[k+1] - energies[-1])
            denom = np.abs(energies[k] - energies[-1])
            errors.append(num/denom)
            print(num/denom)
            all_errors.append(np.abs(num/denom))

        from scipy.stats import gmean

        ax.plot(errors)

        print("Rate of convergence Approx:")
        for k in range(2,energies.size - 1):
            a = energies[k+1] - energies[k]
            b = energies[k] - energies[k-1]
            num = np.log(np.abs(a/b))
            c = energies[k] - energies[k-1]
            d = energies[k-1] - energies[k-2]
            denom = np.log(np.abs(c/d))

def plot_global_rate(checkpoints, all_energies):
    fig, ax = plt.subplots()
    systems = range(0,len(all_energies))
    for (checkpoint,it), energy,system in zip(checkpoints,all_energies, systems):
            rate_of_convergence = []
            for i in range(0,len(it)-2):
                aftr = it[i+1]
                bfr = it[i]
                num = energy[aftr] - energy[-1]
                denom = energy[bfr] - energy[-1]
                rate_of_convergence.append(np.abs(num/denom))
            ax.plot(range(len(rate_of_convergence)), rate_of_convergence, linewidth=0.5)
    ax.set_yscale('log')

def load_summary(path: str, src: str):
    """
    A path is given to the directory of files. The src file is the sorted list of the files.
    """
    # Globals
    global SCF_ITER
    global_energies = []

    #Open sorted list of all files to read in path
    with open(src, 'r') as file:
        files = file.readlines()
        global SURVEY_FILES
        SURVEY_FILES = [f.strip()[:-8] for f in files]
        path_files = [os.path.join(path, f.strip()) for f in files]
        for f in path_files:
            # loop through the ordered files and load them
            if os.path.isfile(f):
                glob_e = FODLoop_energies(f)
                scf_seq = SCF_iterations(f)
                SCF_ITER.append(scf_seq)
                global_energies.append(glob_e)
    return global_energies

def load_energies(path: str, src: str):
    all_energies = []
    all_coords = []
    global ELEC_COUNT
    all_rmsds = []
    labels = []

    # Open Source file: record_source
    with open(src, 'r') as file:
        files = file.readlines()
        path_files = [os.path.join(path, f.strip()) for f in files]
        for f,label in zip(path_files, files):
            # loop through the ordered files and load them
            if os.path.isfile(f):
                energies, coordinates, electrons = parse_file(f)
                # Add Electrons
                ELEC_COUNT.append(electrons)
                # Keep track of RMDSD in-between steps
                rmsds = calculate_all_rmsds(coordinates)
                all_rmsds.append(rmsds)
                all_coords.append(coordinates)
                all_energies.append(np.array(energies))
                labels.append(label)
    return all_energies, all_coords, all_rmsds, labels

def scf_barchart():
    # Number of bars to plot (number of arrays in SCF_ITER)
    n_bars = len(SCF_ITER)

    # Create figure and axis
    fig, ax = plt.subplots(figsize=(6,9))

    # Get the maximum step value for normalization
    max_step = max(max(steps) for steps in SCF_ITER)

    # Loop through each array in SCF_ITER to create a stacked bar
    for i, steps in enumerate(SCF_ITER):
        # Initialize the bottom position for stacking
        left = 0
        # Loop through each step in the array to stack the bars
        for step in steps:
            # Normalize the step value to get a color
            color = cm.hot(step / max_step)
            ax.barh(i, step, left=left, color=color, linewidth=0.5, edgecolor='white')
            # Update the left position
            left += step

    # Set labels and title
    ax.set_ylabel('Systems')
    ax.set_xlabel('Steps')
    ax.set_title('SCF Iterations in a FLOSIC loop')
    ax.set_yticks(range(n_bars))
    ax.set_yticklabels(SURVEY_FILES, size=5)
    fig.tight_layout()  # isomers_similar.pngume the right y-label is not slightly clipped
    fig.savefig(savepath + "SCF_all.svg")

def coordinate_analysis(all_coords, system: str):
    index = SURVEY_FILES.index(system)
    select_coord = all_coords[index]

    # Number of atoms (assuming all snapshots have the same number of atoms)
    n_atoms = len(select_coord[0])

    # Calculate distances for each atom across successive snapshots
    distances_per_atom = []
    for atom_index in range(n_atoms):
        distances = []
        for snapshot_index in range(1, len(select_coord)):
            coord1 = np.array(select_coord[snapshot_index - 1][atom_index])
            coord2 = np.array(select_coord[snapshot_index][atom_index])
            dist = np.linalg.norm(coord2 - coord1)
            distances.append(dist)
        distances_per_atom.append(distances)

    # Create figure and axis
    fig, ax = plt.subplots()

    # Get the maximum distance for normalization
    max_distance = max(max(distances) for distances in distances_per_atom)

    # Loop through each atom to create a stacked bar
    for atom_index, distances in enumerate(distances_per_atom):
        # Initialize the left position for stacking
        left = 0
        # Loop through each distance to stack the bars
        for dist in distances:
            # Normalize the distance value to get a color
            color = cm.Reds(dist / max_distance)
            ax.barh(atom_index+1, dist, left=left, color=color, edgecolor='gray')
            # Update the left position
            left += dist
    ax.set_xlim([0,2.5])

def calculate_distances(select_coord):
    n_atoms = len(select_coord[0])
    distances_per_atom = []
    for atom_index in range(n_atoms):
        distances = []
        for snapshot_index in range(1, len(select_coord)):
            coord1 = np.array(select_coord[snapshot_index - 1][atom_index])
            coord2 = np.array(select_coord[snapshot_index][atom_index])
            dist = np.linalg.norm(coord2 - coord1)
            distances.append(dist*b2a)
        distances_per_atom.append(distances)
    return distances_per_atom

def coordinate_analysis_2(all_coords, system1, system2):
    systems = [system1, system2]
    indices = [SURVEY_FILES.index(system) for system in systems]
    select_coords = [all_coords[index] for index in indices]

    fig, axs = plt.subplots(2, 1, figsize=(6, 6))
    max_distance = -1

    for ax, sys_coords in zip(axs, select_coords):
        distances_per_atom = calculate_distances(sys_coords)

        # Get the maximum distance for normalization
        new_max = max(max(distances) for distances in distances_per_atom)
        if new_max > max_distance:
            max_distance = new_max

        # Loop through each atom to create a stacked bar
        for atom_index, distances in enumerate(distances_per_atom):
            left = 0
            for dist in distances:
                color = cm.Reds(dist / max_distance)
                ax.barh(atom_index + 1, dist, left=left, color=color, edgecolor='gray', linewidth=0.5)
                left += dist

        # Reference Lines
        #ax.axvline(x=1, color='gray', linestyle='--', linewidth=1)

        # Annotations
        init = sys_coords[0]
        final = sys_coords[-1]
        rmsd = calculate_rmsd(init, final)
        ax.annotate(f'RMSD: {rmsd:.3f}', xy=(0.85, 0.04), xycoords='axes fraction', horizontalalignment='center')


    # Labels/Titles
    axs[0].set_ylabel('FODs')
    axs[0].set_title('System ' + systems[0])
    axs[1].set_ylabel('FODs')
    axs[1].set_xlabel('Accumulated FOD Travel Distance (Å)')
    axs[1].set_title('System ' + systems[1])
    axs[0].set_xlim([0,1.4])
    axs[1].set_xlim([0,1.4])


    plt.tight_layout()
    plt.savefig(savepath + '2similar_deviation.svg')


def iter_maxD(all_coords, all_energies):
    """
    This prints the grid of graphs. However, it is not the best.
    """
    # Setup 3x1 subplots figure
    fig, axs = plt.subplots(figsize=(6,3))
    rmsd_array = []
    it_array = []
    energy_dev_array = []
    global SURVEY_FILES
    global ELEC_COUNT
    uniq_elecs = list(set(ELEC_COUNT))
    print(uniq_elecs)
    cmap = {34: 'r', 30: 'g', 29: 'orange', 28: 'blue'}

    for i, coordinates in enumerate(all_coords):
        if SURVEY_FILES[i] != '36' or  SURVEY_FILES[i] != '239' or  SURVEY_FILES[i] != '242':
            print (SURVEY_FILES[i])
            iterations = len(coordinates)
            initial_coords = coordinates[0]
            final_coords = coordinates[-1]
            rmsd = calculate_maxD(initial_coords, final_coords)
            if True:
                it_array.append(iterations)
                rmsd_array.append(rmsd)
                if iterations > 210 and rmsd > 0.17 and rmsd < 0.20:
                    print_filenames([i])
                    print(iterations, 'iterations')
                    print(rmsd, 'rmsd')

            # axs.axhline(0.17, linewidth=0.05)
            # axs.axhline(0.20, linewidth=0.05)
            # axs.axvline(210, linewidth=0.05)
            energies = all_energies[i]
            energy_deviation =  energies[-1] - energies[0]

            # Plot RMSD vs. Iterations
            #energee = 20 + np.abs(np.exp(-10*energy_deviation))
            energee = np.abs(energy_deviation) * 1000
            color = cmap[ELEC_COUNT[i]]
            axs.scatter(iterations, rmsd, s=energee, alpha=0.7, linewidth=0, c=color)
            energy_dev_array.append(-energy_deviation)
            axs.set_xlabel('Iterations')
            axs.set_ylabel('RMSD (Initial vs Final)')

    # Pearson Correlation
    it_array = np.array(it_array)
    rmsd_array = np.array(rmsd_array)
    correlation, p_value = stats.pearsonr(it_array, rmsd_array)

    # Additional metrics
    print(f'Pearson correlation coefficient: {correlation}')
    print(f'P-value: {p_value}')
    max = np.max(energy_dev_array)
    min = np.min(energy_dev_array)
    min_i = np.argmin(energy_dev_array)
    max_i = np.argmax(energy_dev_array)
    print_filenames([max_i])
    print('Max Deviation:', max, 'at', it_array[max_i], 'iterations')
    print_filenames([min_i])
    print('Min Deviation:',min, 'at', it_array[min_i], 'iterations')

    # Iteration Data
    max = np.max(it_array)
    min = np.min(it_array)
    min_i = np.argmin(it_array)
    max_i = np.argmax(it_array)
    print_filenames([max_i])
    print('Max Iterations:', max)
    print_filenames([min_i])
    print('Min Iterations:',min)


    # Create Label
    cmap = {34: 'r', 30: 'g', 29: 'orange', 28: 'blue'}
    from matplotlib.patches import Patch
    legend_elements = []
    for num in  cmap:
        legend_elements.append(Patch(facecolor=cmap[num], edgecolor=cmap[num], label=(f'{num} electrons')))
    axs.legend(handles=legend_elements, fontsize=8, loc='lower right')

    # T-test
    x = it_array
    y = rmsd_array
    #ttest(x,y,axs)
    #delete_residuals(x,y,axs)

    # Create some statistics
    # plt.annotate(f'Average RMSD: {np.mean(rmsd_array):.3f} $\pm$ {np.std(rmsd_array):.3f} Bohr', xy=(0.70, 0.11), xycoords='axes fraction', horizontalalignment='center')
    # plt.annotate(f'Average Iterations: {np.mean(it_array):.0f} ', xy=(0.70, 0.04), xycoords='axes fraction', horizontalalignment='center')
    print(energy_dev_array)

    # Y Axis

    # Additional Settings
    fig.tight_layout()  # Ensure the labels are not slightly clipped
    #fig.savefig(savepath + "Iter_RMSD_elecs.svg")

def get29(all_coords):
    for i,coords in enumerate(all_coords):
        if len(coords[0]) == 29:
            print(SURVEY_FILES[i])

directory = 'getrecords'

# Load the global endpoints of each FOD optimization
summ_dir = os.path.join(os.getcwd(), 'getSUMM')
summlist = os.path.join(os.getcwd(), 'summary_source')
fodloop_checkpoints = load_summary(summ_dir, summlist)

# Load the global endpoints of each FOD optimization
rec_dir = os.path.join(os.getcwd(), 'getrecords')
recordlist = os.path.join(os.getcwd(), 'record_source')
all_energies, all_coords, all_rmsds, labels = load_energies(rec_dir, recordlist)

#get29(all_coords)

# Plot all data on the same graph
#Plot_RMSD_Levels(all_rmsds, labels)
#plot_all_energ_glob_checkp(all_energies, labels, fodloop_checkpoints)
#convergence_subset(all_energies, labels, fodloop_checkpoints)
#boxplotFirstEnergy(all_energies, all_coords)
#rateOfConv(all_energies)
#scf_barchart()


#iter_rmsd_scatter(all_coords, all_energies)
# iter_maxD(all_coords, all_energies)

#iter_rmsd_scatter_zoom(all_coords, all_energies)
# coordinate_analysis(all_coords, '69')
# coordinate_analysis(all_coords, '276')
#coordinate_analysis_2(all_coords, '276', '69')
#iter_energy_scatter(all_coords, all_energies)
#plot_global_rate(fodloop_checkpoints, all_energies)
#plt.show()
