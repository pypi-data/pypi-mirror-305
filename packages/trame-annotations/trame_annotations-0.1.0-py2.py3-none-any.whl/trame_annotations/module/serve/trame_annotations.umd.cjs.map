{"version":3,"file":"trame_annotations.umd.cjs","sources":["../../../../vue-components/node_modules/@timohausmann/quadtree-ts/dist/quadtree.esm.js","../../../../vue-components/src/components/ImageDetection.vue","../../../../vue-components/src/components/index.js","../../../../vue-components/src/main.js"],"sourcesContent":["/**\n * Class representing a Quadtree node.\n *\n * @example\n * ```typescript\n * const tree = new Quadtree({\n *   width: 100,\n *   height: 100,\n *   x: 0,           // optional, default:  0\n *   y: 0,           // optional, default:  0\n *   maxObjects: 10, // optional, default: 10\n *   maxLevels: 4,   // optional, default:  4\n * });\n * ```\n *\n * @example Typescript: If you like to be explicit, you optionally can pass in a generic type for objects to be stored in the Quadtree:\n * ```typescript\n * class GameEntity extends Rectangle {\n *   ...\n * }\n * const tree = new Quadtree<GameEntity>({\n *   width: 100,\n *   height: 100,\n * });\n * ```\n */\nclass Quadtree {\n    /**\n     * Quadtree Constructor\n     * @param props - bounds and properties of the node\n     * @param level - depth level (internal use only, required for subnodes)\n     */\n    constructor(props, level = 0) {\n        this.bounds = {\n            x: props.x || 0,\n            y: props.y || 0,\n            width: props.width,\n            height: props.height,\n        };\n        this.maxObjects = (typeof props.maxObjects === 'number') ? props.maxObjects : 10;\n        this.maxLevels = (typeof props.maxLevels === 'number') ? props.maxLevels : 4;\n        this.level = level;\n        this.objects = [];\n        this.nodes = [];\n    }\n    /**\n     * Get the quadrant (subnode indexes) an object belongs to.\n     *\n     * @example Mostly for internal use but you can call it like so:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rectangle = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * const indexes = tree.getIndex(rectangle);\n     * console.log(indexes); // [1]\n     * ```\n     *\n     * @param obj - object to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right).\n     */\n    getIndex(obj) {\n        return obj.qtIndex(this.bounds);\n    }\n    /**\n     * Split the node into 4 subnodes.\n     * @internal Mostly for internal use! You should only call this yourself if you know what you are doing.\n     *\n     * @example Manual split:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.split();\n     * console.log(tree); // now tree has four subnodes\n     * ```\n     */\n    split() {\n        const level = this.level + 1, width = this.bounds.width / 2, height = this.bounds.height / 2, x = this.bounds.x, y = this.bounds.y;\n        const coords = [\n            { x: x + width, y: y },\n            { x: x, y: y },\n            { x: x, y: y + height },\n            { x: x + width, y: y + height },\n        ];\n        for (let i = 0; i < 4; i++) {\n            this.nodes[i] = new Quadtree({\n                x: coords[i].x,\n                y: coords[i].y,\n                width,\n                height,\n                maxObjects: this.maxObjects,\n                maxLevels: this.maxLevels,\n            }, level);\n        }\n    }\n    /**\n     * Insert an object into the node. If the node\n     * exceeds the capacity, it will split and add all\n     * objects to their corresponding subnodes.\n     *\n     * @example you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.insert(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     *\n     * @param obj - Object to be added.\n     */\n    insert(obj) {\n        //if we have subnodes, call insert on matching subnodes\n        if (this.nodes.length) {\n            const indexes = this.getIndex(obj);\n            for (let i = 0; i < indexes.length; i++) {\n                this.nodes[indexes[i]].insert(obj);\n            }\n            return;\n        }\n        //otherwise, store object here\n        this.objects.push(obj);\n        //maxObjects reached\n        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n            //split if we don't already have subnodes\n            if (!this.nodes.length) {\n                this.split();\n            }\n            //add all objects to their corresponding subnode\n            for (let i = 0; i < this.objects.length; i++) {\n                const indexes = this.getIndex(this.objects[i]);\n                for (let k = 0; k < indexes.length; k++) {\n                    this.nodes[indexes[k]].insert(this.objects[i]);\n                }\n            }\n            //clean up this node\n            this.objects = [];\n        }\n    }\n    /**\n     * Return all objects that could collide with the given geometry.\n     *\n     * @example Just like insert, you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript\n     * tree.retrieve(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.retrieve(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.retrieve(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     *\n     * @param obj - geometry to be checked\n     * @returns Array containing all detected objects.\n     */\n    retrieve(obj) {\n        const indexes = this.getIndex(obj);\n        let returnObjects = this.objects;\n        //if we have subnodes, retrieve their objects\n        if (this.nodes.length) {\n            for (let i = 0; i < indexes.length; i++) {\n                returnObjects = returnObjects.concat(this.nodes[indexes[i]].retrieve(obj));\n            }\n        }\n        // remove duplicates\n        if (this.level === 0) {\n            return Array.from(new Set(returnObjects));\n        }\n        return returnObjects;\n    }\n    /**\n     * Remove an object from the tree.\n     * If you have to remove many objects, consider clearing the entire tree and rebuilding it or use the `fast` flag to cleanup after the last removal.\n     * @beta\n     *\n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const circle = new Circle({ x: 25, y: 25, r: 10, data: 512 });\n     * tree.insert(circle);\n     * tree.remove(circle);\n     * ```\n     *\n     * @example Bulk fast removals and final cleanup:\n     * ```javascript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rects = [];\n     *  for(let i=0; i<20; i++) {\n     *    rects[i] = new Rectangle({ x: 25, y: 25, width: 50, height: 50 });\n     *    tree.insert(rects[i]);\n     *  }\n     *  for(let i=rects.length-1; i>0; i--) {\n     *    //fast=true – just remove the object (may leaves vacant subnodes)\n     *    //fast=false – cleanup empty subnodes (default)\n     *    const fast = (i !== 0);\n     *    tree.remove(rects[i], fast);\n     *  }\n     * ```\n     *\n     * @param obj - Object to be removed.\n     * @param fast - Set to true to increase performance temporarily by preventing cleanup of empty subnodes (optional, default: false).\n     * @returns Weather or not the object was removed from THIS node (no recursive check).\n     */\n    remove(obj, fast = false) {\n        const indexOf = this.objects.indexOf(obj);\n        // remove objects\n        if (indexOf > -1) {\n            this.objects.splice(indexOf, 1);\n        }\n        // remove from all subnodes\n        for (let i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].remove(obj);\n        }\n        // remove all empty subnodes\n        if (this.level === 0 && !fast) {\n            this.join();\n        }\n        return (indexOf !== -1);\n    }\n    /**\n     * Update an object already in the tree (shorthand for remove and insert).\n     * If you have to update many objects, consider clearing and rebuilding the\n     * entire tree or use the `fast` flag to cleanup after the last update.\n     * @beta\n     *\n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100, maxObjects: 1 });\n     * const rect1 = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * const rect2 = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * tree.insert(rect1);\n     * tree.insert(rect2);\n     * rect1.x = 75;\n     * rect1.y = 75;\n     * tree.update(rect1);\n     * ```\n     * @example Bulk fast update and final cleanup:\n     * ```javascript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rects = [];\n     *  for(let i=0; i<20; i++) {\n     *    rects[i] = new Rectangle({ x: 20, y: 20, width: 20, height: 20 });\n     *    tree.insert(rects[i]);\n     *  }\n     *  for(let i=rects.length-1; i>0; i--) {\n     *    rects[i].x = 20 + Math.random()*60;\n     *    rects[i].y = 20 + Math.random()*60;\n     *    //fast=true – just re-insert the object (may leaves vacant subnodes)\n     *    //fast=false – cleanup empty subnodes (default)\n     *    const fast = (i !== 0);\n     *    tree.update(rects[i], fast);\n     *  }\n     * ```\n     *\n     * @param obj - Object to be updated.\n     * @param fast - Set to true to increase performance temporarily by preventing cleanup of empty subnodes (optional, default: false).\n     */\n    update(obj, fast = false) {\n        this.remove(obj, fast);\n        this.insert(obj);\n    }\n    /**\n     * The opposite of a split: try to merge and dissolve subnodes.\n     * @beta\n     * @internal Mostly for internal use! You should only call this yourself if you know what you are doing.\n     *\n     * @example Manual join:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.split();\n     * console.log(tree.nodes.length); // 4\n     * tree.join();\n     * console.log(tree.nodes.length); // 0\n     * ```\n     *\n     * @returns The objects from this node and all subnodes combined.\n     */\n    join() {\n        // recursive join\n        let allObjects = Array.from(this.objects);\n        for (let i = 0; i < this.nodes.length; i++) {\n            const bla = this.nodes[i].join();\n            allObjects = allObjects.concat(bla);\n        }\n        // remove duplicates\n        const uniqueObjects = Array.from(new Set(allObjects));\n        if (uniqueObjects.length <= this.maxObjects) {\n            this.objects = uniqueObjects;\n            for (let i = 0; i < this.nodes.length; i++) {\n                this.nodes[i].objects = [];\n            }\n            this.nodes = [];\n        }\n        return allObjects;\n    }\n    /**\n     * Clear the Quadtree.\n     *\n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10 }));\n     * tree.clear();\n     * console.log(tree); // tree.objects and tree.nodes are empty\n     * ```\n     */\n    clear() {\n        this.objects = [];\n        for (let i = 0; i < this.nodes.length; i++) {\n            if (this.nodes.length) {\n                this.nodes[i].clear();\n            }\n        }\n        this.nodes = [];\n    }\n}\n\n/**\n * Class representing a Rectangle\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n *\n * @example Without custom data (JS/TS):\n * ```typescript\n * const rectangle = new Rectangle({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n * });\n * ```\n *\n * @example With custom data (JS/TS):\n * ```javascript\n * const rectangle = new Rectangle({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n *   data: {\n *     name: 'Jane',\n *     health: 100,\n *   },\n * });\n * ```\n *\n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n *\n * // Typescript will infer the type of the data property\n * const rectangle1 = new Rectangle({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n *   data: entity,\n * });\n *\n * // You can also pass in a generic type for the data property\n * const rectangle2 = new Rectangle<ObjectData>({\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n * });\n * rectangle2.data = entity;\n * ```\n *\n * @example With custom class extending Rectangle (implements {@link RectangleGeometry} (x, y, width, height)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Box extends Rectangle {\n *\n *   constructor(props) {\n *     // call super to set x, y, width, height (and data, if given)\n *     super(props);\n *     this.content = props.content;\n *   }\n * }\n *\n * const box = new Box({\n *   content: 'Gravity Boots',\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 40,\n * });\n * ```\n *\n * @example With custom class and mapping {@link RectangleGeometry}:\n * ```javascript\n * // no need to extend if you don't implement RectangleGeometry\n * class Box {\n *\n *   constructor(content) {\n *     this.content = content;\n *     this.position = [10, 20];\n *     this.size = [30, 40];\n *   }\n *\n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to RectangleGeometry\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   }\n * }\n *\n * const box = new Box('Gravity Boots');\n * ```\n *\n * @example With custom object that implements {@link RectangleGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   x: 10,\n *   y: 20,\n *   width: 30,\n *   height: 30,\n *   qtIndex: Rectangle.prototype.qtIndex,\n * });\n * ```\n *\n * @example With custom object and mapping {@link RectangleGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible.\n * // Using this technique, each object would have it's own qtIndex method.\n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   position: [10, 20],\n *   size: [30, 40],\n *   qtIndex: function(node) {\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   },\n * });\n * ```\n */\nclass Rectangle {\n    constructor(props) {\n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.data = props.data;\n    }\n    /**\n     * Determine which quadrant this rectangle belongs to.\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node) {\n        const indexes = [], boundsCenterX = node.x + (node.width / 2), boundsCenterY = node.y + (node.height / 2);\n        const startIsNorth = this.y < boundsCenterY, startIsWest = this.x < boundsCenterX, endIsEast = this.x + this.width > boundsCenterX, endIsSouth = this.y + this.height > boundsCenterY;\n        //top-right quad\n        if (startIsNorth && endIsEast) {\n            indexes.push(0);\n        }\n        //top-left quad\n        if (startIsWest && startIsNorth) {\n            indexes.push(1);\n        }\n        //bottom-left quad\n        if (startIsWest && endIsSouth) {\n            indexes.push(2);\n        }\n        //bottom-right quad\n        if (endIsEast && endIsSouth) {\n            indexes.push(3);\n        }\n        return indexes;\n    }\n}\n\n/**\n * Class representing a Circle.\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n *\n * @example Without custom data (JS/TS):\n * ```typescript\n * const circle = new Circle({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n * });\n * ```\n *\n * @example With custom data (JS/TS):\n * ```javascript\n * const circle = new Circle({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n *   data: {\n *     name: 'Jane',\n *     health: 100,\n *   },\n * });\n * ```\n *\n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n *\n * // Typescript will infer the type of the data property\n * const circle1 = new Circle({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n *   data: entity,\n * });\n *\n * // You can also pass in a generic type for the data property\n * const circle2 = new Circle<ObjectData>({\n *   x: 100,\n *   y: 100,\n *   r: 32,\n * });\n * circle2.data = entity;\n * ```\n *\n * @example With custom class extending Circle (implements {@link CircleGeometry} (x, y, r)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Bomb extends Circle {\n *\n *   constructor(props) {\n *     // call super to set x, y, r (and data, if given)\n *     super(props);\n *     this.countdown = props.countdown;\n *   }\n * }\n *\n * const bomb = new Bomb({\n *   countdown: 5,\n *   x: 10,\n *   y: 20,\n *   r: 30,\n * });\n * ```\n *\n * @example With custom class and mapping {@link CircleGeometry}:\n * ```javascript\n * // no need to extend if you don't implement CircleGeometry\n * class Bomb {\n *\n *   constructor(countdown) {\n *     this.countdown = countdown;\n *     this.position = [10, 20];\n *     this.radius = 30;\n *   }\n *\n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to CircleGeometry\n *     return Circle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       r: this.radius,\n *     }, node);\n *   }\n * }\n *\n * const bomb = new Bomb(5);\n * ```\n *\n * @example With custom object that implements {@link CircleGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   x: 10,\n *   y: 20,\n *   r: 30,\n *   qtIndex: Circle.prototype.qtIndex,\n * });\n * ```\n *\n * @example With custom object and mapping {@link CircleGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible.\n * // Using this technique, each object would have it's own qtIndex method.\n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   position: [10, 20],\n *   radius: 30,\n *   qtIndex: function(node) {\n *     return Circle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       r: this.radius,\n *     }, node);\n *   },\n * });\n * ```\n */\nclass Circle {\n    /**\n     * Circle Constructor\n     * @param props - Circle properties\n     * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n     */\n    constructor(props) {\n        this.x = props.x;\n        this.y = props.y;\n        this.r = props.r;\n        this.data = props.data;\n    }\n    /**\n     * Determine which quadrant this circle belongs to.\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node) {\n        const indexes = [], w2 = node.width / 2, h2 = node.height / 2, x2 = node.x + w2, y2 = node.y + h2;\n        //an array of node origins where the array index equals the node index\n        const nodes = [\n            [x2, node.y],\n            [node.x, node.y],\n            [node.x, y2],\n            [x2, y2],\n        ];\n        //test all nodes for circle intersections\n        for (let i = 0; i < nodes.length; i++) {\n            if (Circle.intersectRect(this.x, this.y, this.r, nodes[i][0], nodes[i][1], nodes[i][0] + w2, nodes[i][1] + h2)) {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n    /**\n     * Check if a circle intersects an axis aligned rectangle.\n     * @beta\n     * @see https://yal.cc/rectangle-circle-intersection-test/\n     * @param x - circle center X\n     * @param y - circle center Y\n     * @param r - circle radius\n     * @param minX - rectangle start X\n     * @param minY - rectangle start Y\n     * @param maxX - rectangle end X\n     * @param maxY - rectangle end Y\n     * @returns true if circle intersects rectangle\n     *\n     * @example Check if a circle intersects a rectangle:\n     * ```javascript\n     * const circ = { x: 10, y: 20, r: 30 };\n     * const rect = { x: 40, y: 50, width: 60, height: 70 };\n     * const intersect = Circle.intersectRect(\n     *   circ.x,\n     *   circ.y,\n     *   circ.r,\n     *   rect.x,\n     *   rect.y,\n     *   rect.x + rect.width,\n     *   rect.y + rect.height,\n     * );\n     * console.log(circle, rect, 'intersect?', intersect);\n     * ```\n     */\n    static intersectRect(x, y, r, minX, minY, maxX, maxY) {\n        const deltaX = x - Math.max(minX, Math.min(x, maxX));\n        const deltaY = y - Math.max(minY, Math.min(y, maxY));\n        return (deltaX * deltaX + deltaY * deltaY) < (r * r);\n    }\n}\n\n/**\n * Class representing a Line\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n *\n * @example Without custom data (JS/TS):\n * ```typescript\n * const line = new Line({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n * });\n * ```\n *\n * @example With custom data (JS/TS):\n * ```javascript\n * const line = new Line({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n *   data: {\n *     name: 'Jane',\n *     health: 100,\n *   },\n * });\n * ```\n *\n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n *\n * // Typescript will infer the type of the data property\n * const line1 = new Line({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n *   data: entity,\n * });\n *\n * // You can also pass in a generic type for the data property\n * const line2 = new Line<ObjectData>({\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n * });\n * line2.data = entity;\n * ```\n *\n * @example With custom class extending Line (implements {@link LineGeometry} (x1, y1, x2, y2)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Laser extends Line {\n *\n *   constructor(props) {\n *     // call super to set x1, y1, x2, y2 (and data, if given)\n *     super(props);\n *     this.color = props.color;\n *   }\n * }\n *\n * const laser = new Laser({\n *   color: 'green',\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n * });\n * ```\n *\n * @example With custom class and mapping {@link LineGeometry}:\n * ```javascript\n * // no need to extend if you don't implement LineGeometry\n * class Laser {\n *\n *   constructor(color) {\n *     this.color = color;\n *     this.start = [10, 20];\n *     this.end = [30, 40];\n *   }\n *\n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to LineGeometry\n *     return Line.prototype.qtIndex.call({\n *       x1: this.start[0],\n *       y1: this.start[1],\n *       x2: this.end[0],\n *       y2: this.end[1],\n *     }, node);\n *   }\n * }\n *\n * const laser = new Laser('green');\n * ```\n *\n * @example With custom object that implements {@link LineGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   x1: 10,\n *   y1: 20,\n *   x2: 30,\n *   y2: 40,\n *   qtIndex: Line.prototype.qtIndex,\n * });\n * ```\n *\n * @example With custom object and mapping {@link LineGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible.\n * // Using this technique, each object would have it's own qtIndex method.\n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane',\n *   health: 100,\n *   start: [10, 20],\n *   end: [30, 40],\n *   qtIndex: function(node) {\n *     return Line.prototype.qtIndex.call({\n *       x1: this.start[0],\n *       y1: this.start[1],\n *       x2: this.end[0],\n *       y2: this.end[1],\n *     }, node);\n *   },\n * });\n * ```\n */\nclass Line {\n    /**\n     * Line Constructor\n     * @param props - Line properties\n     * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n     */\n    constructor(props) {\n        this.x1 = props.x1;\n        this.y1 = props.y1;\n        this.x2 = props.x2;\n        this.y2 = props.y2;\n        this.data = props.data;\n    }\n    /**\n     * Determine which quadrant this line belongs to.\n     * @beta\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node) {\n        const indexes = [], w2 = node.width / 2, h2 = node.height / 2, x2 = node.x + w2, y2 = node.y + h2;\n        //an array of node origins where the array index equals the node index\n        const nodes = [\n            [x2, node.y],\n            [node.x, node.y],\n            [node.x, y2],\n            [x2, y2],\n        ];\n        //test all nodes for line intersections\n        for (let i = 0; i < nodes.length; i++) {\n            if (Line.intersectRect(this.x1, this.y1, this.x2, this.y2, nodes[i][0], nodes[i][1], nodes[i][0] + w2, nodes[i][1] + h2)) {\n                indexes.push(i);\n            }\n        }\n        return indexes;\n    }\n    /**\n     * check if a line segment (the first 4 parameters) intersects an axis aligned rectangle (the last 4 parameters)\n     * @beta\n     *\n     * @remarks\n     * There is a bug where detection fails on corner intersections\n     * when the line enters/exits the node exactly at corners (45°)\n     * {@link https://stackoverflow.com/a/18292964/860205}\n     *\n     * @param x1 - line start X\n     * @param y1 - line start Y\n     * @param x2 - line end X\n     * @param y2 - line end Y\n     * @param minX - rectangle start X\n     * @param minY - rectangle start Y\n     * @param maxX - rectangle end X\n     * @param maxY - rectangle end Y\n     * @returns true if the line segment intersects the axis aligned rectangle\n     */\n    static intersectRect(x1, y1, x2, y2, minX, minY, maxX, maxY) {\n        // Completely outside\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n            return false;\n        // Single point inside\n        if ((x1 >= minX && x1 <= maxX && y1 >= minY && y1 <= maxY) || (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY))\n            return true;\n        const m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY)\n            return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY)\n            return true;\n        let x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX)\n            return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX)\n            return true;\n        return false;\n    }\n}\n\nexport { Circle, Line, Quadtree, Rectangle };\n","<script setup lang=\"ts\">\nimport { ref, watchEffect, computed, onMounted, unref } from \"vue\";\n\nimport { Quadtree, Rectangle } from \"@timohausmann/quadtree-ts\";\n\nimport type { Annotation, Category, Vector3 } from \"../types/index.ts\";\n\nconst LINE_OPACITY = 0.9;\nconst LINE_WIDTH = 2; // in pixels\n\nconst CATEGORY_COLORS: Vector3<number>[] = [\n  [255, 0, 0],\n  [0, 255, 0],\n  [0, 0, 255],\n  [255, 255, 0],\n  [255, 0, 255],\n  [0, 255, 255],\n];\n\nconst TOOLTIP_OFFSET = [8, 8];\nconst TOOLTIP_PADDING = 12; // fudge to keep tooltip from clipping/overflowing. In pixels\n\nlet annotationsTree: Quadtree<Rectangle<number>> | undefined = undefined;\n\nfunction doRectanglesOverlap(\n  recA: Rectangle<any>,\n  recB: Rectangle<any>,\n): boolean {\n  const noHOverlap =\n    recB.x >= recA.x + recA.width || recA.x >= recB.x + recB.width;\n\n  if (noHOverlap) {\n    return false;\n  }\n\n  const noVOverlap =\n    recB.y >= recA.y + recA.height || recA.y >= recB.y + recB.height;\n\n  return !noVOverlap;\n}\n\nconst props = defineProps<{\n  identifier: string;\n  src: string;\n  annotations?: Annotation[];\n  categories: { [key: number]: Category };\n  selected: boolean;\n  containerSelector?: string;\n}>();\n\nconst visibleCanvas = ref<HTMLCanvasElement>();\nconst visibleCtx = computed(() =>\n  visibleCanvas.value?.getContext(\"2d\", { alpha: true }),\n);\nconst pickingCanvas = ref<HTMLCanvasElement>();\nconst pickingCtx = computed(() =>\n  pickingCanvas.value?.getContext(\"2d\", { willReadFrequently: true }),\n);\nconst labelContainer = ref<HTMLDivElement>();\n\nconst imageSize = ref({ width: 0, height: 0 });\nconst img = ref<HTMLImageElement>();\nconst onImageLoad = () => {\n  imageSize.value = {\n    width: img.value?.naturalWidth ?? 0,\n    height: img.value?.naturalHeight ?? 0,\n  };\n};\n\nconst annotations = computed(() => unref(props.annotations) ?? []);\n\nconst annotationsWithColor = computed(() => {\n  return annotations.value.map((annotation) => {\n    const mutex = annotation.category_id ?? 0;\n    const color = CATEGORY_COLORS[mutex % CATEGORY_COLORS.length];\n    return { ...annotation, color };\n  });\n});\n\n// draw visible annotations\nwatchEffect(() => {\n  if (!visibleCanvas.value || !visibleCtx.value) {\n    return;\n  }\n  const canvas = visibleCanvas.value;\n  const ctx = visibleCtx.value;\n\n  canvas.width = imageSize.value.width;\n  canvas.height = imageSize.value.height;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  ctx.lineWidth = LINE_WIDTH;\n  annotationsWithColor.value.forEach(({ color, bbox }) => {\n    ctx.strokeStyle = `rgba(${[...color, LINE_OPACITY].join(\",\")})`;\n    ctx.strokeRect(bbox[0], bbox[1], bbox[2], bbox[3]);\n  });\n});\n\n// draw picking annotations\nwatchEffect(() => {\n  if (!pickingCtx.value || !pickingCanvas.value) {\n    return;\n  }\n  const canvas = pickingCanvas.value;\n  const ctx = pickingCtx.value;\n\n  canvas.width = imageSize.value.width;\n  canvas.height = imageSize.value.height;\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  annotationsTree = new Quadtree({\n    width: canvas.width,\n    height: canvas.height,\n    maxLevels: 8,\n    maxObjects: 10,\n  });\n\n  annotations.value.forEach((annotation, i) => {\n    const treeNode = new Rectangle<number>({\n      x: annotation.bbox[0],\n      y: annotation.bbox[1],\n      width: annotation.bbox[2],\n      height: annotation.bbox[3],\n      data: i,\n    });\n    annotationsTree?.insert(treeNode);\n    ctx.fillStyle = `rgb(255, 0, 0)`;\n    ctx.fillRect(\n      annotation.bbox[0],\n      annotation.bbox[1],\n      annotation.bbox[2],\n      annotation.bbox[3],\n    );\n  });\n});\n\ninterface HoverEvent {\n  id: string;\n}\n\ntype Events = {\n  hover: [HoverEvent];\n};\n\nconst emit = defineEmits<Events>();\n\nfunction hideLabel() {\n  if (labelContainer.value) labelContainer.value.style.visibility = \"hidden\";\n}\n\nonMounted(hideLabel);\n\nfunction mouseEnter() {\n  emit(\"hover\", { id: props.identifier });\n}\nfunction mouseLeave() {\n  emit(\"hover\", { id: \"\" });\n  hideLabel();\n}\n\nfunction displayToPixel(\n  x: number,\n  y: number,\n  canvas: HTMLCanvasElement,\n): [number, number] {\n  const canvasBounds = canvas.getBoundingClientRect();\n\n  const pixelX = (canvas.width * (x - canvasBounds.left)) / canvasBounds.width;\n  const pixelY = (canvas.height * (y - canvasBounds.top)) / canvasBounds.height;\n\n  return [pixelX, pixelY];\n}\n\nconst mounted = ref(false);\nonMounted(() => {\n  mounted.value = true;\n});\nconst container = computed(() => {\n  if (!mounted.value || !props.containerSelector) return null;\n  return document.querySelector(props.containerSelector);\n});\n\nfunction mouseMove(e: MouseEvent) {\n  if (\n    !pickingCanvas.value ||\n    pickingCanvas.value.width === 0 ||\n    !labelContainer.value ||\n    !annotationsTree ||\n    !props.categories ||\n    !props.annotations\n  ) {\n    return;\n  }\n  const ctx = pickingCtx.value;\n  if (!ctx) {\n    return;\n  }\n\n  const [pixelX, pixelY] = displayToPixel(\n    e.clientX,\n    e.clientY,\n    pickingCanvas.value,\n  );\n  const pixelValue = ctx.getImageData(pixelX, pixelY, 1, 1).data[0];\n  const pickedSomething = pixelValue > 0;\n\n  if (!pickedSomething) {\n    labelContainer.value.style.visibility = \"hidden\";\n    return;\n  }\n\n  labelContainer.value.style.visibility = \"visible\";\n\n  const pixelRectangle = new Rectangle<number>({\n    x: pixelX,\n    y: pixelY,\n    width: 2,\n    height: 2,\n  });\n  const hits = annotationsTree\n    .retrieve(pixelRectangle)\n    .filter((rect: any) => doRectanglesOverlap(rect, pixelRectangle))\n    .filter((hit) => hit.data != undefined)\n    .map((hit) => {\n      const annotation = annotationsWithColor.value[hit.data!];\n      const name =\n        props.categories[annotation.category_id]?.name ?? annotation.label;\n      const color = annotation.color;\n      const category = document.createElement(\"li\");\n      category.style.textShadow = `rgba(${color.join(\",\")},0.6) 1px 1px 3px`;\n      const annotationId = annotation.id ? ` : ${annotation.id}` : \"\";\n      category.textContent = `${name}${annotationId}`;\n      return category;\n    });\n\n  labelContainer.value.replaceChildren(...hits);\n\n  // Position the tooltip\n  const [x, y] = [e.offsetX, e.offsetY];\n  let posX = x + TOOLTIP_OFFSET[0];\n  let posY = y + TOOLTIP_OFFSET[1];\n\n  const tooltipRect = labelContainer.value.getBoundingClientRect();\n  const parentRect = pickingCanvas.value.getBoundingClientRect();\n  const containerRect = container.value?.getBoundingClientRect() ?? {\n    left: 0,\n    top: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n\n  const toolTipInContainer = {\n    left: parentRect.left + posX - containerRect.left,\n    top: parentRect.top + posY - containerRect.top,\n    width: tooltipRect.width + TOOLTIP_PADDING,\n    height: tooltipRect.height + TOOLTIP_PADDING,\n  };\n\n  // if text goes off the edge, move up and/or left\n  if (\n    toolTipInContainer.left + toolTipInContainer.width >\n    containerRect.width\n  ) {\n    posX = x - tooltipRect.width - TOOLTIP_OFFSET[0];\n  }\n  if (\n    toolTipInContainer.top + toolTipInContainer.height >\n    containerRect.height\n  ) {\n    posY = y - tooltipRect.height - TOOLTIP_OFFSET[1];\n  }\n\n  labelContainer.value.style.left = `${posX}px`;\n  labelContainer.value.style.top = `${posY}px`;\n}\n\nconst borderSize = computed(() => (props.selected ? \"4\" : \"0\"));\n\nconst src = computed(() => unref(props.src));\n</script>\n\n<template>\n  <div style=\"position: relative\">\n    <img\n      ref=\"img\"\n      :src=\"src\"\n      :style=\"{ outlineWidth: borderSize + 'px' }\"\n      style=\"width: 100%; outline-style: dotted; outline-color: red\"\n      @load=\"onImageLoad\"\n    />\n    <canvas\n      ref=\"visibleCanvas\"\n      style=\"width: 100%; position: absolute; left: 0; top: 0\"\n    />\n    <canvas\n      ref=\"pickingCanvas\"\n      style=\"opacity: 0; width: 100%; position: absolute; left: 0; top: 0\"\n      @mouseenter=\"mouseEnter\"\n      @mousemove=\"mouseMove\"\n      @mouseleave=\"mouseLeave\"\n    />\n    <ul\n      ref=\"labelContainer\"\n      style=\"\n        position: absolute;\n        z-index: 10;\n        padding: 0.4rem;\n        white-space: pre;\n        font-size: small;\n        border-radius: 0.2rem;\n        border-color: rgba(127, 127, 127, 0.75);\n        border-style: solid;\n        border-width: thin;\n        background-color: #efefef;\n        list-style-type: none;\n      \"\n    />\n  </div>\n</template>\n","import ImageDetection from \"./ImageDetection.vue\";\n\nexport default {\n  ImageDetection,\n};\n","import components from \"./components\";\n\nexport function install(Vue) {\n  Object.keys(components).forEach((name) => {\n    Vue.component(name, components[name]);\n  });\n}\n"],"names":["Quadtree","props","level","obj","width","height","x","y","coords","i","indexes","k","returnObjects","fast","indexOf","allObjects","bla","uniqueObjects","Rectangle","node","boundsCenterX","boundsCenterY","startIsNorth","startIsWest","endIsEast","endIsSouth","LINE_OPACITY","LINE_WIDTH","TOOLTIP_PADDING","components","CATEGORY_COLORS","TOOLTIP_OFFSET","annotationsTree","doRectanglesOverlap","recA","recB","__props","visibleCanvas","ref","visibleCtx","computed","_a","pickingCanvas","pickingCtx","labelContainer","imageSize","img","onImageLoad","_b","annotations","unref","annotationsWithColor","annotation","mutex","color","watchEffect","canvas","ctx","bbox","treeNode","emit","__emit","hideLabel","onMounted","mouseEnter","mouseLeave","displayToPixel","canvasBounds","pixelX","pixelY","mounted","container","mouseMove","e","pixelRectangle","hits","rect","hit","name","category","annotationId","posX","posY","tooltipRect","parentRect","containerRect","toolTipInContainer","borderSize","src","install","Vue"],"mappings":"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","x_google_ignoreList":[0]}