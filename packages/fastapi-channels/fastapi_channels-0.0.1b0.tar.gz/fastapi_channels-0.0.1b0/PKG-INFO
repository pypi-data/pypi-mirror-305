Metadata-Version: 2.1
Name: fastapi-channels
Version: 0.0.1b0
Summary: This project provides a simple setup for creating WebSocket communication channels using FastAPI.
Home-page: https://github.com/YGuang233/fastapi-channels
Author: BXZDYG
Author-email: banxingzhedeyangguang@gmail.com
License: MIT
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: fastapi>=0.110.0
Requires-Dist: broadcaster>=0.3.1
Requires-Dist: fastapi_limiter<=0.1.6
Provides-Extra: dev
Requires-Dist: pytest; extra == "dev"
Requires-Dist: black; extra == "dev"

# FastAPI-Channels

<p align="center">
  <a href="https://python.org">
    <img src="https://img.shields.io/badge/Python-3.8+-yellow?style=for-the-badge&logo=python&logoColor=white&labelColor=101010" alt="">
  </a>
  <a href="https://fastapi.tiangolo.com">
    <img src="https://img.shields.io/badge/FastAPI-0.111.0-00a393?style=for-the-badge&logo=fastapi&logoColor=white&labelColor=101010" alt="">
  </a>
</p>
&nbsp;&nbsp;æœ¬é¡¹ç›®ä¸»è¦ä¸ºFastAPIçš„WebSocketæ¥å£é€šè®¯æä¾›å¿«æ·æ–¹ä¾¿çš„å¤„ç†å’Œç®¡ç†åº“ã€‚ç‰¹è‰²åœ¨äºå°‘é‡ä»£ç å°±èƒ½å®ç°åŸºæœ¬çš„èŠå¤©å®¤çš„åŠŸèƒ½ã€‚
<br>
&nbsp;&nbsp;æœ¬é¡¹ç›®åˆé›†æˆäº†ä¼˜ç§€çš„ç¬¬ä¸‰æ–¹åº“å¦‚:broadcasterã€fastapi-limiterã€‚åœ¨æœ¬é¡¹ç›®å‡ä¿ç•™äº†è‡ªå®šä¹‰ä½¿ç”¨è¿™äº›åº“çš„ä½ç½®ã€‚
<br>
&nbsp;&nbsp;ä¸€èˆ¬çš„ï¼Œç”¨æˆ·ä½¿ç”¨æœ¬åº“ä»…éœ€è€ƒè™‘å¦‚ä½•ç¼–å†™ `action` æ¥å®ç°ä¼ è¾“çš„ç›®æ ‡,å’Œå¯¹åº”çš„`action`è®¿é—®çš„æƒé™ç±»å³å¯

# æ¡ˆä¾‹æ¼”ç¤º

```python
# -*- coding: utf-8 -*-
from contextlib import asynccontextmanager
from typing import AsyncIterator

from fastapi import FastAPI, WebSocket
from starlette.requests import Request
from starlette.templating import Jinja2Templates

from fastapi_channels import add_channel, action, limiter
from fastapi_channels.used import PersonChannel, GroupChannel
from fastapi_channels.exceptions import PermissionDenied
from fastapi_channels.permission import AllowAny
from fastapi_channels.utils.path import TemplatePath

templates = Jinja2Templates(TemplatePath)


@asynccontextmanager
async def lifespan(_: FastAPI) -> AsyncIterator[dict]:
    print('FastAPI-Channel startUp!')
    yield {"name": "main.py"}
    print('FastAPI-Channel shutDown!')


app = FastAPI(lifespan=lifespan)
add_channel(
    app,
    url="redis://localhost:6379",
    limiter_url="redis://localhost:6379"
)


@app.get('/')
async def homepage(request: Request):
    template = "broadcaster.html"
    context = {"request": request}
    return templates.TemplateResponse(template, context)


class PersonalChatRoom(PersonChannel):
    @limiter(times=2, seconds=3000)  # è¯·æ±‚è¶…é¢ ä½†æ˜¯ä¸å…³é—­websocket
    @action('count')  # request exceeded but websocket not closed
    async def get_count(self, websocket: WebSocket, channel: str, data: dict, **kwargs):
        await self.broadcast_to_personal(
            websocket, str(await self.get_connection_count(channel)))

    @action('message')  # å¹¿æ’­æ¶ˆæ¯ # broadcast message
    async def send_message(self, websocket: WebSocket, channel: str, data: dict, **kwargs):
        await self.broadcast_to_channel(channel, await self.encode(data))

    @action(deprecated=True)  # actionè¢«åºŸå¼ƒä¸å…³é—­websocket # action abandoned, websocket not closed
    async def deprecated_action(self, websocket: WebSocket, channel: str, data: dict, **kwargs):
        await self.broadcast_to_personal(websocket, 'å‘é€æ¶ˆæ¯')

    @action("permission_denied", permission=False)  # è¿”å›æƒé™ä¸è¶³çš„é”™è¯¯å“åº” # return error response with insufficient permissions
    async def permission_false(self, websocket: WebSocket, channel: str, data: dict, **kwargs):
        await self.broadcast_to_channel(channel, data.get('message'))

    @action(permission=AllowAny)  # æŠ›å‡ºå¼‚å¸¸ä¸ä½†å…³é—­websocket # raise an exception not only closes websocket
    async def error(self, websocket: WebSocket, channel: str, data: dict, **kwargs):
        raise PermissionDenied(close=False)

    @action()  # é€šè¿‡actionå…³é—­websocketè¿æ¥ # close websocket connection through action
    async def close(self, websocket: WebSocket, channel: str, data: dict, **kwargs):
        await websocket.close()


person_chatroom = PersonalChatRoom()


@app.websocket("/person", name='chatroom_ws')
async def person_chatroom_ws(websocket: WebSocket):
    await person_chatroom.connect(websocket)


class GroupChatRoom(GroupChannel):
    ...


group_chatroom = GroupChatRoom()


@app.websocket("/group", name='chatroom_ws')
async def group_chatroom_ws(websocket: WebSocket):
    await group_chatroom.connect(websocket)


async def join_room(websocket: WebSocket, channel: str, ):
    await group_chatroom.broadcast_to_personal(websocket, 'Join successfully')


async def leave_room(websocket: WebSocket, channel: str, ):
    # await group_chatroom.broadcast_to_personal(websocket, 'leave successfully')
    # error: ğŸ‘†å¦‚æœé€šè¿‡actionç¦»å¼€æˆ¿é—´ä¼šè¾“å‡ºè¿™ä¸ªï¼Œä½†æ˜¯å®¢æˆ·ç«¯ç›´æ¥å…³é—­ä¼šè¯±å‘websocketæ²¡æœ‰è¿›è¡Œè¿æ¥
    # æ‰€ä»¥è¿™ä¸€æ­¥åªèƒ½`broadcast_to_channel`æˆ–è€…åç»­å¤„ç†,è€Œä¸æ˜¯`broadcast_to_personal`
    #
    # error: ğŸ‘† If you leave the room through an action, it will output this,
    # but if the client closes it directly, it will trigger the websocket to not connect,
    # so this step can only be 'broadcast_to-uchannel' or processed later,
    # rather than 'broadcast_to-personal'`
    await group_chatroom.broadcast_to_channel(channel, 'leave successfully')


group_chatroom.add_event_handler('join', join_room)
group_chatroom.add_event_handler('leave', leave_room)


@limiter(seconds=3, times=1)
@group_chatroom.action('message')  # æ¶ˆæ¯å‘é€è§£æå’Œ#è£…é¥°å™¨å¼‚å¸¸
async def send_message(websocket: WebSocket, channel: str, data: dict, **kwargs):
    await group_chatroom.broadcast_to_channel(channel, data.get('message'))


@group_chatroom.action('error_true')  # æ¶ˆæ¯å‘é€è§£æå’Œå¼‚å¸¸
async def send_error_and_close(websocket: WebSocket, channel: str, data: dict, **kwargs):
    raise PermissionDenied(close=True)


@group_chatroom.action('error_false')  # æ¶ˆæ¯å‘é€è§£æå’Œå¼‚å¸¸
async def send_error(websocket: WebSocket, channel: str, data: dict, **kwargs):
    raise PermissionDenied(close=False)


@group_chatroom.action()  # å®¢æˆ·ç«¯å‘è¯·æ±‚ä¸»æœºå…³é—­
async def close(websocket: WebSocket, channel: str, data: dict, **kwargs):
    await websocket.close()


if __name__ == '__main__':
    import uvicorn

    uvicorn.run(app, port=8000)

```

# åŠŸèƒ½å’Œç›®æ ‡æ¸…å•

- [x] æƒé™è®¤è¯
    - [ ] åŸºç¡€çš„ç”¨æˆ·éªŒè¯çš„æ–¹æ¡ˆ
- [x] è‡ªå®šä¹‰å¼‚å¸¸å’Œå…¨å±€æ•è·,å¹¶ä¸”æŠ›å‡ºå¼‚å¸¸å¯æ§è¿æ¥çŠ¶æ€
- [ ] åˆ†é¡µå™¨
- [x] é™æµå™¨
    - [x] fastapi-limiter
- [ ] å…¼å®¹å¤šç§è¯·æ±‚ç±»å‹çš„æ”¯æŒ
    - [ ] Text
    - [x] JSON
    - [ ] Binary
- [x] é¢‘é“äº‹ä»¶
    - [x] é¢‘é“ç”Ÿå‘½å‘¨æœŸ(lifespanã€on_event)
- [ ] å¯è‡ªå®šä¹‰æ•°æ®ä¼ è¾“çš„ç»“æ„
    - [ ] è¯·æ±‚ä½“
    - [ ] å“åº”ä½“
    - [ ] åˆ†é¡µå™¨
- [ ] æŒä¹…åŒ–
    - [ ] å†å²è®°å½•çš„å­˜å‚¨
    - [ ] å†å²è®°å½•çš„è¯»å–
- [ ] åå°ç®¡ç†
    - [ ] Apiæ¥å£æ§åˆ¶
    - [ ] å®šæ—¶ç®¡ç†
- [ ] å›½é™…åŒ–å¼€å‘ã€‚locales åŸºäºä¾èµ–é¡¹å¯¹å“åº”ä½“çš„ä¿¡æ¯åŠ ä»¥å…¨å±€çš„è¯­è¨€é€‰æ‹©
- [ ] æµ‹è¯•ç¯å¢ƒæ­å»º
- [ ] å®Œå–„çš„doc

# å®‰è£…

```shell
pip install fastapi-channels
```

